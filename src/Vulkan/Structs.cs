/*  Please note that this file is generated by the VulkanSharp's generator. Do not edit directly.

    Licensed under the MIT license.

    Copyright 2016 Xamarin Inc

    This notice may not be removed from any source distribution.
    See LICENSE file for licensing details.
*/

using System;
using System.Runtime.InteropServices;

namespace Vulkan
{
    unsafe public partial class BaseOutStructure : MarshalledObject
    {
        BaseOutStructure lNext;
        public BaseOutStructure Next
        {
            get { return lNext; }
            set { lNext = value; M->Next = value != null ? (IntPtr)value.M : default(IntPtr); }
        }

        internal Interop.BaseOutStructure* M
        {
            get { return (Interop.BaseOutStructure*)native.Handle; }
        }

        public BaseOutStructure()
        {
            native = Interop.Structure.Allocate(typeof(Interop.BaseOutStructure));

            // M->SType = StructureType.BaseOutStructure;
        }

        internal BaseOutStructure(NativePointer pointer)
        {
            native = pointer;

            // M->SType = StructureType.BaseOutStructure;
        }
    }

    unsafe public partial class BaseInStructure : MarshalledObject
    {
        BaseInStructure lNext;
        public BaseInStructure Next
        {
            get { return lNext; }
            set { lNext = value; M->Next = value != null ? (IntPtr)value.M : default(IntPtr); }
        }

        internal Interop.BaseInStructure* M
        {
            get { return (Interop.BaseInStructure*)native.Handle; }
        }

        public BaseInStructure()
        {
            native = Interop.Structure.Allocate(typeof(Interop.BaseInStructure));

            // M->SType = StructureType.BaseInStructure;
        }

        internal BaseInStructure(NativePointer pointer)
        {
            native = pointer;

            // M->SType = StructureType.BaseInStructure;
        }
    }

    unsafe public partial struct Offset2D
    {
        public Int32 X;
        public Int32 Y;
    }

    unsafe public partial struct Offset3D
    {
        public Int32 X;
        public Int32 Y;
        public Int32 Z;
    }

    unsafe public partial struct Extent2D
    {
        public UInt32 Width;
        public UInt32 Height;
    }

    unsafe public partial struct Extent3D
    {
        public UInt32 Width;
        public UInt32 Height;
        public UInt32 Depth;
    }

    unsafe public partial struct Viewport
    {
        public float X;
        public float Y;
        public float Width;
        public float Height;
        public float MinDepth;
        public float MaxDepth;
    }

    unsafe public partial struct Rect2D
    {
        public Offset2D Offset;
        public Extent2D Extent;
    }

    unsafe public partial struct ClearRect
    {
        public Rect2D Rect;
        public UInt32 BaseArrayLayer;
        public UInt32 LayerCount;
    }

    unsafe public partial struct ComponentMapping
    {
        public ComponentSwizzle R;
        public ComponentSwizzle G;
        public ComponentSwizzle B;
        public ComponentSwizzle A;
    }

    unsafe public partial class PhysicalDeviceProperties : MarshalledObject
    {
        public UInt32 ApiVersion
        {
            get { return M->ApiVersion; }
            set { M->ApiVersion = value; }
        }

        public UInt32 DriverVersion
        {
            get { return M->DriverVersion; }
            set { M->DriverVersion = value; }
        }

        public UInt32 VendorId
        {
            get { return M->VendorId; }
            set { M->VendorId = value; }
        }

        public UInt32 DeviceId
        {
            get { return M->DeviceId; }
            set { M->DeviceId = value; }
        }

        public PhysicalDeviceType DeviceType
        {
            get { return M->DeviceType; }
            set { M->DeviceType = value; }
        }

        public string DeviceName
        {
            get { return Marshal.PtrToStringAnsi((IntPtr)M->DeviceName); }
            set { Interop.Structure.MarshalFixedSizeString(M->DeviceName, value, 256); }
        }

        public byte[] PipelineCacheUuid
        {
            get
            {
                var arr = new byte[16];
                for (int i = 0; i < 16; i++)
                    arr[i] = M->PipelineCacheUuid[i];
                return arr;
            }
            set
            {
                if (value.Length > 16)
                    throw new Exception("array too long");
                for (int i = 0; i < value.Length; i++)
                    M->PipelineCacheUuid[i] = value[i];
                for (int i = value.Length; i < 16; i++)
                    M->PipelineCacheUuid[i] = 0;
            }
        }

        PhysicalDeviceLimits lLimits;
        public PhysicalDeviceLimits Limits
        {
            get { return lLimits; }
            set { lLimits = value; M->Limits = value != null ? *value.M : default(Interop.PhysicalDeviceLimits); }
        }

        public PhysicalDeviceSparseProperties SparseProperties
        {
            get { return M->SparseProperties; }
            set { M->SparseProperties = value; }
        }

        internal Interop.PhysicalDeviceProperties* M
        {
            get { return (Interop.PhysicalDeviceProperties*)native.Handle; }
        }

        public PhysicalDeviceProperties()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PhysicalDeviceProperties));

            lLimits = new PhysicalDeviceLimits(new NativePointer(native.Reference, (IntPtr)(&M->Limits)));
        }

        internal PhysicalDeviceProperties(NativePointer pointer)
        {
            native = pointer;

            lLimits = new PhysicalDeviceLimits(new NativePointer(native.Reference, (IntPtr)(&M->Limits)));
        }
    }

    unsafe public partial class ExtensionProperties : MarshalledObject
    {
        /// <summary>
        /// extension name
        /// </summary>
        public string ExtensionName
        {
            get { return Marshal.PtrToStringAnsi((IntPtr)M->ExtensionName); }
            set { Interop.Structure.MarshalFixedSizeString(M->ExtensionName, value, 256); }
        }

        /// <summary>
        /// version of the extension specification implemented
        /// </summary>
        public UInt32 SpecVersion
        {
            get { return M->SpecVersion; }
            set { M->SpecVersion = value; }
        }

        internal Interop.ExtensionProperties* M
        {
            get { return (Interop.ExtensionProperties*)native.Handle; }
        }

        public ExtensionProperties()
        {
            native = Interop.Structure.Allocate(typeof(Interop.ExtensionProperties));
        }

        internal ExtensionProperties(NativePointer pointer)
        {
            native = pointer;
        }
    }

    unsafe public partial class LayerProperties : MarshalledObject
    {
        /// <summary>
        /// layer name
        /// </summary>
        public string LayerName
        {
            get { return Marshal.PtrToStringAnsi((IntPtr)M->LayerName); }
            set { Interop.Structure.MarshalFixedSizeString(M->LayerName, value, 256); }
        }

        /// <summary>
        /// version of the layer specification implemented
        /// </summary>
        public UInt32 SpecVersion
        {
            get { return M->SpecVersion; }
            set { M->SpecVersion = value; }
        }

        /// <summary>
        /// build or release version of the layer's library
        /// </summary>
        public UInt32 ImplementationVersion
        {
            get { return M->ImplementationVersion; }
            set { M->ImplementationVersion = value; }
        }

        /// <summary>
        /// Free-form description of the layer
        /// </summary>
        public string Description
        {
            get { return Marshal.PtrToStringAnsi((IntPtr)M->Description); }
            set { Interop.Structure.MarshalFixedSizeString(M->Description, value, 256); }
        }

        internal Interop.LayerProperties* M
        {
            get { return (Interop.LayerProperties*)native.Handle; }
        }

        public LayerProperties()
        {
            native = Interop.Structure.Allocate(typeof(Interop.LayerProperties));
        }

        internal LayerProperties(NativePointer pointer)
        {
            native = pointer;
        }
    }

    unsafe public partial class ApplicationInfo : MarshalledObject
    {
        public string ApplicationName
        {
            get { return Marshal.PtrToStringAnsi(M->ApplicationName); }
            set { M->ApplicationName = Marshal.StringToHGlobalAnsi(value); }
        }

        public UInt32 ApplicationVersion
        {
            get { return M->ApplicationVersion; }
            set { M->ApplicationVersion = value; }
        }

        public string EngineName
        {
            get { return Marshal.PtrToStringAnsi(M->EngineName); }
            set { M->EngineName = Marshal.StringToHGlobalAnsi(value); }
        }

        public UInt32 EngineVersion
        {
            get { return M->EngineVersion; }
            set { M->EngineVersion = value; }
        }

        public UInt32 ApiVersion
        {
            get { return M->ApiVersion; }
            set { M->ApiVersion = value; }
        }

        internal Interop.ApplicationInfo* M
        {
            get { return (Interop.ApplicationInfo*)native.Handle; }
        }

        public ApplicationInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.ApplicationInfo));

            M->SType = StructureType.ApplicationInfo;
        }

        internal ApplicationInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.ApplicationInfo;
        }
    }

    unsafe public partial class AllocationCallbacks : MarshalledObject
    {
        public IntPtr UserData
        {
            get { return M->UserData; }
            set { M->UserData = value; }
        }

        public IntPtr PfnAllocation
        {
            get { return M->PfnAllocation; }
            set { M->PfnAllocation = value; }
        }

        public IntPtr PfnReallocation
        {
            get { return M->PfnReallocation; }
            set { M->PfnReallocation = value; }
        }

        public IntPtr PfnFree
        {
            get { return M->PfnFree; }
            set { M->PfnFree = value; }
        }

        public IntPtr PfnInternalAllocation
        {
            get { return M->PfnInternalAllocation; }
            set { M->PfnInternalAllocation = value; }
        }

        public IntPtr PfnInternalFree
        {
            get { return M->PfnInternalFree; }
            set { M->PfnInternalFree = value; }
        }

        internal Interop.AllocationCallbacks* M
        {
            get { return (Interop.AllocationCallbacks*)native.Handle; }
        }

        public AllocationCallbacks()
        {
            native = Interop.Structure.Allocate(typeof(Interop.AllocationCallbacks));
        }

        internal AllocationCallbacks(NativePointer pointer)
        {
            native = pointer;
        }
    }

    unsafe public partial class DeviceQueueCreateInfo : MarshalledObject
    {
        public DeviceQueueCreateFlags Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        public UInt32 QueueFamilyIndex
        {
            get { return M->QueueFamilyIndex; }
            set { M->QueueFamilyIndex = value; }
        }

        public UInt32 QueueCount
        {
            get { return M->QueueCount; }
            set { M->QueueCount = value; }
        }

        NativeReference refQueuePriorities;
        public float[] QueuePriorities
        {
            get
            {
                if (M->QueueCount == 0)
                    return null;
                var values = new float[M->QueueCount];
                unsafe
                {
                    float* ptr = (float*)M->QueuePriorities;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->QueueCount = 0;
                    M->QueuePriorities = IntPtr.Zero;
                    return;
                }
                M->QueueCount = (uint)value.Length;
                refQueuePriorities = new NativeReference((int)(sizeof(float) * value.Length));
                M->QueuePriorities = refQueuePriorities.Handle;
                unsafe
                {
                    float* ptr = (float*)M->QueuePriorities;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        internal Interop.DeviceQueueCreateInfo* M
        {
            get { return (Interop.DeviceQueueCreateInfo*)native.Handle; }
        }

        public DeviceQueueCreateInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.DeviceQueueCreateInfo));

            M->SType = StructureType.DeviceQueueCreateInfo;
        }

        internal DeviceQueueCreateInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.DeviceQueueCreateInfo;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refQueuePriorities.Dispose();
            refQueuePriorities = null;
        }
    }

    unsafe public partial class DeviceCreateInfo : MarshalledObject
    {
        public DeviceCreateFlags Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        public UInt32 QueueCreateInfoCount
        {
            get { return M->QueueCreateInfoCount; }
            set { M->QueueCreateInfoCount = value; }
        }

        NativeReference refQueueCreateInfos;
        public DeviceQueueCreateInfo[] QueueCreateInfos
        {
            get
            {
                if (M->QueueCreateInfoCount == 0)
                    return null;
                var values = new DeviceQueueCreateInfo[M->QueueCreateInfoCount];
                unsafe
                {
                    Interop.DeviceQueueCreateInfo* ptr = (Interop.DeviceQueueCreateInfo*)M->QueueCreateInfos;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = new DeviceQueueCreateInfo();
                        *values[i].M = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->QueueCreateInfoCount = 0;
                    M->QueueCreateInfos = IntPtr.Zero;
                    return;
                }
                M->QueueCreateInfoCount = (uint)value.Length;
                refQueueCreateInfos = new NativeReference((int)(sizeof(Interop.DeviceQueueCreateInfo) * value.Length));
                M->QueueCreateInfos = refQueueCreateInfos.Handle;
                unsafe
                {
                    Interop.DeviceQueueCreateInfo* ptr = (Interop.DeviceQueueCreateInfo*)M->QueueCreateInfos;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = *value[i].M;
                    }
                }
            }
        }

        public UInt32 EnabledLayerCount
        {
            get { return M->EnabledLayerCount; }
            set { M->EnabledLayerCount = value; }
        }

        /// <summary>
        /// Ordered list of layer names to be enabled
        /// </summary>
        NativeReference refEnabledLayerNames;
        public string[] EnabledLayerNames
        {
            get
            {
                if (M->EnabledLayerCount == 0)
                    return null;
                var strings = new string[M->EnabledLayerCount];
                unsafe
                {
                    void** ptr = (void**)M->EnabledLayerNames;
                    for (int i = 0; i < M->EnabledLayerCount; i++)
                        strings[i] = Marshal.PtrToStringAnsi((IntPtr)ptr[i]);
                }
                return strings;
            }
            set
            {
                if (value == null)
                {
                    M->EnabledLayerCount = 0;
                    M->EnabledLayerNames = IntPtr.Zero;
                    return;
                }
                M->EnabledLayerCount = (uint)value.Length;
                refEnabledLayerNames = new NativeReference((int)(sizeof(IntPtr) * M->EnabledLayerCount));
                M->EnabledLayerNames = refEnabledLayerNames.Handle;
                unsafe
                {
                    void** ptr = (void**)M->EnabledLayerNames;
                    for (int i = 0; i < M->EnabledLayerCount; i++)
                        ptr[i] = (void*) Marshal.StringToHGlobalAnsi(value[i]);
                }
            }
        }

        public UInt32 EnabledExtensionCount
        {
            get { return M->EnabledExtensionCount; }
            set { M->EnabledExtensionCount = value; }
        }

        NativeReference refEnabledExtensionNames;
        public string[] EnabledExtensionNames
        {
            get
            {
                if (M->EnabledExtensionCount == 0)
                    return null;
                var strings = new string[M->EnabledExtensionCount];
                unsafe
                {
                    void** ptr = (void**)M->EnabledExtensionNames;
                    for (int i = 0; i < M->EnabledExtensionCount; i++)
                        strings[i] = Marshal.PtrToStringAnsi((IntPtr)ptr[i]);
                }
                return strings;
            }
            set
            {
                if (value == null)
                {
                    M->EnabledExtensionCount = 0;
                    M->EnabledExtensionNames = IntPtr.Zero;
                    return;
                }
                M->EnabledExtensionCount = (uint)value.Length;
                refEnabledExtensionNames = new NativeReference((int)(sizeof(IntPtr) * M->EnabledExtensionCount));
                M->EnabledExtensionNames = refEnabledExtensionNames.Handle;
                unsafe
                {
                    void** ptr = (void**)M->EnabledExtensionNames;
                    for (int i = 0; i < M->EnabledExtensionCount; i++)
                        ptr[i] = (void*) Marshal.StringToHGlobalAnsi(value[i]);
                }
            }
        }

        public PhysicalDeviceFeatures EnabledFeatures
        {
            get { return (PhysicalDeviceFeatures)Interop.Structure.MarshalPointerToObject(M->EnabledFeatures, typeof(PhysicalDeviceFeatures)); }
            set { M->EnabledFeatures = Interop.Structure.MarshalObjectToPointer(M->EnabledFeatures, value); }
        }

        internal Interop.DeviceCreateInfo* M
        {
            get { return (Interop.DeviceCreateInfo*)native.Handle; }
        }

        public DeviceCreateInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.DeviceCreateInfo));

            M->SType = StructureType.DeviceCreateInfo;
        }

        internal DeviceCreateInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.DeviceCreateInfo;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refQueueCreateInfos.Dispose();
            refQueueCreateInfos = null;
            refEnabledLayerNames.Dispose();
            refEnabledLayerNames = null;
            refEnabledExtensionNames.Dispose();
            refEnabledExtensionNames = null;
        }
    }

    unsafe public partial class InstanceCreateInfo : MarshalledObject
    {
        public InstanceCreateFlags Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        ApplicationInfo lApplicationInfo;
        public ApplicationInfo ApplicationInfo
        {
            get { return lApplicationInfo; }
            set { lApplicationInfo = value; M->ApplicationInfo = value != null ? (IntPtr)value.M : default(IntPtr); }
        }

        public UInt32 EnabledLayerCount
        {
            get { return M->EnabledLayerCount; }
            set { M->EnabledLayerCount = value; }
        }

        /// <summary>
        /// Ordered list of layer names to be enabled
        /// </summary>
        NativeReference refEnabledLayerNames;
        public string[] EnabledLayerNames
        {
            get
            {
                if (M->EnabledLayerCount == 0)
                    return null;
                var strings = new string[M->EnabledLayerCount];
                unsafe
                {
                    void** ptr = (void**)M->EnabledLayerNames;
                    for (int i = 0; i < M->EnabledLayerCount; i++)
                        strings[i] = Marshal.PtrToStringAnsi((IntPtr)ptr[i]);
                }
                return strings;
            }
            set
            {
                if (value == null)
                {
                    M->EnabledLayerCount = 0;
                    M->EnabledLayerNames = IntPtr.Zero;
                    return;
                }
                M->EnabledLayerCount = (uint)value.Length;
                refEnabledLayerNames = new NativeReference((int)(sizeof(IntPtr) * M->EnabledLayerCount));
                M->EnabledLayerNames = refEnabledLayerNames.Handle;
                unsafe
                {
                    void** ptr = (void**)M->EnabledLayerNames;
                    for (int i = 0; i < M->EnabledLayerCount; i++)
                        ptr[i] = (void*) Marshal.StringToHGlobalAnsi(value[i]);
                }
            }
        }

        public UInt32 EnabledExtensionCount
        {
            get { return M->EnabledExtensionCount; }
            set { M->EnabledExtensionCount = value; }
        }

        /// <summary>
        /// Extension names to be enabled
        /// </summary>
        NativeReference refEnabledExtensionNames;
        public string[] EnabledExtensionNames
        {
            get
            {
                if (M->EnabledExtensionCount == 0)
                    return null;
                var strings = new string[M->EnabledExtensionCount];
                unsafe
                {
                    void** ptr = (void**)M->EnabledExtensionNames;
                    for (int i = 0; i < M->EnabledExtensionCount; i++)
                        strings[i] = Marshal.PtrToStringAnsi((IntPtr)ptr[i]);
                }
                return strings;
            }
            set
            {
                if (value == null)
                {
                    M->EnabledExtensionCount = 0;
                    M->EnabledExtensionNames = IntPtr.Zero;
                    return;
                }
                M->EnabledExtensionCount = (uint)value.Length;
                refEnabledExtensionNames = new NativeReference((int)(sizeof(IntPtr) * M->EnabledExtensionCount));
                M->EnabledExtensionNames = refEnabledExtensionNames.Handle;
                unsafe
                {
                    void** ptr = (void**)M->EnabledExtensionNames;
                    for (int i = 0; i < M->EnabledExtensionCount; i++)
                        ptr[i] = (void*) Marshal.StringToHGlobalAnsi(value[i]);
                }
            }
        }

        internal Interop.InstanceCreateInfo* M
        {
            get { return (Interop.InstanceCreateInfo*)native.Handle; }
        }

        public InstanceCreateInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.InstanceCreateInfo));

            M->SType = StructureType.InstanceCreateInfo;
        }

        internal InstanceCreateInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.InstanceCreateInfo;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refEnabledLayerNames.Dispose();
            refEnabledLayerNames = null;
            refEnabledExtensionNames.Dispose();
            refEnabledExtensionNames = null;
        }
    }

    unsafe public partial struct QueueFamilyProperties
    {
        /// <summary>
        /// Queue flags
        /// </summary>
        public QueueFlags QueueFlags;
        public UInt32 QueueCount;
        public UInt32 TimestampValidBits;
        /// <summary>
        /// Minimum alignment requirement for image transfers
        /// </summary>
        public Extent3D MinImageTransferGranularity;
    }

    unsafe public partial class PhysicalDeviceMemoryProperties : MarshalledObject
    {
        public UInt32 MemoryTypeCount
        {
            get { return M->MemoryTypeCount; }
            set { M->MemoryTypeCount = value; }
        }

        public MemoryType[] MemoryTypes
        {
            get
            {
                var arr = new MemoryType[M->MemoryTypeCount];
                for (int i = 0; i < M->MemoryTypeCount; i++)
                    unsafe
                    {
                        arr[i] = (&M->MemoryTypes0)[i];
                    }
                return arr;
            }
            set
            {
                if (value.Length > M->MemoryTypeCount)
                    throw new Exception("array too long");
                M->MemoryTypeCount = (uint)value.Length;
                for (int i = 0; i < value.Length; i++)
                    unsafe
                    {
                        (&M->MemoryTypes0)[i] = value[i];
                    }
            }
        }

        public UInt32 MemoryHeapCount
        {
            get { return M->MemoryHeapCount; }
            set { M->MemoryHeapCount = value; }
        }

        public MemoryHeap[] MemoryHeaps
        {
            get
            {
                var arr = new MemoryHeap[M->MemoryHeapCount];
                for (int i = 0; i < M->MemoryHeapCount; i++)
                    unsafe
                    {
                        arr[i] = (&M->MemoryHeaps0)[i];
                    }
                return arr;
            }
            set
            {
                if (value.Length > M->MemoryHeapCount)
                    throw new Exception("array too long");
                M->MemoryHeapCount = (uint)value.Length;
                for (int i = 0; i < value.Length; i++)
                    unsafe
                    {
                        (&M->MemoryHeaps0)[i] = value[i];
                    }
            }
        }

        internal Interop.PhysicalDeviceMemoryProperties* M
        {
            get { return (Interop.PhysicalDeviceMemoryProperties*)native.Handle; }
        }

        public PhysicalDeviceMemoryProperties()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PhysicalDeviceMemoryProperties));
        }

        internal PhysicalDeviceMemoryProperties(NativePointer pointer)
        {
            native = pointer;
        }
    }

    unsafe public partial class MemoryAllocateInfo : MarshalledObject
    {
        /// <summary>
        /// Size of memory allocation
        /// </summary>
        public DeviceSize AllocationSize
        {
            get { return M->AllocationSize; }
            set { M->AllocationSize = value; }
        }

        /// <summary>
        /// Index of the of the memory type to allocate from
        /// </summary>
        public UInt32 MemoryTypeIndex
        {
            get { return M->MemoryTypeIndex; }
            set { M->MemoryTypeIndex = value; }
        }

        internal Interop.MemoryAllocateInfo* M
        {
            get { return (Interop.MemoryAllocateInfo*)native.Handle; }
        }

        public MemoryAllocateInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.MemoryAllocateInfo));

            M->SType = StructureType.MemoryAllocateInfo;
        }

        internal MemoryAllocateInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.MemoryAllocateInfo;
        }
    }

    unsafe public partial struct MemoryRequirements
    {
        /// <summary>
        /// Specified in bytes
        /// </summary>
        public DeviceSize Size;
        /// <summary>
        /// Specified in bytes
        /// </summary>
        public DeviceSize Alignment;
        /// <summary>
        /// Bitmask of the allowed memory type indices into memoryTypes[] for this object
        /// </summary>
        public UInt32 MemoryTypeBits;
    }

    unsafe public partial struct SparseImageFormatProperties
    {
        public ImageAspectFlags AspectMask;
        public Extent3D ImageGranularity;
        public SparseImageFormatFlags Flags;
    }

    unsafe public partial struct SparseImageMemoryRequirements
    {
        public SparseImageFormatProperties FormatProperties;
        public UInt32 ImageMipTailFirstLod;
        /// <summary>
        /// Specified in bytes, must be a multiple of sparse block size in bytes / alignment
        /// </summary>
        public DeviceSize ImageMipTailSize;
        /// <summary>
        /// Specified in bytes, must be a multiple of sparse block size in bytes / alignment
        /// </summary>
        public DeviceSize ImageMipTailOffset;
        /// <summary>
        /// Specified in bytes, must be a multiple of sparse block size in bytes / alignment
        /// </summary>
        public DeviceSize ImageMipTailStride;
    }

    unsafe public partial struct MemoryType
    {
        /// <summary>
        /// Memory properties of this memory type
        /// </summary>
        public MemoryPropertyFlags PropertyFlags;
        /// <summary>
        /// Index of the memory heap allocations of this memory type are taken from
        /// </summary>
        public UInt32 HeapIndex;
    }

    unsafe public partial struct MemoryHeap
    {
        /// <summary>
        /// Available memory in the heap
        /// </summary>
        public DeviceSize Size;
        /// <summary>
        /// Flags for the heap
        /// </summary>
        public MemoryHeapFlags Flags;
    }

    unsafe public partial class MappedMemoryRange : MarshalledObject
    {
        /// <summary>
        /// Mapped memory object
        /// </summary>
        DeviceMemory lMemory;
        public DeviceMemory Memory
        {
            get { return lMemory; }
            set { lMemory = value; M->Memory = value != null ? (UInt64)value.M : default(UInt64); }
        }

        /// <summary>
        /// Offset within the memory object where the range starts
        /// </summary>
        public DeviceSize Offset
        {
            get { return M->Offset; }
            set { M->Offset = value; }
        }

        /// <summary>
        /// Size of the range within the memory object
        /// </summary>
        public DeviceSize Size
        {
            get { return M->Size; }
            set { M->Size = value; }
        }

        internal Interop.MappedMemoryRange* M
        {
            get { return (Interop.MappedMemoryRange*)native.Handle; }
        }

        public MappedMemoryRange()
        {
            native = Interop.Structure.Allocate(typeof(Interop.MappedMemoryRange));

            M->SType = StructureType.MappedMemoryRange;
        }

        internal MappedMemoryRange(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.MappedMemoryRange;
        }
    }

    unsafe public partial struct FormatProperties
    {
        /// <summary>
        /// Format features in case of linear tiling
        /// </summary>
        public FormatFeatureFlags LinearTilingFeatures;
        /// <summary>
        /// Format features in case of optimal tiling
        /// </summary>
        public FormatFeatureFlags OptimalTilingFeatures;
        /// <summary>
        /// Format features supported by buffers
        /// </summary>
        public FormatFeatureFlags BufferFeatures;
    }

    unsafe public partial struct ImageFormatProperties
    {
        /// <summary>
        /// max image dimensions for this resource type
        /// </summary>
        public Extent3D MaxExtent;
        /// <summary>
        /// max number of mipmap levels for this resource type
        /// </summary>
        public UInt32 MaxMipLevels;
        /// <summary>
        /// max array size for this resource type
        /// </summary>
        public UInt32 MaxArrayLayers;
        /// <summary>
        /// supported sample counts for this resource type
        /// </summary>
        public SampleCountFlags SampleCounts;
        /// <summary>
        /// max size(in bytes) of this resource type
        /// </summary>
        public DeviceSize MaxResourceSize;
    }

    unsafe public partial class DescriptorBufferInfo : MarshalledObject
    {
        /// <summary>
        /// Buffer used for this descriptor slot.
        /// </summary>
        Buffer lBuffer;
        public Buffer Buffer
        {
            get { return lBuffer; }
            set { lBuffer = value; M->Buffer = value != null ? (UInt64)value.M : default(UInt64); }
        }

        /// <summary>
        /// Base offset from buffer start in bytes to update in the descriptor set.
        /// </summary>
        public DeviceSize Offset
        {
            get { return M->Offset; }
            set { M->Offset = value; }
        }

        /// <summary>
        /// Size in bytes of the buffer resource for this descriptor update.
        /// </summary>
        public DeviceSize Range
        {
            get { return M->Range; }
            set { M->Range = value; }
        }

        internal Interop.DescriptorBufferInfo* M
        {
            get { return (Interop.DescriptorBufferInfo*)native.Handle; }
        }

        public DescriptorBufferInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.DescriptorBufferInfo));

        }

        internal DescriptorBufferInfo(NativePointer pointer)
        {
            native = pointer;

        }
    }

    unsafe public partial class DescriptorImageInfo : MarshalledObject
    {
        /// <summary>
        /// Sampler to write to the descriptor in case it is a SAMPLER or COMBINED_IMAGE_SAMPLER descriptor. Ignored otherwise.
        /// </summary>
        Sampler lSampler;
        public Sampler Sampler
        {
            get { return lSampler; }
            set { lSampler = value; M->Sampler = value != null ? (UInt64)value.M : default(UInt64); }
        }

        /// <summary>
        /// Image view to write to the descriptor in case it is a SAMPLED_IMAGE, STORAGE_IMAGE, COMBINED_IMAGE_SAMPLER, or INPUT_ATTACHMENT descriptor. Ignored otherwise.
        /// </summary>
        ImageView lImageView;
        public ImageView ImageView
        {
            get { return lImageView; }
            set { lImageView = value; M->ImageView = value != null ? (UInt64)value.M : default(UInt64); }
        }

        /// <summary>
        /// Layout the image is expected to be in when accessed using this descriptor(only used if imageView is not VK_NULL_HANDLE).
        /// </summary>
        public ImageLayout ImageLayout
        {
            get { return M->ImageLayout; }
            set { M->ImageLayout = value; }
        }

        internal Interop.DescriptorImageInfo* M
        {
            get { return (Interop.DescriptorImageInfo*)native.Handle; }
        }

        public DescriptorImageInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.DescriptorImageInfo));

        }

        internal DescriptorImageInfo(NativePointer pointer)
        {
            native = pointer;

        }
    }

    unsafe public partial class WriteDescriptorSet : MarshalledObject
    {
        /// <summary>
        /// Destination descriptor set
        /// </summary>
        DescriptorSet lDstSet;
        public DescriptorSet DstSet
        {
            get { return lDstSet; }
            set { lDstSet = value; M->DstSet = value != null ? (UInt64)value.M : default(UInt64); }
        }

        /// <summary>
        /// Binding within the destination descriptor set to write
        /// </summary>
        public UInt32 DstBinding
        {
            get { return M->DstBinding; }
            set { M->DstBinding = value; }
        }

        /// <summary>
        /// Array element within the destination binding to write
        /// </summary>
        public UInt32 DstArrayElement
        {
            get { return M->DstArrayElement; }
            set { M->DstArrayElement = value; }
        }

        /// <summary>
        /// Number of descriptors to write(determines the size of the array pointed by pDescriptors)
        /// </summary>
        public UInt32 DescriptorCount
        {
            get { return M->DescriptorCount; }
            set { M->DescriptorCount = value; }
        }

        /// <summary>
        /// Descriptor type to write(determines which members of the array pointed by pDescriptors are going to be used)
        /// </summary>
        public DescriptorType DescriptorType
        {
            get { return M->DescriptorType; }
            set { M->DescriptorType = value; }
        }

        /// <summary>
        /// Sampler, image view, and layout for SAMPLER, COMBINED_IMAGE_SAMPLER, {SAMPLED,STORAGE}_IMAGE, and INPUT_ATTACHMENT descriptor types.
        /// </summary>
        NativeReference refImageInfo;
        public DescriptorImageInfo[] ImageInfo
        {
            get
            {
                if (M->DescriptorCount == 0)
                    return null;
                var values = new DescriptorImageInfo[M->DescriptorCount];
                unsafe
                {
                    Interop.DescriptorImageInfo* ptr = (Interop.DescriptorImageInfo*)M->ImageInfo;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = new DescriptorImageInfo();
                        *values[i].M = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->DescriptorCount = 0;
                    M->ImageInfo = IntPtr.Zero;
                    return;
                }
                M->DescriptorCount = (uint)value.Length;
                refImageInfo = new NativeReference((int)(sizeof(Interop.DescriptorImageInfo) * value.Length));
                M->ImageInfo = refImageInfo.Handle;
                unsafe
                {
                    Interop.DescriptorImageInfo* ptr = (Interop.DescriptorImageInfo*)M->ImageInfo;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = *value[i].M;
                    }
                }
            }
        }

        /// <summary>
        /// Raw buffer, size, and offset for {UNIFORM,STORAGE}_BUFFER[_DYNAMIC] descriptor types.
        /// </summary>
        NativeReference refBufferInfo;
        public DescriptorBufferInfo[] BufferInfo
        {
            get
            {
                if (M->DescriptorCount == 0)
                    return null;
                var values = new DescriptorBufferInfo[M->DescriptorCount];
                unsafe
                {
                    Interop.DescriptorBufferInfo* ptr = (Interop.DescriptorBufferInfo*)M->BufferInfo;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = new DescriptorBufferInfo();
                        *values[i].M = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->DescriptorCount = 0;
                    M->BufferInfo = IntPtr.Zero;
                    return;
                }
                M->DescriptorCount = (uint)value.Length;
                refBufferInfo = new NativeReference((int)(sizeof(Interop.DescriptorBufferInfo) * value.Length));
                M->BufferInfo = refBufferInfo.Handle;
                unsafe
                {
                    Interop.DescriptorBufferInfo* ptr = (Interop.DescriptorBufferInfo*)M->BufferInfo;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = *value[i].M;
                    }
                }
            }
        }

        /// <summary>
        /// Buffer view to write to the descriptor for {UNIFORM,STORAGE}_TEXEL_BUFFER descriptor types.
        /// </summary>
        NativeReference refTexelBufferView;
        public BufferView[] TexelBufferView
        {
            get
            {
                if (M->DescriptorCount == 0)
                    return null;
                var values = new BufferView[M->DescriptorCount];
                unsafe
                {
                    UInt64* ptr = (UInt64*)M->TexelBufferView;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = new BufferView();
                        values[i].M = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->DescriptorCount = 0;
                    M->TexelBufferView = IntPtr.Zero;
                    return;
                }
                M->DescriptorCount = (uint)value.Length;
                refTexelBufferView = new NativeReference((int)(sizeof(UInt64) * value.Length));
                M->TexelBufferView = refTexelBufferView.Handle;
                unsafe
                {
                    UInt64* ptr = (UInt64*)M->TexelBufferView;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i].M;
                    }
                }
            }
        }

        internal Interop.WriteDescriptorSet* M
        {
            get { return (Interop.WriteDescriptorSet*)native.Handle; }
        }

        public WriteDescriptorSet()
        {
            native = Interop.Structure.Allocate(typeof(Interop.WriteDescriptorSet));

            M->SType = StructureType.WriteDescriptorSet;
        }

        internal WriteDescriptorSet(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.WriteDescriptorSet;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refImageInfo.Dispose();
            refImageInfo = null;
            refBufferInfo.Dispose();
            refBufferInfo = null;
            refTexelBufferView.Dispose();
            refTexelBufferView = null;
        }
    }

    unsafe public partial class CopyDescriptorSet : MarshalledObject
    {
        /// <summary>
        /// Source descriptor set
        /// </summary>
        DescriptorSet lSrcSet;
        public DescriptorSet SrcSet
        {
            get { return lSrcSet; }
            set { lSrcSet = value; M->SrcSet = value != null ? (UInt64)value.M : default(UInt64); }
        }

        /// <summary>
        /// Binding within the source descriptor set to copy from
        /// </summary>
        public UInt32 SrcBinding
        {
            get { return M->SrcBinding; }
            set { M->SrcBinding = value; }
        }

        /// <summary>
        /// Array element within the source binding to copy from
        /// </summary>
        public UInt32 SrcArrayElement
        {
            get { return M->SrcArrayElement; }
            set { M->SrcArrayElement = value; }
        }

        /// <summary>
        /// Destination descriptor set
        /// </summary>
        DescriptorSet lDstSet;
        public DescriptorSet DstSet
        {
            get { return lDstSet; }
            set { lDstSet = value; M->DstSet = value != null ? (UInt64)value.M : default(UInt64); }
        }

        /// <summary>
        /// Binding within the destination descriptor set to copy to
        /// </summary>
        public UInt32 DstBinding
        {
            get { return M->DstBinding; }
            set { M->DstBinding = value; }
        }

        /// <summary>
        /// Array element within the destination binding to copy to
        /// </summary>
        public UInt32 DstArrayElement
        {
            get { return M->DstArrayElement; }
            set { M->DstArrayElement = value; }
        }

        /// <summary>
        /// Number of descriptors to write(determines the size of the array pointed by pDescriptors)
        /// </summary>
        public UInt32 DescriptorCount
        {
            get { return M->DescriptorCount; }
            set { M->DescriptorCount = value; }
        }

        internal Interop.CopyDescriptorSet* M
        {
            get { return (Interop.CopyDescriptorSet*)native.Handle; }
        }

        public CopyDescriptorSet()
        {
            native = Interop.Structure.Allocate(typeof(Interop.CopyDescriptorSet));

            M->SType = StructureType.CopyDescriptorSet;
        }

        internal CopyDescriptorSet(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.CopyDescriptorSet;
        }
    }

    unsafe public partial class BufferCreateInfo : MarshalledObject
    {
        /// <summary>
        /// Buffer creation flags
        /// </summary>
        public BufferCreateFlags Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        /// <summary>
        /// Specified in bytes
        /// </summary>
        public DeviceSize Size
        {
            get { return M->Size; }
            set { M->Size = value; }
        }

        /// <summary>
        /// Buffer usage flags
        /// </summary>
        public BufferUsageFlags Usage
        {
            get { return M->Usage; }
            set { M->Usage = value; }
        }

        public SharingMode SharingMode
        {
            get { return M->SharingMode; }
            set { M->SharingMode = value; }
        }

        public UInt32 QueueFamilyIndexCount
        {
            get { return M->QueueFamilyIndexCount; }
            set { M->QueueFamilyIndexCount = value; }
        }

        NativeReference refQueueFamilyIndices;
        public UInt32[] QueueFamilyIndices
        {
            get
            {
                if (M->QueueFamilyIndexCount == 0)
                    return null;
                var values = new UInt32[M->QueueFamilyIndexCount];
                unsafe
                {
                    UInt32* ptr = (UInt32*)M->QueueFamilyIndices;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->QueueFamilyIndexCount = 0;
                    M->QueueFamilyIndices = IntPtr.Zero;
                    return;
                }
                M->QueueFamilyIndexCount = (uint)value.Length;
                refQueueFamilyIndices = new NativeReference((int)(sizeof(UInt32) * value.Length));
                M->QueueFamilyIndices = refQueueFamilyIndices.Handle;
                unsafe
                {
                    UInt32* ptr = (UInt32*)M->QueueFamilyIndices;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        internal Interop.BufferCreateInfo* M
        {
            get { return (Interop.BufferCreateInfo*)native.Handle; }
        }

        public BufferCreateInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.BufferCreateInfo));

            M->SType = StructureType.BufferCreateInfo;
        }

        internal BufferCreateInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.BufferCreateInfo;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refQueueFamilyIndices.Dispose();
            refQueueFamilyIndices = null;
        }
    }

    unsafe public partial class BufferViewCreateInfo : MarshalledObject
    {
        public BufferViewCreateFlags Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        Buffer lBuffer;
        public Buffer Buffer
        {
            get { return lBuffer; }
            set { lBuffer = value; M->Buffer = value != null ? (UInt64)value.M : default(UInt64); }
        }

        /// <summary>
        /// Optionally specifies format of elements
        /// </summary>
        public Format Format
        {
            get { return M->Format; }
            set { M->Format = value; }
        }

        /// <summary>
        /// Specified in bytes
        /// </summary>
        public DeviceSize Offset
        {
            get { return M->Offset; }
            set { M->Offset = value; }
        }

        /// <summary>
        /// View size specified in bytes
        /// </summary>
        public DeviceSize Range
        {
            get { return M->Range; }
            set { M->Range = value; }
        }

        internal Interop.BufferViewCreateInfo* M
        {
            get { return (Interop.BufferViewCreateInfo*)native.Handle; }
        }

        public BufferViewCreateInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.BufferViewCreateInfo));

            M->SType = StructureType.BufferViewCreateInfo;
        }

        internal BufferViewCreateInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.BufferViewCreateInfo;
        }
    }

    unsafe public partial struct ImageSubresource
    {
        public ImageAspectFlags AspectMask;
        public UInt32 MipLevel;
        public UInt32 ArrayLayer;
    }

    unsafe public partial struct ImageSubresourceLayers
    {
        public ImageAspectFlags AspectMask;
        public UInt32 MipLevel;
        public UInt32 BaseArrayLayer;
        public UInt32 LayerCount;
    }

    unsafe public partial struct ImageSubresourceRange
    {
        public ImageAspectFlags AspectMask;
        public UInt32 BaseMipLevel;
        public UInt32 LevelCount;
        public UInt32 BaseArrayLayer;
        public UInt32 LayerCount;
    }

    unsafe public partial class MemoryBarrier : MarshalledObject
    {
        /// <summary>
        /// Memory accesses from the source of the dependency to synchronize
        /// </summary>
        public AccessFlags SrcAccessMask
        {
            get { return M->SrcAccessMask; }
            set { M->SrcAccessMask = value; }
        }

        /// <summary>
        /// Memory accesses from the destination of the dependency to synchronize
        /// </summary>
        public AccessFlags DstAccessMask
        {
            get { return M->DstAccessMask; }
            set { M->DstAccessMask = value; }
        }

        internal Interop.MemoryBarrier* M
        {
            get { return (Interop.MemoryBarrier*)native.Handle; }
        }

        public MemoryBarrier()
        {
            native = Interop.Structure.Allocate(typeof(Interop.MemoryBarrier));

            M->SType = StructureType.MemoryBarrier;
        }

        internal MemoryBarrier(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.MemoryBarrier;
        }
    }

    unsafe public partial class BufferMemoryBarrier : MarshalledObject
    {
        /// <summary>
        /// Memory accesses from the source of the dependency to synchronize
        /// </summary>
        public AccessFlags SrcAccessMask
        {
            get { return M->SrcAccessMask; }
            set { M->SrcAccessMask = value; }
        }

        /// <summary>
        /// Memory accesses from the destination of the dependency to synchronize
        /// </summary>
        public AccessFlags DstAccessMask
        {
            get { return M->DstAccessMask; }
            set { M->DstAccessMask = value; }
        }

        /// <summary>
        /// Queue family to transition ownership from
        /// </summary>
        public UInt32 SrcQueueFamilyIndex
        {
            get { return M->SrcQueueFamilyIndex; }
            set { M->SrcQueueFamilyIndex = value; }
        }

        /// <summary>
        /// Queue family to transition ownership to
        /// </summary>
        public UInt32 DstQueueFamilyIndex
        {
            get { return M->DstQueueFamilyIndex; }
            set { M->DstQueueFamilyIndex = value; }
        }

        /// <summary>
        /// Buffer to sync
        /// </summary>
        Buffer lBuffer;
        public Buffer Buffer
        {
            get { return lBuffer; }
            set { lBuffer = value; M->Buffer = value != null ? (UInt64)value.M : default(UInt64); }
        }

        /// <summary>
        /// Offset within the buffer to sync
        /// </summary>
        public DeviceSize Offset
        {
            get { return M->Offset; }
            set { M->Offset = value; }
        }

        /// <summary>
        /// Amount of bytes to sync
        /// </summary>
        public DeviceSize Size
        {
            get { return M->Size; }
            set { M->Size = value; }
        }

        internal Interop.BufferMemoryBarrier* M
        {
            get { return (Interop.BufferMemoryBarrier*)native.Handle; }
        }

        public BufferMemoryBarrier()
        {
            native = Interop.Structure.Allocate(typeof(Interop.BufferMemoryBarrier));

            M->SType = StructureType.BufferMemoryBarrier;
        }

        internal BufferMemoryBarrier(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.BufferMemoryBarrier;
        }
    }

    unsafe public partial class ImageMemoryBarrier : MarshalledObject
    {
        /// <summary>
        /// Memory accesses from the source of the dependency to synchronize
        /// </summary>
        public AccessFlags SrcAccessMask
        {
            get { return M->SrcAccessMask; }
            set { M->SrcAccessMask = value; }
        }

        /// <summary>
        /// Memory accesses from the destination of the dependency to synchronize
        /// </summary>
        public AccessFlags DstAccessMask
        {
            get { return M->DstAccessMask; }
            set { M->DstAccessMask = value; }
        }

        /// <summary>
        /// Current layout of the image
        /// </summary>
        public ImageLayout OldLayout
        {
            get { return M->OldLayout; }
            set { M->OldLayout = value; }
        }

        /// <summary>
        /// New layout to transition the image to
        /// </summary>
        public ImageLayout NewLayout
        {
            get { return M->NewLayout; }
            set { M->NewLayout = value; }
        }

        /// <summary>
        /// Queue family to transition ownership from
        /// </summary>
        public UInt32 SrcQueueFamilyIndex
        {
            get { return M->SrcQueueFamilyIndex; }
            set { M->SrcQueueFamilyIndex = value; }
        }

        /// <summary>
        /// Queue family to transition ownership to
        /// </summary>
        public UInt32 DstQueueFamilyIndex
        {
            get { return M->DstQueueFamilyIndex; }
            set { M->DstQueueFamilyIndex = value; }
        }

        /// <summary>
        /// Image to sync
        /// </summary>
        Image lImage;
        public Image Image
        {
            get { return lImage; }
            set { lImage = value; M->Image = value != null ? (UInt64)value.M : default(UInt64); }
        }

        /// <summary>
        /// Subresource range to sync
        /// </summary>
        public ImageSubresourceRange SubresourceRange
        {
            get { return M->SubresourceRange; }
            set { M->SubresourceRange = value; }
        }

        internal Interop.ImageMemoryBarrier* M
        {
            get { return (Interop.ImageMemoryBarrier*)native.Handle; }
        }

        public ImageMemoryBarrier()
        {
            native = Interop.Structure.Allocate(typeof(Interop.ImageMemoryBarrier));

            M->SType = StructureType.ImageMemoryBarrier;
        }

        internal ImageMemoryBarrier(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.ImageMemoryBarrier;
        }
    }

    unsafe public partial class ImageCreateInfo : MarshalledObject
    {
        /// <summary>
        /// Image creation flags
        /// </summary>
        public ImageCreateFlags Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        public ImageType ImageType
        {
            get { return M->ImageType; }
            set { M->ImageType = value; }
        }

        public Format Format
        {
            get { return M->Format; }
            set { M->Format = value; }
        }

        public Extent3D Extent
        {
            get { return M->Extent; }
            set { M->Extent = value; }
        }

        public UInt32 MipLevels
        {
            get { return M->MipLevels; }
            set { M->MipLevels = value; }
        }

        public UInt32 ArrayLayers
        {
            get { return M->ArrayLayers; }
            set { M->ArrayLayers = value; }
        }

        public SampleCountFlags Samples
        {
            get { return M->Samples; }
            set { M->Samples = value; }
        }

        public ImageTiling Tiling
        {
            get { return M->Tiling; }
            set { M->Tiling = value; }
        }

        /// <summary>
        /// Image usage flags
        /// </summary>
        public ImageUsageFlags Usage
        {
            get { return M->Usage; }
            set { M->Usage = value; }
        }

        /// <summary>
        /// Cross-queue-family sharing mode
        /// </summary>
        public SharingMode SharingMode
        {
            get { return M->SharingMode; }
            set { M->SharingMode = value; }
        }

        /// <summary>
        /// Number of queue families to share across
        /// </summary>
        public UInt32 QueueFamilyIndexCount
        {
            get { return M->QueueFamilyIndexCount; }
            set { M->QueueFamilyIndexCount = value; }
        }

        /// <summary>
        /// Array of queue family indices to share across
        /// </summary>
        NativeReference refQueueFamilyIndices;
        public UInt32[] QueueFamilyIndices
        {
            get
            {
                if (M->QueueFamilyIndexCount == 0)
                    return null;
                var values = new UInt32[M->QueueFamilyIndexCount];
                unsafe
                {
                    UInt32* ptr = (UInt32*)M->QueueFamilyIndices;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->QueueFamilyIndexCount = 0;
                    M->QueueFamilyIndices = IntPtr.Zero;
                    return;
                }
                M->QueueFamilyIndexCount = (uint)value.Length;
                refQueueFamilyIndices = new NativeReference((int)(sizeof(UInt32) * value.Length));
                M->QueueFamilyIndices = refQueueFamilyIndices.Handle;
                unsafe
                {
                    UInt32* ptr = (UInt32*)M->QueueFamilyIndices;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        /// <summary>
        /// Initial image layout for all subresources
        /// </summary>
        public ImageLayout InitialLayout
        {
            get { return M->InitialLayout; }
            set { M->InitialLayout = value; }
        }

        internal Interop.ImageCreateInfo* M
        {
            get { return (Interop.ImageCreateInfo*)native.Handle; }
        }

        public ImageCreateInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.ImageCreateInfo));

            M->SType = StructureType.ImageCreateInfo;
        }

        internal ImageCreateInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.ImageCreateInfo;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refQueueFamilyIndices.Dispose();
            refQueueFamilyIndices = null;
        }
    }

    unsafe public partial struct SubresourceLayout
    {
        /// <summary>
        /// Specified in bytes
        /// </summary>
        public DeviceSize Offset;
        /// <summary>
        /// Specified in bytes
        /// </summary>
        public DeviceSize Size;
        /// <summary>
        /// Specified in bytes
        /// </summary>
        public DeviceSize RowPitch;
        /// <summary>
        /// Specified in bytes
        /// </summary>
        public DeviceSize ArrayPitch;
        /// <summary>
        /// Specified in bytes
        /// </summary>
        public DeviceSize DepthPitch;
    }

    unsafe public partial class ImageViewCreateInfo : MarshalledObject
    {
        public ImageViewCreateFlags Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        Image lImage;
        public Image Image
        {
            get { return lImage; }
            set { lImage = value; M->Image = value != null ? (UInt64)value.M : default(UInt64); }
        }

        public ImageViewType ViewType
        {
            get { return M->ViewType; }
            set { M->ViewType = value; }
        }

        public Format Format
        {
            get { return M->Format; }
            set { M->Format = value; }
        }

        public ComponentMapping Components
        {
            get { return M->Components; }
            set { M->Components = value; }
        }

        public ImageSubresourceRange SubresourceRange
        {
            get { return M->SubresourceRange; }
            set { M->SubresourceRange = value; }
        }

        internal Interop.ImageViewCreateInfo* M
        {
            get { return (Interop.ImageViewCreateInfo*)native.Handle; }
        }

        public ImageViewCreateInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.ImageViewCreateInfo));

            M->SType = StructureType.ImageViewCreateInfo;
        }

        internal ImageViewCreateInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.ImageViewCreateInfo;
        }
    }

    unsafe public partial struct BufferCopy
    {
        /// <summary>
        /// Specified in bytes
        /// </summary>
        public DeviceSize SrcOffset;
        /// <summary>
        /// Specified in bytes
        /// </summary>
        public DeviceSize DstOffset;
        /// <summary>
        /// Specified in bytes
        /// </summary>
        public DeviceSize Size;
    }

    unsafe public partial class SparseMemoryBind : MarshalledObject
    {
        /// <summary>
        /// Specified in bytes
        /// </summary>
        public DeviceSize ResourceOffset
        {
            get { return M->ResourceOffset; }
            set { M->ResourceOffset = value; }
        }

        /// <summary>
        /// Specified in bytes
        /// </summary>
        public DeviceSize Size
        {
            get { return M->Size; }
            set { M->Size = value; }
        }

        DeviceMemory lMemory;
        public DeviceMemory Memory
        {
            get { return lMemory; }
            set { lMemory = value; M->Memory = value != null ? (UInt64)value.M : default(UInt64); }
        }

        /// <summary>
        /// Specified in bytes
        /// </summary>
        public DeviceSize MemoryOffset
        {
            get { return M->MemoryOffset; }
            set { M->MemoryOffset = value; }
        }

        public SparseMemoryBindFlags Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        internal Interop.SparseMemoryBind* M
        {
            get { return (Interop.SparseMemoryBind*)native.Handle; }
        }

        public SparseMemoryBind()
        {
            native = Interop.Structure.Allocate(typeof(Interop.SparseMemoryBind));

        }

        internal SparseMemoryBind(NativePointer pointer)
        {
            native = pointer;

        }
    }

    unsafe public partial class SparseImageMemoryBind : MarshalledObject
    {
        public ImageSubresource Subresource
        {
            get { return M->Subresource; }
            set { M->Subresource = value; }
        }

        public Offset3D Offset
        {
            get { return M->Offset; }
            set { M->Offset = value; }
        }

        public Extent3D Extent
        {
            get { return M->Extent; }
            set { M->Extent = value; }
        }

        DeviceMemory lMemory;
        public DeviceMemory Memory
        {
            get { return lMemory; }
            set { lMemory = value; M->Memory = value != null ? (UInt64)value.M : default(UInt64); }
        }

        /// <summary>
        /// Specified in bytes
        /// </summary>
        public DeviceSize MemoryOffset
        {
            get { return M->MemoryOffset; }
            set { M->MemoryOffset = value; }
        }

        public SparseMemoryBindFlags Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        internal Interop.SparseImageMemoryBind* M
        {
            get { return (Interop.SparseImageMemoryBind*)native.Handle; }
        }

        public SparseImageMemoryBind()
        {
            native = Interop.Structure.Allocate(typeof(Interop.SparseImageMemoryBind));

        }

        internal SparseImageMemoryBind(NativePointer pointer)
        {
            native = pointer;

        }
    }

    unsafe public partial class SparseBufferMemoryBindInfo : MarshalledObject
    {
        Buffer lBuffer;
        public Buffer Buffer
        {
            get { return lBuffer; }
            set { lBuffer = value; M->Buffer = value != null ? (UInt64)value.M : default(UInt64); }
        }

        public UInt32 BindCount
        {
            get { return M->BindCount; }
            set { M->BindCount = value; }
        }

        NativeReference refBinds;
        public SparseMemoryBind[] Binds
        {
            get
            {
                if (M->BindCount == 0)
                    return null;
                var values = new SparseMemoryBind[M->BindCount];
                unsafe
                {
                    Interop.SparseMemoryBind* ptr = (Interop.SparseMemoryBind*)M->Binds;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = new SparseMemoryBind();
                        *values[i].M = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->BindCount = 0;
                    M->Binds = IntPtr.Zero;
                    return;
                }
                M->BindCount = (uint)value.Length;
                refBinds = new NativeReference((int)(sizeof(Interop.SparseMemoryBind) * value.Length));
                M->Binds = refBinds.Handle;
                unsafe
                {
                    Interop.SparseMemoryBind* ptr = (Interop.SparseMemoryBind*)M->Binds;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = *value[i].M;
                    }
                }
            }
        }

        internal Interop.SparseBufferMemoryBindInfo* M
        {
            get { return (Interop.SparseBufferMemoryBindInfo*)native.Handle; }
        }

        public SparseBufferMemoryBindInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.SparseBufferMemoryBindInfo));

        }

        internal SparseBufferMemoryBindInfo(NativePointer pointer)
        {
            native = pointer;

        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refBinds.Dispose();
            refBinds = null;
        }
    }

    unsafe public partial class SparseImageOpaqueMemoryBindInfo : MarshalledObject
    {
        Image lImage;
        public Image Image
        {
            get { return lImage; }
            set { lImage = value; M->Image = value != null ? (UInt64)value.M : default(UInt64); }
        }

        public UInt32 BindCount
        {
            get { return M->BindCount; }
            set { M->BindCount = value; }
        }

        NativeReference refBinds;
        public SparseMemoryBind[] Binds
        {
            get
            {
                if (M->BindCount == 0)
                    return null;
                var values = new SparseMemoryBind[M->BindCount];
                unsafe
                {
                    Interop.SparseMemoryBind* ptr = (Interop.SparseMemoryBind*)M->Binds;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = new SparseMemoryBind();
                        *values[i].M = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->BindCount = 0;
                    M->Binds = IntPtr.Zero;
                    return;
                }
                M->BindCount = (uint)value.Length;
                refBinds = new NativeReference((int)(sizeof(Interop.SparseMemoryBind) * value.Length));
                M->Binds = refBinds.Handle;
                unsafe
                {
                    Interop.SparseMemoryBind* ptr = (Interop.SparseMemoryBind*)M->Binds;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = *value[i].M;
                    }
                }
            }
        }

        internal Interop.SparseImageOpaqueMemoryBindInfo* M
        {
            get { return (Interop.SparseImageOpaqueMemoryBindInfo*)native.Handle; }
        }

        public SparseImageOpaqueMemoryBindInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.SparseImageOpaqueMemoryBindInfo));

        }

        internal SparseImageOpaqueMemoryBindInfo(NativePointer pointer)
        {
            native = pointer;

        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refBinds.Dispose();
            refBinds = null;
        }
    }

    unsafe public partial class SparseImageMemoryBindInfo : MarshalledObject
    {
        Image lImage;
        public Image Image
        {
            get { return lImage; }
            set { lImage = value; M->Image = value != null ? (UInt64)value.M : default(UInt64); }
        }

        public UInt32 BindCount
        {
            get { return M->BindCount; }
            set { M->BindCount = value; }
        }

        NativeReference refBinds;
        public SparseImageMemoryBind[] Binds
        {
            get
            {
                if (M->BindCount == 0)
                    return null;
                var values = new SparseImageMemoryBind[M->BindCount];
                unsafe
                {
                    Interop.SparseImageMemoryBind* ptr = (Interop.SparseImageMemoryBind*)M->Binds;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = new SparseImageMemoryBind();
                        *values[i].M = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->BindCount = 0;
                    M->Binds = IntPtr.Zero;
                    return;
                }
                M->BindCount = (uint)value.Length;
                refBinds = new NativeReference((int)(sizeof(Interop.SparseImageMemoryBind) * value.Length));
                M->Binds = refBinds.Handle;
                unsafe
                {
                    Interop.SparseImageMemoryBind* ptr = (Interop.SparseImageMemoryBind*)M->Binds;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = *value[i].M;
                    }
                }
            }
        }

        internal Interop.SparseImageMemoryBindInfo* M
        {
            get { return (Interop.SparseImageMemoryBindInfo*)native.Handle; }
        }

        public SparseImageMemoryBindInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.SparseImageMemoryBindInfo));

        }

        internal SparseImageMemoryBindInfo(NativePointer pointer)
        {
            native = pointer;

        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refBinds.Dispose();
            refBinds = null;
        }
    }

    unsafe public partial class BindSparseInfo : MarshalledObject
    {
        public UInt32 WaitSemaphoreCount
        {
            get { return M->WaitSemaphoreCount; }
            set { M->WaitSemaphoreCount = value; }
        }

        NativeReference refWaitSemaphores;
        public Semaphore[] WaitSemaphores
        {
            get
            {
                if (M->WaitSemaphoreCount == 0)
                    return null;
                var values = new Semaphore[M->WaitSemaphoreCount];
                unsafe
                {
                    UInt64* ptr = (UInt64*)M->WaitSemaphores;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = new Semaphore();
                        values[i].M = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->WaitSemaphoreCount = 0;
                    M->WaitSemaphores = IntPtr.Zero;
                    return;
                }
                M->WaitSemaphoreCount = (uint)value.Length;
                refWaitSemaphores = new NativeReference((int)(sizeof(UInt64) * value.Length));
                M->WaitSemaphores = refWaitSemaphores.Handle;
                unsafe
                {
                    UInt64* ptr = (UInt64*)M->WaitSemaphores;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i].M;
                    }
                }
            }
        }

        public UInt32 BufferBindCount
        {
            get { return M->BufferBindCount; }
            set { M->BufferBindCount = value; }
        }

        NativeReference refBufferBinds;
        public SparseBufferMemoryBindInfo[] BufferBinds
        {
            get
            {
                if (M->BufferBindCount == 0)
                    return null;
                var values = new SparseBufferMemoryBindInfo[M->BufferBindCount];
                unsafe
                {
                    Interop.SparseBufferMemoryBindInfo* ptr = (Interop.SparseBufferMemoryBindInfo*)M->BufferBinds;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = new SparseBufferMemoryBindInfo();
                        *values[i].M = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->BufferBindCount = 0;
                    M->BufferBinds = IntPtr.Zero;
                    return;
                }
                M->BufferBindCount = (uint)value.Length;
                refBufferBinds = new NativeReference((int)(sizeof(Interop.SparseBufferMemoryBindInfo) * value.Length));
                M->BufferBinds = refBufferBinds.Handle;
                unsafe
                {
                    Interop.SparseBufferMemoryBindInfo* ptr = (Interop.SparseBufferMemoryBindInfo*)M->BufferBinds;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = *value[i].M;
                    }
                }
            }
        }

        public UInt32 ImageOpaqueBindCount
        {
            get { return M->ImageOpaqueBindCount; }
            set { M->ImageOpaqueBindCount = value; }
        }

        NativeReference refImageOpaqueBinds;
        public SparseImageOpaqueMemoryBindInfo[] ImageOpaqueBinds
        {
            get
            {
                if (M->ImageOpaqueBindCount == 0)
                    return null;
                var values = new SparseImageOpaqueMemoryBindInfo[M->ImageOpaqueBindCount];
                unsafe
                {
                    Interop.SparseImageOpaqueMemoryBindInfo* ptr = (Interop.SparseImageOpaqueMemoryBindInfo*)M->ImageOpaqueBinds;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = new SparseImageOpaqueMemoryBindInfo();
                        *values[i].M = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->ImageOpaqueBindCount = 0;
                    M->ImageOpaqueBinds = IntPtr.Zero;
                    return;
                }
                M->ImageOpaqueBindCount = (uint)value.Length;
                refImageOpaqueBinds = new NativeReference((int)(sizeof(Interop.SparseImageOpaqueMemoryBindInfo) * value.Length));
                M->ImageOpaqueBinds = refImageOpaqueBinds.Handle;
                unsafe
                {
                    Interop.SparseImageOpaqueMemoryBindInfo* ptr = (Interop.SparseImageOpaqueMemoryBindInfo*)M->ImageOpaqueBinds;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = *value[i].M;
                    }
                }
            }
        }

        public UInt32 ImageBindCount
        {
            get { return M->ImageBindCount; }
            set { M->ImageBindCount = value; }
        }

        NativeReference refImageBinds;
        public SparseImageMemoryBindInfo[] ImageBinds
        {
            get
            {
                if (M->ImageBindCount == 0)
                    return null;
                var values = new SparseImageMemoryBindInfo[M->ImageBindCount];
                unsafe
                {
                    Interop.SparseImageMemoryBindInfo* ptr = (Interop.SparseImageMemoryBindInfo*)M->ImageBinds;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = new SparseImageMemoryBindInfo();
                        *values[i].M = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->ImageBindCount = 0;
                    M->ImageBinds = IntPtr.Zero;
                    return;
                }
                M->ImageBindCount = (uint)value.Length;
                refImageBinds = new NativeReference((int)(sizeof(Interop.SparseImageMemoryBindInfo) * value.Length));
                M->ImageBinds = refImageBinds.Handle;
                unsafe
                {
                    Interop.SparseImageMemoryBindInfo* ptr = (Interop.SparseImageMemoryBindInfo*)M->ImageBinds;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = *value[i].M;
                    }
                }
            }
        }

        public UInt32 SignalSemaphoreCount
        {
            get { return M->SignalSemaphoreCount; }
            set { M->SignalSemaphoreCount = value; }
        }

        NativeReference refSignalSemaphores;
        public Semaphore[] SignalSemaphores
        {
            get
            {
                if (M->SignalSemaphoreCount == 0)
                    return null;
                var values = new Semaphore[M->SignalSemaphoreCount];
                unsafe
                {
                    UInt64* ptr = (UInt64*)M->SignalSemaphores;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = new Semaphore();
                        values[i].M = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->SignalSemaphoreCount = 0;
                    M->SignalSemaphores = IntPtr.Zero;
                    return;
                }
                M->SignalSemaphoreCount = (uint)value.Length;
                refSignalSemaphores = new NativeReference((int)(sizeof(UInt64) * value.Length));
                M->SignalSemaphores = refSignalSemaphores.Handle;
                unsafe
                {
                    UInt64* ptr = (UInt64*)M->SignalSemaphores;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i].M;
                    }
                }
            }
        }

        internal Interop.BindSparseInfo* M
        {
            get { return (Interop.BindSparseInfo*)native.Handle; }
        }

        public BindSparseInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.BindSparseInfo));

            M->SType = StructureType.BindSparseInfo;
        }

        internal BindSparseInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.BindSparseInfo;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refWaitSemaphores.Dispose();
            refWaitSemaphores = null;
            refBufferBinds.Dispose();
            refBufferBinds = null;
            refImageOpaqueBinds.Dispose();
            refImageOpaqueBinds = null;
            refImageBinds.Dispose();
            refImageBinds = null;
            refSignalSemaphores.Dispose();
            refSignalSemaphores = null;
        }
    }

    unsafe public partial struct ImageCopy
    {
        public ImageSubresourceLayers SrcSubresource;
        /// <summary>
        /// Specified in pixels for both compressed and uncompressed images
        /// </summary>
        public Offset3D SrcOffset;
        public ImageSubresourceLayers DstSubresource;
        /// <summary>
        /// Specified in pixels for both compressed and uncompressed images
        /// </summary>
        public Offset3D DstOffset;
        /// <summary>
        /// Specified in pixels for both compressed and uncompressed images
        /// </summary>
        public Extent3D Extent;
    }

    unsafe public partial class ImageBlit : MarshalledObject
    {
        public ImageSubresourceLayers SrcSubresource
        {
            get { return M->SrcSubresource; }
            set { M->SrcSubresource = value; }
        }

        /// <summary>
        /// Specified in pixels for both compressed and uncompressed images
        /// </summary>
        public Offset3D[] SrcOffsets
        {
            get
            {
                var arr = new Offset3D[2];
                for (int i = 0; i < 2; i++)
                    unsafe
                    {
                        arr[i] = (&M->SrcOffsets0)[i];
                    }
                return arr;
            }
            set
            {
                if (value.Length > 2)
                    throw new Exception("array too long");
                for (int i = 0; i < value.Length; i++)
                    unsafe
                    {
                        (&M->SrcOffsets0)[i] = value[i];
                    }
            }
        }

        public ImageSubresourceLayers DstSubresource
        {
            get { return M->DstSubresource; }
            set { M->DstSubresource = value; }
        }

        /// <summary>
        /// Specified in pixels for both compressed and uncompressed images
        /// </summary>
        public Offset3D[] DstOffsets
        {
            get
            {
                var arr = new Offset3D[2];
                for (int i = 0; i < 2; i++)
                    unsafe
                    {
                        arr[i] = (&M->DstOffsets0)[i];
                    }
                return arr;
            }
            set
            {
                if (value.Length > 2)
                    throw new Exception("array too long");
                for (int i = 0; i < value.Length; i++)
                    unsafe
                    {
                        (&M->DstOffsets0)[i] = value[i];
                    }
            }
        }

        internal Interop.ImageBlit* M
        {
            get { return (Interop.ImageBlit*)native.Handle; }
        }

        public ImageBlit()
        {
            native = Interop.Structure.Allocate(typeof(Interop.ImageBlit));
        }

        internal ImageBlit(NativePointer pointer)
        {
            native = pointer;
        }
    }

    unsafe public partial struct BufferImageCopy
    {
        /// <summary>
        /// Specified in bytes
        /// </summary>
        public DeviceSize BufferOffset;
        /// <summary>
        /// Specified in texels
        /// </summary>
        public UInt32 BufferRowLength;
        public UInt32 BufferImageHeight;
        public ImageSubresourceLayers ImageSubresource;
        /// <summary>
        /// Specified in pixels for both compressed and uncompressed images
        /// </summary>
        public Offset3D ImageOffset;
        /// <summary>
        /// Specified in pixels for both compressed and uncompressed images
        /// </summary>
        public Extent3D ImageExtent;
    }

    unsafe public partial struct ImageResolve
    {
        public ImageSubresourceLayers SrcSubresource;
        public Offset3D SrcOffset;
        public ImageSubresourceLayers DstSubresource;
        public Offset3D DstOffset;
        public Extent3D Extent;
    }

    unsafe public partial class ShaderModuleCreateInfo : MarshalledObject
    {
        public ShaderModuleCreateFlags Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        /// <summary>
        /// Specified in bytes
        /// </summary>
        public UIntPtr CodeSize
        {
            get { return M->CodeSize; }
            set { M->CodeSize = value; }
        }

        /// <summary>
        /// Binary code of size codeSize
        /// </summary>
        NativeReference refCode;
        public UInt32[] Code
        {
            get
            {
                if (M->CodeSize == UIntPtr.Zero)
                    return null;
                var values = new UInt32[((uint)M->CodeSize >> 2)];
                unsafe
                {
                    UInt32* ptr = (UInt32*)M->Code;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->CodeSize = UIntPtr.Zero;
                    M->Code = IntPtr.Zero;
                    return;
                }
                M->CodeSize = (UIntPtr)(value.Length << 2);
                refCode = new NativeReference((int)(sizeof(UInt32) * value.Length));
                M->Code = refCode.Handle;
                unsafe
                {
                    UInt32* ptr = (UInt32*)M->Code;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        internal Interop.ShaderModuleCreateInfo* M
        {
            get { return (Interop.ShaderModuleCreateInfo*)native.Handle; }
        }

        public ShaderModuleCreateInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.ShaderModuleCreateInfo));

            M->SType = StructureType.ShaderModuleCreateInfo;
        }

        internal ShaderModuleCreateInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.ShaderModuleCreateInfo;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refCode.Dispose();
            refCode = null;
        }
    }

    unsafe public partial class DescriptorSetLayoutBinding : MarshalledObject
    {
        /// <summary>
        /// Binding number for this entry
        /// </summary>
        public UInt32 Binding
        {
            get { return M->Binding; }
            set { M->Binding = value; }
        }

        /// <summary>
        /// Type of the descriptors in this binding
        /// </summary>
        public DescriptorType DescriptorType
        {
            get { return M->DescriptorType; }
            set { M->DescriptorType = value; }
        }

        /// <summary>
        /// Number of descriptors in this binding
        /// </summary>
        public UInt32 DescriptorCount
        {
            get { return M->DescriptorCount; }
            set { M->DescriptorCount = value; }
        }

        /// <summary>
        /// Shader stages this binding is visible to
        /// </summary>
        public ShaderStageFlags StageFlags
        {
            get { return M->StageFlags; }
            set { M->StageFlags = value; }
        }

        /// <summary>
        /// Immutable samplers(used if descriptor type is SAMPLER or COMBINED_IMAGE_SAMPLER, is either NULL or contains count number of elements)
        /// </summary>
        NativeReference refImmutableSamplers;
        public Sampler[] ImmutableSamplers
        {
            get
            {
                if (M->DescriptorCount == 0)
                    return null;
                var values = new Sampler[M->DescriptorCount];
                unsafe
                {
                    UInt64* ptr = (UInt64*)M->ImmutableSamplers;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = new Sampler();
                        values[i].M = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->DescriptorCount = 0;
                    M->ImmutableSamplers = IntPtr.Zero;
                    return;
                }
                M->DescriptorCount = (uint)value.Length;
                refImmutableSamplers = new NativeReference((int)(sizeof(UInt64) * value.Length));
                M->ImmutableSamplers = refImmutableSamplers.Handle;
                unsafe
                {
                    UInt64* ptr = (UInt64*)M->ImmutableSamplers;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i].M;
                    }
                }
            }
        }

        internal Interop.DescriptorSetLayoutBinding* M
        {
            get { return (Interop.DescriptorSetLayoutBinding*)native.Handle; }
        }

        public DescriptorSetLayoutBinding()
        {
            native = Interop.Structure.Allocate(typeof(Interop.DescriptorSetLayoutBinding));
        }

        internal DescriptorSetLayoutBinding(NativePointer pointer)
        {
            native = pointer;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refImmutableSamplers.Dispose();
            refImmutableSamplers = null;
        }
    }

    unsafe public partial class DescriptorSetLayoutCreateInfo : MarshalledObject
    {
        public DescriptorSetLayoutCreateFlags Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        /// <summary>
        /// Number of bindings in the descriptor set layout
        /// </summary>
        public UInt32 BindingCount
        {
            get { return M->BindingCount; }
            set { M->BindingCount = value; }
        }

        /// <summary>
        /// Array of descriptor set layout bindings
        /// </summary>
        NativeReference refBindings;
        public DescriptorSetLayoutBinding[] Bindings
        {
            get
            {
                if (M->BindingCount == 0)
                    return null;
                var values = new DescriptorSetLayoutBinding[M->BindingCount];
                unsafe
                {
                    Interop.DescriptorSetLayoutBinding* ptr = (Interop.DescriptorSetLayoutBinding*)M->Bindings;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = new DescriptorSetLayoutBinding();
                        *values[i].M = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->BindingCount = 0;
                    M->Bindings = IntPtr.Zero;
                    return;
                }
                M->BindingCount = (uint)value.Length;
                refBindings = new NativeReference((int)(sizeof(Interop.DescriptorSetLayoutBinding) * value.Length));
                M->Bindings = refBindings.Handle;
                unsafe
                {
                    Interop.DescriptorSetLayoutBinding* ptr = (Interop.DescriptorSetLayoutBinding*)M->Bindings;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = *value[i].M;
                    }
                }
            }
        }

        internal Interop.DescriptorSetLayoutCreateInfo* M
        {
            get { return (Interop.DescriptorSetLayoutCreateInfo*)native.Handle; }
        }

        public DescriptorSetLayoutCreateInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.DescriptorSetLayoutCreateInfo));

            M->SType = StructureType.DescriptorSetLayoutCreateInfo;
        }

        internal DescriptorSetLayoutCreateInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.DescriptorSetLayoutCreateInfo;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refBindings.Dispose();
            refBindings = null;
        }
    }

    unsafe public partial struct DescriptorPoolSize
    {
        public DescriptorType Type;
        public UInt32 DescriptorCount;
    }

    unsafe public partial class DescriptorPoolCreateInfo : MarshalledObject
    {
        public DescriptorPoolCreateFlags Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        public UInt32 MaxSets
        {
            get { return M->MaxSets; }
            set { M->MaxSets = value; }
        }

        public UInt32 PoolSizeCount
        {
            get { return M->PoolSizeCount; }
            set { M->PoolSizeCount = value; }
        }

        NativeReference refPoolSizes;
        public DescriptorPoolSize[] PoolSizes
        {
            get
            {
                if (M->PoolSizeCount == 0)
                    return null;
                var values = new DescriptorPoolSize[M->PoolSizeCount];
                unsafe
                {
                    DescriptorPoolSize* ptr = (DescriptorPoolSize*)M->PoolSizes;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->PoolSizeCount = 0;
                    M->PoolSizes = IntPtr.Zero;
                    return;
                }
                M->PoolSizeCount = (uint)value.Length;
                refPoolSizes = new NativeReference((int)(sizeof(DescriptorPoolSize) * value.Length));
                M->PoolSizes = refPoolSizes.Handle;
                unsafe
                {
                    DescriptorPoolSize* ptr = (DescriptorPoolSize*)M->PoolSizes;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        internal Interop.DescriptorPoolCreateInfo* M
        {
            get { return (Interop.DescriptorPoolCreateInfo*)native.Handle; }
        }

        public DescriptorPoolCreateInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.DescriptorPoolCreateInfo));

            M->SType = StructureType.DescriptorPoolCreateInfo;
        }

        internal DescriptorPoolCreateInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.DescriptorPoolCreateInfo;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refPoolSizes.Dispose();
            refPoolSizes = null;
        }
    }

    unsafe public partial class DescriptorSetAllocateInfo : MarshalledObject
    {
        DescriptorPool lDescriptorPool;
        public DescriptorPool DescriptorPool
        {
            get { return lDescriptorPool; }
            set { lDescriptorPool = value; M->DescriptorPool = value != null ? (UInt64)value.M : default(UInt64); }
        }

        public UInt32 DescriptorSetCount
        {
            get { return M->DescriptorSetCount; }
            set { M->DescriptorSetCount = value; }
        }

        NativeReference refSetLayouts;
        public DescriptorSetLayout[] SetLayouts
        {
            get
            {
                if (M->DescriptorSetCount == 0)
                    return null;
                var values = new DescriptorSetLayout[M->DescriptorSetCount];
                unsafe
                {
                    UInt64* ptr = (UInt64*)M->SetLayouts;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = new DescriptorSetLayout();
                        values[i].M = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->DescriptorSetCount = 0;
                    M->SetLayouts = IntPtr.Zero;
                    return;
                }
                M->DescriptorSetCount = (uint)value.Length;
                refSetLayouts = new NativeReference((int)(sizeof(UInt64) * value.Length));
                M->SetLayouts = refSetLayouts.Handle;
                unsafe
                {
                    UInt64* ptr = (UInt64*)M->SetLayouts;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i].M;
                    }
                }
            }
        }

        internal Interop.DescriptorSetAllocateInfo* M
        {
            get { return (Interop.DescriptorSetAllocateInfo*)native.Handle; }
        }

        public DescriptorSetAllocateInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.DescriptorSetAllocateInfo));

            M->SType = StructureType.DescriptorSetAllocateInfo;
        }

        internal DescriptorSetAllocateInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.DescriptorSetAllocateInfo;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refSetLayouts.Dispose();
            refSetLayouts = null;
        }
    }

    unsafe public partial struct SpecializationMapEntry
    {
        /// <summary>
        /// The SpecConstant ID specified in the BIL
        /// </summary>
        public UInt32 ConstantId;
        /// <summary>
        /// Offset of the value in the data block
        /// </summary>
        public UInt32 Offset;
        /// <summary>
        /// Size in bytes of the SpecConstant
        /// </summary>
        public UIntPtr Size;
    }

    unsafe public partial class SpecializationInfo : MarshalledObject
    {
        /// <summary>
        /// Number of entries in the map
        /// </summary>
        public UInt32 MapEntryCount
        {
            get { return M->MapEntryCount; }
            set { M->MapEntryCount = value; }
        }

        /// <summary>
        /// Array of map entries
        /// </summary>
        NativeReference refMapEntries;
        public SpecializationMapEntry[] MapEntries
        {
            get
            {
                if (M->MapEntryCount == 0)
                    return null;
                var values = new SpecializationMapEntry[M->MapEntryCount];
                unsafe
                {
                    SpecializationMapEntry* ptr = (SpecializationMapEntry*)M->MapEntries;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->MapEntryCount = 0;
                    M->MapEntries = IntPtr.Zero;
                    return;
                }
                M->MapEntryCount = (uint)value.Length;
                refMapEntries = new NativeReference((int)(sizeof(SpecializationMapEntry) * value.Length));
                M->MapEntries = refMapEntries.Handle;
                unsafe
                {
                    SpecializationMapEntry* ptr = (SpecializationMapEntry*)M->MapEntries;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        /// <summary>
        /// Size in bytes of pData
        /// </summary>
        public UIntPtr DataSize
        {
            get { return M->DataSize; }
            set { M->DataSize = value; }
        }

        /// <summary>
        /// Pointer to SpecConstant data
        /// </summary>
        public IntPtr Data
        {
            get { return M->Data; }
            set { M->Data = value; }
        }

        internal Interop.SpecializationInfo* M
        {
            get { return (Interop.SpecializationInfo*)native.Handle; }
        }

        public SpecializationInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.SpecializationInfo));
        }

        internal SpecializationInfo(NativePointer pointer)
        {
            native = pointer;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refMapEntries.Dispose();
            refMapEntries = null;
        }
    }

    unsafe public partial class PipelineShaderStageCreateInfo : MarshalledObject
    {
        public PipelineShaderStageCreateFlags Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        /// <summary>
        /// Shader stage
        /// </summary>
        public ShaderStageFlags Stage
        {
            get { return M->Stage; }
            set { M->Stage = value; }
        }

        /// <summary>
        /// Module containing entry point
        /// </summary>
        ShaderModule lModule;
        public ShaderModule Module
        {
            get { return lModule; }
            set { lModule = value; M->Module = value != null ? (UInt64)value.M : default(UInt64); }
        }

        /// <summary>
        /// Null-terminated entry point name
        /// </summary>
        public string Name
        {
            get { return Marshal.PtrToStringAnsi(M->Name); }
            set { M->Name = Marshal.StringToHGlobalAnsi(value); }
        }

        SpecializationInfo lSpecializationInfo;
        public SpecializationInfo SpecializationInfo
        {
            get { return lSpecializationInfo; }
            set { lSpecializationInfo = value; M->SpecializationInfo = value != null ? (IntPtr)value.M : default(IntPtr); }
        }

        internal Interop.PipelineShaderStageCreateInfo* M
        {
            get { return (Interop.PipelineShaderStageCreateInfo*)native.Handle; }
        }

        public PipelineShaderStageCreateInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PipelineShaderStageCreateInfo));

            M->SType = StructureType.PipelineShaderStageCreateInfo;
        }

        internal PipelineShaderStageCreateInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PipelineShaderStageCreateInfo;
        }
    }

    unsafe public partial class ComputePipelineCreateInfo : MarshalledObject
    {
        /// <summary>
        /// Pipeline creation flags
        /// </summary>
        public PipelineCreateFlags Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        PipelineShaderStageCreateInfo lStage;
        public PipelineShaderStageCreateInfo Stage
        {
            get { return lStage; }
            set { lStage = value; M->Stage = value != null ? *value.M : default(Interop.PipelineShaderStageCreateInfo); }
        }

        /// <summary>
        /// Interface layout of the pipeline
        /// </summary>
        PipelineLayout lLayout;
        public PipelineLayout Layout
        {
            get { return lLayout; }
            set { lLayout = value; M->Layout = value != null ? (UInt64)value.M : default(UInt64); }
        }

        /// <summary>
        /// If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of
        /// </summary>
        Pipeline lBasePipelineHandle;
        public Pipeline BasePipelineHandle
        {
            get { return lBasePipelineHandle; }
            set { lBasePipelineHandle = value; M->BasePipelineHandle = value != null ? (UInt64)value.M : default(UInt64); }
        }

        /// <summary>
        /// If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of
        /// </summary>
        public Int32 BasePipelineIndex
        {
            get { return M->BasePipelineIndex; }
            set { M->BasePipelineIndex = value; }
        }

        internal Interop.ComputePipelineCreateInfo* M
        {
            get { return (Interop.ComputePipelineCreateInfo*)native.Handle; }
        }

        public ComputePipelineCreateInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.ComputePipelineCreateInfo));

            M->SType = StructureType.ComputePipelineCreateInfo;
            lStage = new PipelineShaderStageCreateInfo(new NativePointer(native.Reference, (IntPtr)(&M->Stage)));
        }

        internal ComputePipelineCreateInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.ComputePipelineCreateInfo;
            lStage = new PipelineShaderStageCreateInfo(new NativePointer(native.Reference, (IntPtr)(&M->Stage)));
        }
    }

    unsafe public partial struct VertexInputBindingDescription
    {
        /// <summary>
        /// Vertex buffer binding id
        /// </summary>
        public UInt32 Binding;
        /// <summary>
        /// Distance between vertices in bytes(0 = no advancement)
        /// </summary>
        public UInt32 Stride;
        /// <summary>
        /// The rate at which the vertex data is consumed
        /// </summary>
        public VertexInputRate InputRate;
    }

    unsafe public partial struct VertexInputAttributeDescription
    {
        /// <summary>
        /// location of the shader vertex attrib
        /// </summary>
        public UInt32 Location;
        /// <summary>
        /// Vertex buffer binding id
        /// </summary>
        public UInt32 Binding;
        /// <summary>
        /// format of source data
        /// </summary>
        public Format Format;
        /// <summary>
        /// Offset of first element in bytes from base of vertex
        /// </summary>
        public UInt32 Offset;
    }

    unsafe public partial class PipelineVertexInputStateCreateInfo : MarshalledObject
    {
        public PipelineVertexInputStateCreateFlags Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        /// <summary>
        /// number of bindings
        /// </summary>
        public UInt32 VertexBindingDescriptionCount
        {
            get { return M->VertexBindingDescriptionCount; }
            set { M->VertexBindingDescriptionCount = value; }
        }

        NativeReference refVertexBindingDescriptions;
        public VertexInputBindingDescription[] VertexBindingDescriptions
        {
            get
            {
                if (M->VertexBindingDescriptionCount == 0)
                    return null;
                var values = new VertexInputBindingDescription[M->VertexBindingDescriptionCount];
                unsafe
                {
                    VertexInputBindingDescription* ptr = (VertexInputBindingDescription*)M->VertexBindingDescriptions;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->VertexBindingDescriptionCount = 0;
                    M->VertexBindingDescriptions = IntPtr.Zero;
                    return;
                }
                M->VertexBindingDescriptionCount = (uint)value.Length;
                refVertexBindingDescriptions = new NativeReference((int)(sizeof(VertexInputBindingDescription) * value.Length));
                M->VertexBindingDescriptions = refVertexBindingDescriptions.Handle;
                unsafe
                {
                    VertexInputBindingDescription* ptr = (VertexInputBindingDescription*)M->VertexBindingDescriptions;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        /// <summary>
        /// number of attributes
        /// </summary>
        public UInt32 VertexAttributeDescriptionCount
        {
            get { return M->VertexAttributeDescriptionCount; }
            set { M->VertexAttributeDescriptionCount = value; }
        }

        NativeReference refVertexAttributeDescriptions;
        public VertexInputAttributeDescription[] VertexAttributeDescriptions
        {
            get
            {
                if (M->VertexAttributeDescriptionCount == 0)
                    return null;
                var values = new VertexInputAttributeDescription[M->VertexAttributeDescriptionCount];
                unsafe
                {
                    VertexInputAttributeDescription* ptr = (VertexInputAttributeDescription*)M->VertexAttributeDescriptions;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->VertexAttributeDescriptionCount = 0;
                    M->VertexAttributeDescriptions = IntPtr.Zero;
                    return;
                }
                M->VertexAttributeDescriptionCount = (uint)value.Length;
                refVertexAttributeDescriptions = new NativeReference((int)(sizeof(VertexInputAttributeDescription) * value.Length));
                M->VertexAttributeDescriptions = refVertexAttributeDescriptions.Handle;
                unsafe
                {
                    VertexInputAttributeDescription* ptr = (VertexInputAttributeDescription*)M->VertexAttributeDescriptions;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        internal Interop.PipelineVertexInputStateCreateInfo* M
        {
            get { return (Interop.PipelineVertexInputStateCreateInfo*)native.Handle; }
        }

        public PipelineVertexInputStateCreateInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PipelineVertexInputStateCreateInfo));

            M->SType = StructureType.PipelineVertexInputStateCreateInfo;
        }

        internal PipelineVertexInputStateCreateInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PipelineVertexInputStateCreateInfo;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refVertexBindingDescriptions.Dispose();
            refVertexBindingDescriptions = null;
            refVertexAttributeDescriptions.Dispose();
            refVertexAttributeDescriptions = null;
        }
    }

    unsafe public partial class PipelineInputAssemblyStateCreateInfo : MarshalledObject
    {
        public PipelineInputAssemblyStateCreateFlags Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        public PrimitiveTopology Topology
        {
            get { return M->Topology; }
            set { M->Topology = value; }
        }

        public bool PrimitiveRestartEnable
        {
            get { return M->PrimitiveRestartEnable; }
            set { M->PrimitiveRestartEnable = value; }
        }

        internal Interop.PipelineInputAssemblyStateCreateInfo* M
        {
            get { return (Interop.PipelineInputAssemblyStateCreateInfo*)native.Handle; }
        }

        public PipelineInputAssemblyStateCreateInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PipelineInputAssemblyStateCreateInfo));

            M->SType = StructureType.PipelineInputAssemblyStateCreateInfo;
        }

        internal PipelineInputAssemblyStateCreateInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PipelineInputAssemblyStateCreateInfo;
        }
    }

    unsafe public partial class PipelineTessellationStateCreateInfo : MarshalledObject
    {
        public PipelineTessellationStateCreateFlags Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        public UInt32 PatchControlPoints
        {
            get { return M->PatchControlPoints; }
            set { M->PatchControlPoints = value; }
        }

        internal Interop.PipelineTessellationStateCreateInfo* M
        {
            get { return (Interop.PipelineTessellationStateCreateInfo*)native.Handle; }
        }

        public PipelineTessellationStateCreateInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PipelineTessellationStateCreateInfo));

            M->SType = StructureType.PipelineTessellationStateCreateInfo;
        }

        internal PipelineTessellationStateCreateInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PipelineTessellationStateCreateInfo;
        }
    }

    unsafe public partial class PipelineViewportStateCreateInfo : MarshalledObject
    {
        public PipelineViewportStateCreateFlags Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        public UInt32 ViewportCount
        {
            get { return M->ViewportCount; }
            set { M->ViewportCount = value; }
        }

        NativeReference refViewports;
        public Viewport[] Viewports
        {
            get
            {
                if (M->ViewportCount == 0)
                    return null;
                var values = new Viewport[M->ViewportCount];
                unsafe
                {
                    Viewport* ptr = (Viewport*)M->Viewports;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->ViewportCount = 0;
                    M->Viewports = IntPtr.Zero;
                    return;
                }
                M->ViewportCount = (uint)value.Length;
                refViewports = new NativeReference((int)(sizeof(Viewport) * value.Length));
                M->Viewports = refViewports.Handle;
                unsafe
                {
                    Viewport* ptr = (Viewport*)M->Viewports;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        public UInt32 ScissorCount
        {
            get { return M->ScissorCount; }
            set { M->ScissorCount = value; }
        }

        NativeReference refScissors;
        public Rect2D[] Scissors
        {
            get
            {
                if (M->ScissorCount == 0)
                    return null;
                var values = new Rect2D[M->ScissorCount];
                unsafe
                {
                    Rect2D* ptr = (Rect2D*)M->Scissors;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->ScissorCount = 0;
                    M->Scissors = IntPtr.Zero;
                    return;
                }
                M->ScissorCount = (uint)value.Length;
                refScissors = new NativeReference((int)(sizeof(Rect2D) * value.Length));
                M->Scissors = refScissors.Handle;
                unsafe
                {
                    Rect2D* ptr = (Rect2D*)M->Scissors;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        internal Interop.PipelineViewportStateCreateInfo* M
        {
            get { return (Interop.PipelineViewportStateCreateInfo*)native.Handle; }
        }

        public PipelineViewportStateCreateInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PipelineViewportStateCreateInfo));

            M->SType = StructureType.PipelineViewportStateCreateInfo;
        }

        internal PipelineViewportStateCreateInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PipelineViewportStateCreateInfo;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refViewports.Dispose();
            refViewports = null;
            refScissors.Dispose();
            refScissors = null;
        }
    }

    unsafe public partial class PipelineRasterizationStateCreateInfo : MarshalledObject
    {
        public PipelineRasterizationStateCreateFlags Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        public bool DepthClampEnable
        {
            get { return M->DepthClampEnable; }
            set { M->DepthClampEnable = value; }
        }

        public bool RasterizerDiscardEnable
        {
            get { return M->RasterizerDiscardEnable; }
            set { M->RasterizerDiscardEnable = value; }
        }

        /// <summary>
        /// optional(GL45)
        /// </summary>
        public PolygonMode PolygonMode
        {
            get { return M->PolygonMode; }
            set { M->PolygonMode = value; }
        }

        public CullModeFlags CullMode
        {
            get { return M->CullMode; }
            set { M->CullMode = value; }
        }

        public FrontFace FrontFace
        {
            get { return M->FrontFace; }
            set { M->FrontFace = value; }
        }

        public bool DepthBiasEnable
        {
            get { return M->DepthBiasEnable; }
            set { M->DepthBiasEnable = value; }
        }

        public float DepthBiasConstantFactor
        {
            get { return M->DepthBiasConstantFactor; }
            set { M->DepthBiasConstantFactor = value; }
        }

        public float DepthBiasClamp
        {
            get { return M->DepthBiasClamp; }
            set { M->DepthBiasClamp = value; }
        }

        public float DepthBiasSlopeFactor
        {
            get { return M->DepthBiasSlopeFactor; }
            set { M->DepthBiasSlopeFactor = value; }
        }

        public float LineWidth
        {
            get { return M->LineWidth; }
            set { M->LineWidth = value; }
        }

        internal Interop.PipelineRasterizationStateCreateInfo* M
        {
            get { return (Interop.PipelineRasterizationStateCreateInfo*)native.Handle; }
        }

        public PipelineRasterizationStateCreateInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PipelineRasterizationStateCreateInfo));

            M->SType = StructureType.PipelineRasterizationStateCreateInfo;
        }

        internal PipelineRasterizationStateCreateInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PipelineRasterizationStateCreateInfo;
        }
    }

    unsafe public partial class PipelineMultisampleStateCreateInfo : MarshalledObject
    {
        public PipelineMultisampleStateCreateFlags Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        /// <summary>
        /// Number of samples used for rasterization
        /// </summary>
        public SampleCountFlags RasterizationSamples
        {
            get { return M->RasterizationSamples; }
            set { M->RasterizationSamples = value; }
        }

        /// <summary>
        /// optional(GL45)
        /// </summary>
        public bool SampleShadingEnable
        {
            get { return M->SampleShadingEnable; }
            set { M->SampleShadingEnable = value; }
        }

        /// <summary>
        /// optional(GL45)
        /// </summary>
        public float MinSampleShading
        {
            get { return M->MinSampleShading; }
            set { M->MinSampleShading = value; }
        }

        /// <summary>
        /// Array of sampleMask words
        /// </summary>
        NativeReference refSampleMask;
        public UInt32[] SampleMask
        {
            get
            {
                if (M->RasterizationSamples == 0)
                    return null;
                var values = new UInt32[((uint)M->RasterizationSamples >> 5)];
                unsafe
                {
                    UInt32* ptr = (UInt32*)M->SampleMask;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->RasterizationSamples = 0;
                    M->SampleMask = IntPtr.Zero;
                    return;
                }
                M->RasterizationSamples = (SampleCountFlags)(value.Length << 5);
                refSampleMask = new NativeReference((int)(sizeof(UInt32) * value.Length));
                M->SampleMask = refSampleMask.Handle;
                unsafe
                {
                    UInt32* ptr = (UInt32*)M->SampleMask;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        public bool AlphaToCoverageEnable
        {
            get { return M->AlphaToCoverageEnable; }
            set { M->AlphaToCoverageEnable = value; }
        }

        public bool AlphaToOneEnable
        {
            get { return M->AlphaToOneEnable; }
            set { M->AlphaToOneEnable = value; }
        }

        internal Interop.PipelineMultisampleStateCreateInfo* M
        {
            get { return (Interop.PipelineMultisampleStateCreateInfo*)native.Handle; }
        }

        public PipelineMultisampleStateCreateInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PipelineMultisampleStateCreateInfo));

            M->SType = StructureType.PipelineMultisampleStateCreateInfo;
        }

        internal PipelineMultisampleStateCreateInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PipelineMultisampleStateCreateInfo;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refSampleMask.Dispose();
            refSampleMask = null;
        }
    }

    unsafe public partial struct PipelineColorBlendAttachmentState
    {
        public Bool32 BlendEnable;
        public BlendFactor SrcColorBlendFactor;
        public BlendFactor DstColorBlendFactor;
        public BlendOp ColorBlendOp;
        public BlendFactor SrcAlphaBlendFactor;
        public BlendFactor DstAlphaBlendFactor;
        public BlendOp AlphaBlendOp;
        public ColorComponentFlags ColorWriteMask;
    }

    unsafe public partial class PipelineColorBlendStateCreateInfo : MarshalledObject
    {
        public PipelineColorBlendStateCreateFlags Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        public bool LogicOpEnable
        {
            get { return M->LogicOpEnable; }
            set { M->LogicOpEnable = value; }
        }

        public LogicOp LogicOp
        {
            get { return M->LogicOp; }
            set { M->LogicOp = value; }
        }

        /// <summary>
        /// # of pAttachments
        /// </summary>
        public UInt32 AttachmentCount
        {
            get { return M->AttachmentCount; }
            set { M->AttachmentCount = value; }
        }

        NativeReference refAttachments;
        public PipelineColorBlendAttachmentState[] Attachments
        {
            get
            {
                if (M->AttachmentCount == 0)
                    return null;
                var values = new PipelineColorBlendAttachmentState[M->AttachmentCount];
                unsafe
                {
                    PipelineColorBlendAttachmentState* ptr = (PipelineColorBlendAttachmentState*)M->Attachments;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->AttachmentCount = 0;
                    M->Attachments = IntPtr.Zero;
                    return;
                }
                M->AttachmentCount = (uint)value.Length;
                refAttachments = new NativeReference((int)(sizeof(PipelineColorBlendAttachmentState) * value.Length));
                M->Attachments = refAttachments.Handle;
                unsafe
                {
                    PipelineColorBlendAttachmentState* ptr = (PipelineColorBlendAttachmentState*)M->Attachments;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        public float[] BlendConstants
        {
            get
            {
                var arr = new float[4];
                for (int i = 0; i < 4; i++)
                    arr[i] = M->BlendConstants[i];
                return arr;
            }
            set
            {
                if (value.Length > 4)
                    throw new Exception("array too long");
                for (int i = 0; i < value.Length; i++)
                    M->BlendConstants[i] = value[i];
                for (int i = value.Length; i < 4; i++)
                    M->BlendConstants[i] = 0;
            }
        }

        internal Interop.PipelineColorBlendStateCreateInfo* M
        {
            get { return (Interop.PipelineColorBlendStateCreateInfo*)native.Handle; }
        }

        public PipelineColorBlendStateCreateInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PipelineColorBlendStateCreateInfo));

            M->SType = StructureType.PipelineColorBlendStateCreateInfo;
        }

        internal PipelineColorBlendStateCreateInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PipelineColorBlendStateCreateInfo;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refAttachments.Dispose();
            refAttachments = null;
        }
    }

    unsafe public partial class PipelineDynamicStateCreateInfo : MarshalledObject
    {
        public PipelineDynamicStateCreateFlags Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        public UInt32 DynamicStateCount
        {
            get { return M->DynamicStateCount; }
            set { M->DynamicStateCount = value; }
        }

        NativeReference refDynamicStates;
        public DynamicState[] DynamicStates
        {
            get
            {
                if (M->DynamicStateCount == 0)
                    return null;
                var values = new DynamicState[M->DynamicStateCount];
                unsafe
                {
                    DynamicState* ptr = (DynamicState*)M->DynamicStates;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->DynamicStateCount = 0;
                    M->DynamicStates = IntPtr.Zero;
                    return;
                }
                M->DynamicStateCount = (uint)value.Length;
                refDynamicStates = new NativeReference((int)(sizeof(DynamicState) * value.Length));
                M->DynamicStates = refDynamicStates.Handle;
                unsafe
                {
                    DynamicState* ptr = (DynamicState*)M->DynamicStates;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        internal Interop.PipelineDynamicStateCreateInfo* M
        {
            get { return (Interop.PipelineDynamicStateCreateInfo*)native.Handle; }
        }

        public PipelineDynamicStateCreateInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PipelineDynamicStateCreateInfo));

            M->SType = StructureType.PipelineDynamicStateCreateInfo;
        }

        internal PipelineDynamicStateCreateInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PipelineDynamicStateCreateInfo;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refDynamicStates.Dispose();
            refDynamicStates = null;
        }
    }

    unsafe public partial struct StencilOpState
    {
        public StencilOp FailOp;
        public StencilOp PassOp;
        public StencilOp DepthFailOp;
        public CompareOp CompareOp;
        public UInt32 CompareMask;
        public UInt32 WriteMask;
        public UInt32 Reference;
    }

    unsafe public partial class PipelineDepthStencilStateCreateInfo : MarshalledObject
    {
        public PipelineDepthStencilStateCreateFlags Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        public bool DepthTestEnable
        {
            get { return M->DepthTestEnable; }
            set { M->DepthTestEnable = value; }
        }

        public bool DepthWriteEnable
        {
            get { return M->DepthWriteEnable; }
            set { M->DepthWriteEnable = value; }
        }

        public CompareOp DepthCompareOp
        {
            get { return M->DepthCompareOp; }
            set { M->DepthCompareOp = value; }
        }

        /// <summary>
        /// optional(depth_bounds_test)
        /// </summary>
        public bool DepthBoundsTestEnable
        {
            get { return M->DepthBoundsTestEnable; }
            set { M->DepthBoundsTestEnable = value; }
        }

        public bool StencilTestEnable
        {
            get { return M->StencilTestEnable; }
            set { M->StencilTestEnable = value; }
        }

        public StencilOpState Front
        {
            get { return M->Front; }
            set { M->Front = value; }
        }

        public StencilOpState Back
        {
            get { return M->Back; }
            set { M->Back = value; }
        }

        public float MinDepthBounds
        {
            get { return M->MinDepthBounds; }
            set { M->MinDepthBounds = value; }
        }

        public float MaxDepthBounds
        {
            get { return M->MaxDepthBounds; }
            set { M->MaxDepthBounds = value; }
        }

        internal Interop.PipelineDepthStencilStateCreateInfo* M
        {
            get { return (Interop.PipelineDepthStencilStateCreateInfo*)native.Handle; }
        }

        public PipelineDepthStencilStateCreateInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PipelineDepthStencilStateCreateInfo));

            M->SType = StructureType.PipelineDepthStencilStateCreateInfo;
        }

        internal PipelineDepthStencilStateCreateInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PipelineDepthStencilStateCreateInfo;
        }
    }

    unsafe public partial class GraphicsPipelineCreateInfo : MarshalledObject
    {
        /// <summary>
        /// Pipeline creation flags
        /// </summary>
        public PipelineCreateFlags Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        public UInt32 StageCount
        {
            get { return M->StageCount; }
            set { M->StageCount = value; }
        }

        /// <summary>
        /// One entry for each active shader stage
        /// </summary>
        NativeReference refStages;
        public PipelineShaderStageCreateInfo[] Stages
        {
            get
            {
                if (M->StageCount == 0)
                    return null;
                var values = new PipelineShaderStageCreateInfo[M->StageCount];
                unsafe
                {
                    Interop.PipelineShaderStageCreateInfo* ptr = (Interop.PipelineShaderStageCreateInfo*)M->Stages;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = new PipelineShaderStageCreateInfo();
                        *values[i].M = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->StageCount = 0;
                    M->Stages = IntPtr.Zero;
                    return;
                }
                M->StageCount = (uint)value.Length;
                refStages = new NativeReference((int)(sizeof(Interop.PipelineShaderStageCreateInfo) * value.Length));
                M->Stages = refStages.Handle;
                unsafe
                {
                    Interop.PipelineShaderStageCreateInfo* ptr = (Interop.PipelineShaderStageCreateInfo*)M->Stages;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = *value[i].M;
                    }
                }
            }
        }

        PipelineVertexInputStateCreateInfo lVertexInputState;
        public PipelineVertexInputStateCreateInfo VertexInputState
        {
            get { return lVertexInputState; }
            set { lVertexInputState = value; M->VertexInputState = value != null ? (IntPtr)value.M : default(IntPtr); }
        }

        PipelineInputAssemblyStateCreateInfo lInputAssemblyState;
        public PipelineInputAssemblyStateCreateInfo InputAssemblyState
        {
            get { return lInputAssemblyState; }
            set { lInputAssemblyState = value; M->InputAssemblyState = value != null ? (IntPtr)value.M : default(IntPtr); }
        }

        PipelineTessellationStateCreateInfo lTessellationState;
        public PipelineTessellationStateCreateInfo TessellationState
        {
            get { return lTessellationState; }
            set { lTessellationState = value; M->TessellationState = value != null ? (IntPtr)value.M : default(IntPtr); }
        }

        PipelineViewportStateCreateInfo lViewportState;
        public PipelineViewportStateCreateInfo ViewportState
        {
            get { return lViewportState; }
            set { lViewportState = value; M->ViewportState = value != null ? (IntPtr)value.M : default(IntPtr); }
        }

        PipelineRasterizationStateCreateInfo lRasterizationState;
        public PipelineRasterizationStateCreateInfo RasterizationState
        {
            get { return lRasterizationState; }
            set { lRasterizationState = value; M->RasterizationState = value != null ? (IntPtr)value.M : default(IntPtr); }
        }

        PipelineMultisampleStateCreateInfo lMultisampleState;
        public PipelineMultisampleStateCreateInfo MultisampleState
        {
            get { return lMultisampleState; }
            set { lMultisampleState = value; M->MultisampleState = value != null ? (IntPtr)value.M : default(IntPtr); }
        }

        PipelineDepthStencilStateCreateInfo lDepthStencilState;
        public PipelineDepthStencilStateCreateInfo DepthStencilState
        {
            get { return lDepthStencilState; }
            set { lDepthStencilState = value; M->DepthStencilState = value != null ? (IntPtr)value.M : default(IntPtr); }
        }

        PipelineColorBlendStateCreateInfo lColorBlendState;
        public PipelineColorBlendStateCreateInfo ColorBlendState
        {
            get { return lColorBlendState; }
            set { lColorBlendState = value; M->ColorBlendState = value != null ? (IntPtr)value.M : default(IntPtr); }
        }

        PipelineDynamicStateCreateInfo lDynamicState;
        public PipelineDynamicStateCreateInfo DynamicState
        {
            get { return lDynamicState; }
            set { lDynamicState = value; M->DynamicState = value != null ? (IntPtr)value.M : default(IntPtr); }
        }

        /// <summary>
        /// Interface layout of the pipeline
        /// </summary>
        PipelineLayout lLayout;
        public PipelineLayout Layout
        {
            get { return lLayout; }
            set { lLayout = value; M->Layout = value != null ? (UInt64)value.M : default(UInt64); }
        }

        RenderPass lRenderPass;
        public RenderPass RenderPass
        {
            get { return lRenderPass; }
            set { lRenderPass = value; M->RenderPass = value != null ? (UInt64)value.M : default(UInt64); }
        }

        public UInt32 Subpass
        {
            get { return M->Subpass; }
            set { M->Subpass = value; }
        }

        /// <summary>
        /// If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of
        /// </summary>
        Pipeline lBasePipelineHandle;
        public Pipeline BasePipelineHandle
        {
            get { return lBasePipelineHandle; }
            set { lBasePipelineHandle = value; M->BasePipelineHandle = value != null ? (UInt64)value.M : default(UInt64); }
        }

        /// <summary>
        /// If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of
        /// </summary>
        public Int32 BasePipelineIndex
        {
            get { return M->BasePipelineIndex; }
            set { M->BasePipelineIndex = value; }
        }

        internal Interop.GraphicsPipelineCreateInfo* M
        {
            get { return (Interop.GraphicsPipelineCreateInfo*)native.Handle; }
        }

        public GraphicsPipelineCreateInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.GraphicsPipelineCreateInfo));

            M->SType = StructureType.GraphicsPipelineCreateInfo;
        }

        internal GraphicsPipelineCreateInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.GraphicsPipelineCreateInfo;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refStages.Dispose();
            refStages = null;
        }
    }

    unsafe public partial class PipelineCacheCreateInfo : MarshalledObject
    {
        public PipelineCacheCreateFlags Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        /// <summary>
        /// Size of initial data to populate cache, in bytes
        /// </summary>
        public UIntPtr InitialDataSize
        {
            get { return M->InitialDataSize; }
            set { M->InitialDataSize = value; }
        }

        /// <summary>
        /// Initial data to populate cache
        /// </summary>
        public IntPtr InitialData
        {
            get { return M->InitialData; }
            set { M->InitialData = value; }
        }

        internal Interop.PipelineCacheCreateInfo* M
        {
            get { return (Interop.PipelineCacheCreateInfo*)native.Handle; }
        }

        public PipelineCacheCreateInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PipelineCacheCreateInfo));

            M->SType = StructureType.PipelineCacheCreateInfo;
        }

        internal PipelineCacheCreateInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PipelineCacheCreateInfo;
        }
    }

    unsafe public partial struct PushConstantRange
    {
        /// <summary>
        /// Which stages use the range
        /// </summary>
        public ShaderStageFlags StageFlags;
        /// <summary>
        /// Start of the range, in bytes
        /// </summary>
        public UInt32 Offset;
        /// <summary>
        /// Size of the range, in bytes
        /// </summary>
        public UInt32 Size;
    }

    unsafe public partial class PipelineLayoutCreateInfo : MarshalledObject
    {
        public PipelineLayoutCreateFlags Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        /// <summary>
        /// Number of descriptor sets interfaced by the pipeline
        /// </summary>
        public UInt32 SetLayoutCount
        {
            get { return M->SetLayoutCount; }
            set { M->SetLayoutCount = value; }
        }

        /// <summary>
        /// Array of setCount number of descriptor set layout objects defining the layout of the
        /// </summary>
        NativeReference refSetLayouts;
        public DescriptorSetLayout[] SetLayouts
        {
            get
            {
                if (M->SetLayoutCount == 0)
                    return null;
                var values = new DescriptorSetLayout[M->SetLayoutCount];
                unsafe
                {
                    UInt64* ptr = (UInt64*)M->SetLayouts;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = new DescriptorSetLayout();
                        values[i].M = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->SetLayoutCount = 0;
                    M->SetLayouts = IntPtr.Zero;
                    return;
                }
                M->SetLayoutCount = (uint)value.Length;
                refSetLayouts = new NativeReference((int)(sizeof(UInt64) * value.Length));
                M->SetLayouts = refSetLayouts.Handle;
                unsafe
                {
                    UInt64* ptr = (UInt64*)M->SetLayouts;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i].M;
                    }
                }
            }
        }

        /// <summary>
        /// Number of push-constant ranges used by the pipeline
        /// </summary>
        public UInt32 PushConstantRangeCount
        {
            get { return M->PushConstantRangeCount; }
            set { M->PushConstantRangeCount = value; }
        }

        /// <summary>
        /// Array of pushConstantRangeCount number of ranges used by various shader stages
        /// </summary>
        NativeReference refPushConstantRanges;
        public PushConstantRange[] PushConstantRanges
        {
            get
            {
                if (M->PushConstantRangeCount == 0)
                    return null;
                var values = new PushConstantRange[M->PushConstantRangeCount];
                unsafe
                {
                    PushConstantRange* ptr = (PushConstantRange*)M->PushConstantRanges;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->PushConstantRangeCount = 0;
                    M->PushConstantRanges = IntPtr.Zero;
                    return;
                }
                M->PushConstantRangeCount = (uint)value.Length;
                refPushConstantRanges = new NativeReference((int)(sizeof(PushConstantRange) * value.Length));
                M->PushConstantRanges = refPushConstantRanges.Handle;
                unsafe
                {
                    PushConstantRange* ptr = (PushConstantRange*)M->PushConstantRanges;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        internal Interop.PipelineLayoutCreateInfo* M
        {
            get { return (Interop.PipelineLayoutCreateInfo*)native.Handle; }
        }

        public PipelineLayoutCreateInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PipelineLayoutCreateInfo));

            M->SType = StructureType.PipelineLayoutCreateInfo;
        }

        internal PipelineLayoutCreateInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PipelineLayoutCreateInfo;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refSetLayouts.Dispose();
            refSetLayouts = null;
            refPushConstantRanges.Dispose();
            refPushConstantRanges = null;
        }
    }

    unsafe public partial class SamplerCreateInfo : MarshalledObject
    {
        public SamplerCreateFlags Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        /// <summary>
        /// Filter mode for magnification
        /// </summary>
        public Filter MagFilter
        {
            get { return M->MagFilter; }
            set { M->MagFilter = value; }
        }

        /// <summary>
        /// Filter mode for minifiation
        /// </summary>
        public Filter MinFilter
        {
            get { return M->MinFilter; }
            set { M->MinFilter = value; }
        }

        /// <summary>
        /// Mipmap selection mode
        /// </summary>
        public SamplerMipmapMode MipmapMode
        {
            get { return M->MipmapMode; }
            set { M->MipmapMode = value; }
        }

        public SamplerAddressMode AddressModeU
        {
            get { return M->AddressModeU; }
            set { M->AddressModeU = value; }
        }

        public SamplerAddressMode AddressModeV
        {
            get { return M->AddressModeV; }
            set { M->AddressModeV = value; }
        }

        public SamplerAddressMode AddressModeW
        {
            get { return M->AddressModeW; }
            set { M->AddressModeW = value; }
        }

        public float MipLodBias
        {
            get { return M->MipLodBias; }
            set { M->MipLodBias = value; }
        }

        public bool AnisotropyEnable
        {
            get { return M->AnisotropyEnable; }
            set { M->AnisotropyEnable = value; }
        }

        public float MaxAnisotropy
        {
            get { return M->MaxAnisotropy; }
            set { M->MaxAnisotropy = value; }
        }

        public bool CompareEnable
        {
            get { return M->CompareEnable; }
            set { M->CompareEnable = value; }
        }

        public CompareOp CompareOp
        {
            get { return M->CompareOp; }
            set { M->CompareOp = value; }
        }

        public float MinLod
        {
            get { return M->MinLod; }
            set { M->MinLod = value; }
        }

        public float MaxLod
        {
            get { return M->MaxLod; }
            set { M->MaxLod = value; }
        }

        public BorderColor BorderColor
        {
            get { return M->BorderColor; }
            set { M->BorderColor = value; }
        }

        public bool UnnormalizedCoordinates
        {
            get { return M->UnnormalizedCoordinates; }
            set { M->UnnormalizedCoordinates = value; }
        }

        internal Interop.SamplerCreateInfo* M
        {
            get { return (Interop.SamplerCreateInfo*)native.Handle; }
        }

        public SamplerCreateInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.SamplerCreateInfo));

            M->SType = StructureType.SamplerCreateInfo;
        }

        internal SamplerCreateInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.SamplerCreateInfo;
        }
    }

    unsafe public partial class CommandPoolCreateInfo : MarshalledObject
    {
        /// <summary>
        /// Command pool creation flags
        /// </summary>
        public CommandPoolCreateFlags Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        public UInt32 QueueFamilyIndex
        {
            get { return M->QueueFamilyIndex; }
            set { M->QueueFamilyIndex = value; }
        }

        internal Interop.CommandPoolCreateInfo* M
        {
            get { return (Interop.CommandPoolCreateInfo*)native.Handle; }
        }

        public CommandPoolCreateInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.CommandPoolCreateInfo));

            M->SType = StructureType.CommandPoolCreateInfo;
        }

        internal CommandPoolCreateInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.CommandPoolCreateInfo;
        }
    }

    unsafe public partial class CommandBufferAllocateInfo : MarshalledObject
    {
        CommandPool lCommandPool;
        public CommandPool CommandPool
        {
            get { return lCommandPool; }
            set { lCommandPool = value; M->CommandPool = value != null ? (UInt64)value.M : default(UInt64); }
        }

        public CommandBufferLevel Level
        {
            get { return M->Level; }
            set { M->Level = value; }
        }

        public UInt32 CommandBufferCount
        {
            get { return M->CommandBufferCount; }
            set { M->CommandBufferCount = value; }
        }

        internal Interop.CommandBufferAllocateInfo* M
        {
            get { return (Interop.CommandBufferAllocateInfo*)native.Handle; }
        }

        public CommandBufferAllocateInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.CommandBufferAllocateInfo));

            M->SType = StructureType.CommandBufferAllocateInfo;
        }

        internal CommandBufferAllocateInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.CommandBufferAllocateInfo;
        }
    }

    unsafe public partial class CommandBufferInheritanceInfo : MarshalledObject
    {
        /// <summary>
        /// Render pass for secondary command buffers
        /// </summary>
        RenderPass lRenderPass;
        public RenderPass RenderPass
        {
            get { return lRenderPass; }
            set { lRenderPass = value; M->RenderPass = value != null ? (UInt64)value.M : default(UInt64); }
        }

        public UInt32 Subpass
        {
            get { return M->Subpass; }
            set { M->Subpass = value; }
        }

        /// <summary>
        /// Framebuffer for secondary command buffers
        /// </summary>
        Framebuffer lFramebuffer;
        public Framebuffer Framebuffer
        {
            get { return lFramebuffer; }
            set { lFramebuffer = value; M->Framebuffer = value != null ? (UInt64)value.M : default(UInt64); }
        }

        /// <summary>
        /// Whether this secondary command buffer may be executed during an occlusion query
        /// </summary>
        public bool OcclusionQueryEnable
        {
            get { return M->OcclusionQueryEnable; }
            set { M->OcclusionQueryEnable = value; }
        }

        /// <summary>
        /// Query flags used by this secondary command buffer, if executed during an occlusion query
        /// </summary>
        public QueryControlFlags QueryFlags
        {
            get { return M->QueryFlags; }
            set { M->QueryFlags = value; }
        }

        /// <summary>
        /// Pipeline statistics that may be counted for this secondary command buffer
        /// </summary>
        public QueryPipelineStatisticFlags PipelineStatistics
        {
            get { return M->PipelineStatistics; }
            set { M->PipelineStatistics = value; }
        }

        internal Interop.CommandBufferInheritanceInfo* M
        {
            get { return (Interop.CommandBufferInheritanceInfo*)native.Handle; }
        }

        public CommandBufferInheritanceInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.CommandBufferInheritanceInfo));

            M->SType = StructureType.CommandBufferInheritanceInfo;
        }

        internal CommandBufferInheritanceInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.CommandBufferInheritanceInfo;
        }
    }

    unsafe public partial class CommandBufferBeginInfo : MarshalledObject
    {
        /// <summary>
        /// Command buffer usage flags
        /// </summary>
        public CommandBufferUsageFlags Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        /// <summary>
        /// Pointer to inheritance info for secondary command buffers
        /// </summary>
        CommandBufferInheritanceInfo lInheritanceInfo;
        public CommandBufferInheritanceInfo InheritanceInfo
        {
            get { return lInheritanceInfo; }
            set { lInheritanceInfo = value; M->InheritanceInfo = value != null ? (IntPtr)value.M : default(IntPtr); }
        }

        internal Interop.CommandBufferBeginInfo* M
        {
            get { return (Interop.CommandBufferBeginInfo*)native.Handle; }
        }

        public CommandBufferBeginInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.CommandBufferBeginInfo));

            M->SType = StructureType.CommandBufferBeginInfo;
        }

        internal CommandBufferBeginInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.CommandBufferBeginInfo;
        }
    }

    unsafe public partial class RenderPassBeginInfo : MarshalledObject
    {
        RenderPass lRenderPass;
        public RenderPass RenderPass
        {
            get { return lRenderPass; }
            set { lRenderPass = value; M->RenderPass = value != null ? (UInt64)value.M : default(UInt64); }
        }

        Framebuffer lFramebuffer;
        public Framebuffer Framebuffer
        {
            get { return lFramebuffer; }
            set { lFramebuffer = value; M->Framebuffer = value != null ? (UInt64)value.M : default(UInt64); }
        }

        public Rect2D RenderArea
        {
            get { return M->RenderArea; }
            set { M->RenderArea = value; }
        }

        public UInt32 ClearValueCount
        {
            get { return M->ClearValueCount; }
            set { M->ClearValueCount = value; }
        }

        NativeReference refClearValues;
        public ClearValue[] ClearValues
        {
            get
            {
                if (M->ClearValueCount == 0)
                    return null;
                var values = new ClearValue[M->ClearValueCount];
                unsafe
                {
                    Interop.ClearValue* ptr = (Interop.ClearValue*)M->ClearValues;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = new ClearValue();
                        *values[i].M = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->ClearValueCount = 0;
                    M->ClearValues = IntPtr.Zero;
                    return;
                }
                M->ClearValueCount = (uint)value.Length;
                refClearValues = new NativeReference((int)(sizeof(Interop.ClearValue) * value.Length));
                M->ClearValues = refClearValues.Handle;
                unsafe
                {
                    Interop.ClearValue* ptr = (Interop.ClearValue*)M->ClearValues;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = *value[i].M;
                    }
                }
            }
        }

        internal Interop.RenderPassBeginInfo* M
        {
            get { return (Interop.RenderPassBeginInfo*)native.Handle; }
        }

        public RenderPassBeginInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.RenderPassBeginInfo));

            M->SType = StructureType.RenderPassBeginInfo;
        }

        internal RenderPassBeginInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.RenderPassBeginInfo;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refClearValues.Dispose();
            refClearValues = null;
        }
    }

    unsafe public partial struct ClearDepthStencilValue
    {
        public float Depth;
        public UInt32 Stencil;
    }

    unsafe public partial class ClearAttachment : MarshalledObject
    {
        public ImageAspectFlags AspectMask
        {
            get { return M->AspectMask; }
            set { M->AspectMask = value; }
        }

        public UInt32 ColorAttachment
        {
            get { return M->ColorAttachment; }
            set { M->ColorAttachment = value; }
        }

        ClearValue lClearValue;
        public ClearValue ClearValue
        {
            get { return lClearValue; }
            set { lClearValue = value; M->ClearValue = value != null ? *value.M : default(Interop.ClearValue); }
        }

        internal Interop.ClearAttachment* M
        {
            get { return (Interop.ClearAttachment*)native.Handle; }
        }

        public ClearAttachment()
        {
            native = Interop.Structure.Allocate(typeof(Interop.ClearAttachment));

            lClearValue = new ClearValue(new NativePointer(native.Reference, (IntPtr)(&M->ClearValue)));
        }

        internal ClearAttachment(NativePointer pointer)
        {
            native = pointer;

            lClearValue = new ClearValue(new NativePointer(native.Reference, (IntPtr)(&M->ClearValue)));
        }
    }

    unsafe public partial struct AttachmentDescription
    {
        public AttachmentDescriptionFlags Flags;
        public Format Format;
        public SampleCountFlags Samples;
        /// <summary>
        /// Load operation for color or depth data
        /// </summary>
        public AttachmentLoadOp LoadOp;
        /// <summary>
        /// Store operation for color or depth data
        /// </summary>
        public AttachmentStoreOp StoreOp;
        /// <summary>
        /// Load operation for stencil data
        /// </summary>
        public AttachmentLoadOp StencilLoadOp;
        /// <summary>
        /// Store operation for stencil data
        /// </summary>
        public AttachmentStoreOp StencilStoreOp;
        public ImageLayout InitialLayout;
        public ImageLayout FinalLayout;
    }

    unsafe public partial struct AttachmentReference
    {
        public UInt32 Attachment;
        public ImageLayout Layout;
    }

    unsafe public partial class SubpassDescription : MarshalledObject
    {
        public SubpassDescriptionFlags Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        /// <summary>
        /// Must be VK_PIPELINE_BIND_POINT_GRAPHICS for now
        /// </summary>
        public PipelineBindPoint PipelineBindPoint
        {
            get { return M->PipelineBindPoint; }
            set { M->PipelineBindPoint = value; }
        }

        public UInt32 InputAttachmentCount
        {
            get { return M->InputAttachmentCount; }
            set { M->InputAttachmentCount = value; }
        }

        NativeReference refInputAttachments;
        public AttachmentReference[] InputAttachments
        {
            get
            {
                if (M->InputAttachmentCount == 0)
                    return null;
                var values = new AttachmentReference[M->InputAttachmentCount];
                unsafe
                {
                    AttachmentReference* ptr = (AttachmentReference*)M->InputAttachments;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->InputAttachmentCount = 0;
                    M->InputAttachments = IntPtr.Zero;
                    return;
                }
                M->InputAttachmentCount = (uint)value.Length;
                refInputAttachments = new NativeReference((int)(sizeof(AttachmentReference) * value.Length));
                M->InputAttachments = refInputAttachments.Handle;
                unsafe
                {
                    AttachmentReference* ptr = (AttachmentReference*)M->InputAttachments;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        public UInt32 ColorAttachmentCount
        {
            get { return M->ColorAttachmentCount; }
            set { M->ColorAttachmentCount = value; }
        }

        NativeReference refColorAttachments;
        public AttachmentReference[] ColorAttachments
        {
            get
            {
                if (M->ColorAttachmentCount == 0)
                    return null;
                var values = new AttachmentReference[M->ColorAttachmentCount];
                unsafe
                {
                    AttachmentReference* ptr = (AttachmentReference*)M->ColorAttachments;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->ColorAttachmentCount = 0;
                    M->ColorAttachments = IntPtr.Zero;
                    return;
                }
                M->ColorAttachmentCount = (uint)value.Length;
                refColorAttachments = new NativeReference((int)(sizeof(AttachmentReference) * value.Length));
                M->ColorAttachments = refColorAttachments.Handle;
                unsafe
                {
                    AttachmentReference* ptr = (AttachmentReference*)M->ColorAttachments;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        NativeReference refResolveAttachments;
        public AttachmentReference[] ResolveAttachments
        {
            get
            {
                if (M->ColorAttachmentCount == 0)
                    return null;
                var values = new AttachmentReference[M->ColorAttachmentCount];
                unsafe
                {
                    AttachmentReference* ptr = (AttachmentReference*)M->ResolveAttachments;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->ColorAttachmentCount = 0;
                    M->ResolveAttachments = IntPtr.Zero;
                    return;
                }
                M->ColorAttachmentCount = (uint)value.Length;
                refResolveAttachments = new NativeReference((int)(sizeof(AttachmentReference) * value.Length));
                M->ResolveAttachments = refResolveAttachments.Handle;
                unsafe
                {
                    AttachmentReference* ptr = (AttachmentReference*)M->ResolveAttachments;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        public AttachmentReference DepthStencilAttachment
        {
            get { return (AttachmentReference)Interop.Structure.MarshalPointerToObject(M->DepthStencilAttachment, typeof(AttachmentReference)); }
            set { M->DepthStencilAttachment = Interop.Structure.MarshalObjectToPointer(M->DepthStencilAttachment, value); }
        }

        public UInt32 PreserveAttachmentCount
        {
            get { return M->PreserveAttachmentCount; }
            set { M->PreserveAttachmentCount = value; }
        }

        NativeReference refPreserveAttachments;
        public UInt32[] PreserveAttachments
        {
            get
            {
                if (M->PreserveAttachmentCount == 0)
                    return null;
                var values = new UInt32[M->PreserveAttachmentCount];
                unsafe
                {
                    UInt32* ptr = (UInt32*)M->PreserveAttachments;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->PreserveAttachmentCount = 0;
                    M->PreserveAttachments = IntPtr.Zero;
                    return;
                }
                M->PreserveAttachmentCount = (uint)value.Length;
                refPreserveAttachments = new NativeReference((int)(sizeof(UInt32) * value.Length));
                M->PreserveAttachments = refPreserveAttachments.Handle;
                unsafe
                {
                    UInt32* ptr = (UInt32*)M->PreserveAttachments;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        internal Interop.SubpassDescription* M
        {
            get { return (Interop.SubpassDescription*)native.Handle; }
        }

        public SubpassDescription()
        {
            native = Interop.Structure.Allocate(typeof(Interop.SubpassDescription));
        }

        internal SubpassDescription(NativePointer pointer)
        {
            native = pointer;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refInputAttachments.Dispose();
            refInputAttachments = null;
            refColorAttachments.Dispose();
            refColorAttachments = null;
            refResolveAttachments.Dispose();
            refResolveAttachments = null;
            refPreserveAttachments.Dispose();
            refPreserveAttachments = null;
        }
    }

    unsafe public partial struct SubpassDependency
    {
        public UInt32 SrcSubpass;
        public UInt32 DstSubpass;
        public PipelineStageFlags SrcStageMask;
        public PipelineStageFlags DstStageMask;
        /// <summary>
        /// Memory accesses from the source of the dependency to synchronize
        /// </summary>
        public AccessFlags SrcAccessMask;
        /// <summary>
        /// Memory accesses from the destination of the dependency to synchronize
        /// </summary>
        public AccessFlags DstAccessMask;
        public DependencyFlags DependencyFlags;
    }

    unsafe public partial class RenderPassCreateInfo : MarshalledObject
    {
        public RenderPassCreateFlags Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        public UInt32 AttachmentCount
        {
            get { return M->AttachmentCount; }
            set { M->AttachmentCount = value; }
        }

        NativeReference refAttachments;
        public AttachmentDescription[] Attachments
        {
            get
            {
                if (M->AttachmentCount == 0)
                    return null;
                var values = new AttachmentDescription[M->AttachmentCount];
                unsafe
                {
                    AttachmentDescription* ptr = (AttachmentDescription*)M->Attachments;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->AttachmentCount = 0;
                    M->Attachments = IntPtr.Zero;
                    return;
                }
                M->AttachmentCount = (uint)value.Length;
                refAttachments = new NativeReference((int)(sizeof(AttachmentDescription) * value.Length));
                M->Attachments = refAttachments.Handle;
                unsafe
                {
                    AttachmentDescription* ptr = (AttachmentDescription*)M->Attachments;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        public UInt32 SubpassCount
        {
            get { return M->SubpassCount; }
            set { M->SubpassCount = value; }
        }

        NativeReference refSubpasses;
        public SubpassDescription[] Subpasses
        {
            get
            {
                if (M->SubpassCount == 0)
                    return null;
                var values = new SubpassDescription[M->SubpassCount];
                unsafe
                {
                    Interop.SubpassDescription* ptr = (Interop.SubpassDescription*)M->Subpasses;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = new SubpassDescription();
                        *values[i].M = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->SubpassCount = 0;
                    M->Subpasses = IntPtr.Zero;
                    return;
                }
                M->SubpassCount = (uint)value.Length;
                refSubpasses = new NativeReference((int)(sizeof(Interop.SubpassDescription) * value.Length));
                M->Subpasses = refSubpasses.Handle;
                unsafe
                {
                    Interop.SubpassDescription* ptr = (Interop.SubpassDescription*)M->Subpasses;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = *value[i].M;
                    }
                }
            }
        }

        public UInt32 DependencyCount
        {
            get { return M->DependencyCount; }
            set { M->DependencyCount = value; }
        }

        NativeReference refDependencies;
        public SubpassDependency[] Dependencies
        {
            get
            {
                if (M->DependencyCount == 0)
                    return null;
                var values = new SubpassDependency[M->DependencyCount];
                unsafe
                {
                    SubpassDependency* ptr = (SubpassDependency*)M->Dependencies;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->DependencyCount = 0;
                    M->Dependencies = IntPtr.Zero;
                    return;
                }
                M->DependencyCount = (uint)value.Length;
                refDependencies = new NativeReference((int)(sizeof(SubpassDependency) * value.Length));
                M->Dependencies = refDependencies.Handle;
                unsafe
                {
                    SubpassDependency* ptr = (SubpassDependency*)M->Dependencies;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        internal Interop.RenderPassCreateInfo* M
        {
            get { return (Interop.RenderPassCreateInfo*)native.Handle; }
        }

        public RenderPassCreateInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.RenderPassCreateInfo));

            M->SType = StructureType.RenderPassCreateInfo;
        }

        internal RenderPassCreateInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.RenderPassCreateInfo;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refAttachments.Dispose();
            refAttachments = null;
            refSubpasses.Dispose();
            refSubpasses = null;
            refDependencies.Dispose();
            refDependencies = null;
        }
    }

    unsafe public partial class EventCreateInfo : MarshalledObject
    {
        /// <summary>
        /// Event creation flags
        /// </summary>
        public EventCreateFlags Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        internal Interop.EventCreateInfo* M
        {
            get { return (Interop.EventCreateInfo*)native.Handle; }
        }

        public EventCreateInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.EventCreateInfo));

            M->SType = StructureType.EventCreateInfo;
        }

        internal EventCreateInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.EventCreateInfo;
        }
    }

    unsafe public partial class FenceCreateInfo : MarshalledObject
    {
        /// <summary>
        /// Fence creation flags
        /// </summary>
        public FenceCreateFlags Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        internal Interop.FenceCreateInfo* M
        {
            get { return (Interop.FenceCreateInfo*)native.Handle; }
        }

        public FenceCreateInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.FenceCreateInfo));

            M->SType = StructureType.FenceCreateInfo;
        }

        internal FenceCreateInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.FenceCreateInfo;
        }
    }

    unsafe public partial struct PhysicalDeviceFeatures
    {
        /// <summary>
        /// out of bounds buffer accesses are well defined
        /// </summary>
        public Bool32 RobustBufferAccess;
        /// <summary>
        /// full 32-bit range of indices for indexed draw calls
        /// </summary>
        public Bool32 FullDrawIndexUint32;
        /// <summary>
        /// image views which are arrays of cube maps
        /// </summary>
        public Bool32 ImageCubeArray;
        /// <summary>
        /// blending operations are controlled per-attachment
        /// </summary>
        public Bool32 IndependentBlend;
        /// <summary>
        /// geometry stage
        /// </summary>
        public Bool32 GeometryShader;
        /// <summary>
        /// tessellation control and evaluation stage
        /// </summary>
        public Bool32 TessellationShader;
        /// <summary>
        /// per-sample shading and interpolation
        /// </summary>
        public Bool32 SampleRateShading;
        /// <summary>
        /// blend operations which take two sources
        /// </summary>
        public Bool32 DualSrcBlend;
        /// <summary>
        /// logic operations
        /// </summary>
        public Bool32 LogicOp;
        /// <summary>
        /// multi draw indirect
        /// </summary>
        public Bool32 MultiDrawIndirect;
        /// <summary>
        /// indirect draws can use non-zero firstInstance
        /// </summary>
        public Bool32 DrawIndirectFirstInstance;
        /// <summary>
        /// depth clamping
        /// </summary>
        public Bool32 DepthClamp;
        /// <summary>
        /// depth bias clamping
        /// </summary>
        public Bool32 DepthBiasClamp;
        /// <summary>
        /// point and wireframe fill modes
        /// </summary>
        public Bool32 FillModeNonSolid;
        /// <summary>
        /// depth bounds test
        /// </summary>
        public Bool32 DepthBounds;
        /// <summary>
        /// lines with width greater than 1
        /// </summary>
        public Bool32 WideLines;
        /// <summary>
        /// points with size greater than 1
        /// </summary>
        public Bool32 LargePoints;
        /// <summary>
        /// the fragment alpha component can be forced to maximum representable alpha value
        /// </summary>
        public Bool32 AlphaToOne;
        /// <summary>
        /// viewport arrays
        /// </summary>
        public Bool32 MultiViewport;
        /// <summary>
        /// anisotropic sampler filtering
        /// </summary>
        public Bool32 SamplerAnisotropy;
        /// <summary>
        /// ETC texture compression formats
        /// </summary>
        public Bool32 TextureCompressionEtc2;
        /// <summary>
        /// ASTC LDR texture compression formats
        /// </summary>
        public Bool32 TextureCompressionAstcLdr;
        /// <summary>
        /// BC1-7 texture compressed formats
        /// </summary>
        public Bool32 TextureCompressionBc;
        /// <summary>
        /// precise occlusion queries returning actual sample counts
        /// </summary>
        public Bool32 OcclusionQueryPrecise;
        /// <summary>
        /// pipeline statistics query
        /// </summary>
        public Bool32 PipelineStatisticsQuery;
        /// <summary>
        /// stores and atomic ops on storage buffers and images are supported in vertex, tessellation, and geometry stages
        /// </summary>
        public Bool32 VertexPipelineStoresAndAtomics;
        /// <summary>
        /// stores and atomic ops on storage buffers and images are supported in the fragment stage
        /// </summary>
        public Bool32 FragmentStoresAndAtomics;
        /// <summary>
        /// tessellation and geometry stages can export point size
        /// </summary>
        public Bool32 ShaderTessellationAndGeometryPointSize;
        /// <summary>
        /// image gather with run-time values and independent offsets
        /// </summary>
        public Bool32 ShaderImageGatherExtended;
        /// <summary>
        /// the extended set of formats can be used for storage images
        /// </summary>
        public Bool32 ShaderStorageImageExtendedFormats;
        /// <summary>
        /// multisample images can be used for storage images
        /// </summary>
        public Bool32 ShaderStorageImageMultisample;
        /// <summary>
        /// read from storage image does not require format qualifier
        /// </summary>
        public Bool32 ShaderStorageImageReadWithoutFormat;
        /// <summary>
        /// write to storage image does not require format qualifier
        /// </summary>
        public Bool32 ShaderStorageImageWriteWithoutFormat;
        /// <summary>
        /// arrays of uniform buffers can be accessed with dynamically uniform indices
        /// </summary>
        public Bool32 ShaderUniformBufferArrayDynamicIndexing;
        /// <summary>
        /// arrays of sampled images can be accessed with dynamically uniform indices
        /// </summary>
        public Bool32 ShaderSampledImageArrayDynamicIndexing;
        /// <summary>
        /// arrays of storage buffers can be accessed with dynamically uniform indices
        /// </summary>
        public Bool32 ShaderStorageBufferArrayDynamicIndexing;
        /// <summary>
        /// arrays of storage images can be accessed with dynamically uniform indices
        /// </summary>
        public Bool32 ShaderStorageImageArrayDynamicIndexing;
        /// <summary>
        /// clip distance in shaders
        /// </summary>
        public Bool32 ShaderClipDistance;
        /// <summary>
        /// cull distance in shaders
        /// </summary>
        public Bool32 ShaderCullDistance;
        /// <summary>
        /// 64-bit floats(doubles) in shaders
        /// </summary>
        public Bool32 ShaderFloat64;
        /// <summary>
        /// 64-bit integers in shaders
        /// </summary>
        public Bool32 ShaderInt64;
        /// <summary>
        /// 16-bit integers in shaders
        /// </summary>
        public Bool32 ShaderInt16;
        /// <summary>
        /// shader can use texture operations that return resource residency information(requires sparseNonResident support)
        /// </summary>
        public Bool32 ShaderResourceResidency;
        /// <summary>
        /// shader can use texture operations that specify minimum resource LOD
        /// </summary>
        public Bool32 ShaderResourceMinLod;
        /// <summary>
        /// Sparse resources support: Resource memory can be managed at opaque page level rather than object level
        /// </summary>
        public Bool32 SparseBinding;
        /// <summary>
        /// Sparse resources support: GPU can access partially resident buffers 
        /// </summary>
        public Bool32 SparseResidencyBuffer;
        /// <summary>
        /// Sparse resources support: GPU can access partially resident 2D(non-MSAA non-depth/stencil) images 
        /// </summary>
        public Bool32 SparseResidencyImage2D;
        /// <summary>
        /// Sparse resources support: GPU can access partially resident 3D images 
        /// </summary>
        public Bool32 SparseResidencyImage3D;
        /// <summary>
        /// Sparse resources support: GPU can access partially resident MSAA 2D images with 2 samples
        /// </summary>
        public Bool32 SparseResidency2Samples;
        /// <summary>
        /// Sparse resources support: GPU can access partially resident MSAA 2D images with 4 samples
        /// </summary>
        public Bool32 SparseResidency4Samples;
        /// <summary>
        /// Sparse resources support: GPU can access partially resident MSAA 2D images with 8 samples
        /// </summary>
        public Bool32 SparseResidency8Samples;
        /// <summary>
        /// Sparse resources support: GPU can access partially resident MSAA 2D images with 16 samples
        /// </summary>
        public Bool32 SparseResidency16Samples;
        /// <summary>
        /// Sparse resources support: GPU can correctly access data aliased into multiple locations(opt-in)
        /// </summary>
        public Bool32 SparseResidencyAliased;
        /// <summary>
        /// multisample rate must be the same for all pipelines in a subpass
        /// </summary>
        public Bool32 VariableMultisampleRate;
        /// <summary>
        /// Queries may be inherited from primary to secondary command buffers
        /// </summary>
        public Bool32 InheritedQueries;
    }

    unsafe public partial struct PhysicalDeviceSparseProperties
    {
        /// <summary>
        /// Sparse resources support: GPU will access all 2D(single sample) sparse resources using the standard sparse image block shapes(based on pixel format)
        /// </summary>
        public Bool32 ResidencyStandard2DBlockShape;
        /// <summary>
        /// Sparse resources support: GPU will access all 2D(multisample) sparse resources using the standard sparse image block shapes(based on pixel format)
        /// </summary>
        public Bool32 ResidencyStandard2DMultisampleBlockShape;
        /// <summary>
        /// Sparse resources support: GPU will access all 3D sparse resources using the standard sparse image block shapes(based on pixel format)
        /// </summary>
        public Bool32 ResidencyStandard3DBlockShape;
        /// <summary>
        /// Sparse resources support: Images with mip level dimensions that are NOT a multiple of the sparse image block dimensions will be placed in the mip tail
        /// </summary>
        public Bool32 ResidencyAlignedMipSize;
        /// <summary>
        /// Sparse resources support: GPU can consistently access non-resident regions of a resource, all reads return as if data is 0, writes are discarded
        /// </summary>
        public Bool32 ResidencyNonResidentStrict;
    }

    unsafe public partial class PhysicalDeviceLimits : MarshalledObject
    {
        /// <summary>
        /// max 1D image dimension
        /// </summary>
        public UInt32 MaxImageDimension1D
        {
            get { return M->MaxImageDimension1D; }
            set { M->MaxImageDimension1D = value; }
        }

        /// <summary>
        /// max 2D image dimension
        /// </summary>
        public UInt32 MaxImageDimension2D
        {
            get { return M->MaxImageDimension2D; }
            set { M->MaxImageDimension2D = value; }
        }

        /// <summary>
        /// max 3D image dimension
        /// </summary>
        public UInt32 MaxImageDimension3D
        {
            get { return M->MaxImageDimension3D; }
            set { M->MaxImageDimension3D = value; }
        }

        /// <summary>
        /// max cubemap image dimension
        /// </summary>
        public UInt32 MaxImageDimensionCube
        {
            get { return M->MaxImageDimensionCube; }
            set { M->MaxImageDimensionCube = value; }
        }

        /// <summary>
        /// max layers for image arrays
        /// </summary>
        public UInt32 MaxImageArrayLayers
        {
            get { return M->MaxImageArrayLayers; }
            set { M->MaxImageArrayLayers = value; }
        }

        /// <summary>
        /// max texel buffer size(fstexels)
        /// </summary>
        public UInt32 MaxTexelBufferElements
        {
            get { return M->MaxTexelBufferElements; }
            set { M->MaxTexelBufferElements = value; }
        }

        /// <summary>
        /// max uniform buffer range(bytes)
        /// </summary>
        public UInt32 MaxUniformBufferRange
        {
            get { return M->MaxUniformBufferRange; }
            set { M->MaxUniformBufferRange = value; }
        }

        /// <summary>
        /// max storage buffer range(bytes)
        /// </summary>
        public UInt32 MaxStorageBufferRange
        {
            get { return M->MaxStorageBufferRange; }
            set { M->MaxStorageBufferRange = value; }
        }

        /// <summary>
        /// max size of the push constants pool(bytes)
        /// </summary>
        public UInt32 MaxPushConstantsSize
        {
            get { return M->MaxPushConstantsSize; }
            set { M->MaxPushConstantsSize = value; }
        }

        /// <summary>
        /// max number of device memory allocations supported
        /// </summary>
        public UInt32 MaxMemoryAllocationCount
        {
            get { return M->MaxMemoryAllocationCount; }
            set { M->MaxMemoryAllocationCount = value; }
        }

        /// <summary>
        /// max number of samplers that can be allocated on a device
        /// </summary>
        public UInt32 MaxSamplerAllocationCount
        {
            get { return M->MaxSamplerAllocationCount; }
            set { M->MaxSamplerAllocationCount = value; }
        }

        /// <summary>
        /// Granularity(in bytes) at which buffers and images can be bound to adjacent memory for simultaneous usage
        /// </summary>
        public DeviceSize BufferImageGranularity
        {
            get { return M->BufferImageGranularity; }
            set { M->BufferImageGranularity = value; }
        }

        /// <summary>
        /// Total address space available for sparse allocations(bytes)
        /// </summary>
        public DeviceSize SparseAddressSpaceSize
        {
            get { return M->SparseAddressSpaceSize; }
            set { M->SparseAddressSpaceSize = value; }
        }

        /// <summary>
        /// max number of descriptors sets that can be bound to a pipeline
        /// </summary>
        public UInt32 MaxBoundDescriptorSets
        {
            get { return M->MaxBoundDescriptorSets; }
            set { M->MaxBoundDescriptorSets = value; }
        }

        /// <summary>
        /// max number of samplers allowed per-stage in a descriptor set
        /// </summary>
        public UInt32 MaxPerStageDescriptorSamplers
        {
            get { return M->MaxPerStageDescriptorSamplers; }
            set { M->MaxPerStageDescriptorSamplers = value; }
        }

        /// <summary>
        /// max number of uniform buffers allowed per-stage in a descriptor set
        /// </summary>
        public UInt32 MaxPerStageDescriptorUniformBuffers
        {
            get { return M->MaxPerStageDescriptorUniformBuffers; }
            set { M->MaxPerStageDescriptorUniformBuffers = value; }
        }

        /// <summary>
        /// max number of storage buffers allowed per-stage in a descriptor set
        /// </summary>
        public UInt32 MaxPerStageDescriptorStorageBuffers
        {
            get { return M->MaxPerStageDescriptorStorageBuffers; }
            set { M->MaxPerStageDescriptorStorageBuffers = value; }
        }

        /// <summary>
        /// max number of sampled images allowed per-stage in a descriptor set
        /// </summary>
        public UInt32 MaxPerStageDescriptorSampledImages
        {
            get { return M->MaxPerStageDescriptorSampledImages; }
            set { M->MaxPerStageDescriptorSampledImages = value; }
        }

        /// <summary>
        /// max number of storage images allowed per-stage in a descriptor set
        /// </summary>
        public UInt32 MaxPerStageDescriptorStorageImages
        {
            get { return M->MaxPerStageDescriptorStorageImages; }
            set { M->MaxPerStageDescriptorStorageImages = value; }
        }

        /// <summary>
        /// max number of input attachments allowed per-stage in a descriptor set
        /// </summary>
        public UInt32 MaxPerStageDescriptorInputAttachments
        {
            get { return M->MaxPerStageDescriptorInputAttachments; }
            set { M->MaxPerStageDescriptorInputAttachments = value; }
        }

        /// <summary>
        /// max number of resources allowed by a single stage
        /// </summary>
        public UInt32 MaxPerStageResources
        {
            get { return M->MaxPerStageResources; }
            set { M->MaxPerStageResources = value; }
        }

        /// <summary>
        /// max number of samplers allowed in all stages in a descriptor set
        /// </summary>
        public UInt32 MaxDescriptorSetSamplers
        {
            get { return M->MaxDescriptorSetSamplers; }
            set { M->MaxDescriptorSetSamplers = value; }
        }

        /// <summary>
        /// max number of uniform buffers allowed in all stages in a descriptor set
        /// </summary>
        public UInt32 MaxDescriptorSetUniformBuffers
        {
            get { return M->MaxDescriptorSetUniformBuffers; }
            set { M->MaxDescriptorSetUniformBuffers = value; }
        }

        /// <summary>
        /// max number of dynamic uniform buffers allowed in all stages in a descriptor set
        /// </summary>
        public UInt32 MaxDescriptorSetUniformBuffersDynamic
        {
            get { return M->MaxDescriptorSetUniformBuffersDynamic; }
            set { M->MaxDescriptorSetUniformBuffersDynamic = value; }
        }

        /// <summary>
        /// max number of storage buffers allowed in all stages in a descriptor set
        /// </summary>
        public UInt32 MaxDescriptorSetStorageBuffers
        {
            get { return M->MaxDescriptorSetStorageBuffers; }
            set { M->MaxDescriptorSetStorageBuffers = value; }
        }

        /// <summary>
        /// max number of dynamic storage buffers allowed in all stages in a descriptor set
        /// </summary>
        public UInt32 MaxDescriptorSetStorageBuffersDynamic
        {
            get { return M->MaxDescriptorSetStorageBuffersDynamic; }
            set { M->MaxDescriptorSetStorageBuffersDynamic = value; }
        }

        /// <summary>
        /// max number of sampled images allowed in all stages in a descriptor set
        /// </summary>
        public UInt32 MaxDescriptorSetSampledImages
        {
            get { return M->MaxDescriptorSetSampledImages; }
            set { M->MaxDescriptorSetSampledImages = value; }
        }

        /// <summary>
        /// max number of storage images allowed in all stages in a descriptor set
        /// </summary>
        public UInt32 MaxDescriptorSetStorageImages
        {
            get { return M->MaxDescriptorSetStorageImages; }
            set { M->MaxDescriptorSetStorageImages = value; }
        }

        /// <summary>
        /// max number of input attachments allowed in all stages in a descriptor set
        /// </summary>
        public UInt32 MaxDescriptorSetInputAttachments
        {
            get { return M->MaxDescriptorSetInputAttachments; }
            set { M->MaxDescriptorSetInputAttachments = value; }
        }

        /// <summary>
        /// max number of vertex input attribute slots
        /// </summary>
        public UInt32 MaxVertexInputAttributes
        {
            get { return M->MaxVertexInputAttributes; }
            set { M->MaxVertexInputAttributes = value; }
        }

        /// <summary>
        /// max number of vertex input binding slots
        /// </summary>
        public UInt32 MaxVertexInputBindings
        {
            get { return M->MaxVertexInputBindings; }
            set { M->MaxVertexInputBindings = value; }
        }

        /// <summary>
        /// max vertex input attribute offset added to vertex buffer offset
        /// </summary>
        public UInt32 MaxVertexInputAttributeOffset
        {
            get { return M->MaxVertexInputAttributeOffset; }
            set { M->MaxVertexInputAttributeOffset = value; }
        }

        /// <summary>
        /// max vertex input binding stride
        /// </summary>
        public UInt32 MaxVertexInputBindingStride
        {
            get { return M->MaxVertexInputBindingStride; }
            set { M->MaxVertexInputBindingStride = value; }
        }

        /// <summary>
        /// max number of output components written by vertex shader
        /// </summary>
        public UInt32 MaxVertexOutputComponents
        {
            get { return M->MaxVertexOutputComponents; }
            set { M->MaxVertexOutputComponents = value; }
        }

        /// <summary>
        /// max level supported by tessellation primitive generator
        /// </summary>
        public UInt32 MaxTessellationGenerationLevel
        {
            get { return M->MaxTessellationGenerationLevel; }
            set { M->MaxTessellationGenerationLevel = value; }
        }

        /// <summary>
        /// max patch size(vertices)
        /// </summary>
        public UInt32 MaxTessellationPatchSize
        {
            get { return M->MaxTessellationPatchSize; }
            set { M->MaxTessellationPatchSize = value; }
        }

        /// <summary>
        /// max number of input components per-vertex in TCS
        /// </summary>
        public UInt32 MaxTessellationControlPerVertexInputComponents
        {
            get { return M->MaxTessellationControlPerVertexInputComponents; }
            set { M->MaxTessellationControlPerVertexInputComponents = value; }
        }

        /// <summary>
        /// max number of output components per-vertex in TCS
        /// </summary>
        public UInt32 MaxTessellationControlPerVertexOutputComponents
        {
            get { return M->MaxTessellationControlPerVertexOutputComponents; }
            set { M->MaxTessellationControlPerVertexOutputComponents = value; }
        }

        /// <summary>
        /// max number of output components per-patch in TCS
        /// </summary>
        public UInt32 MaxTessellationControlPerPatchOutputComponents
        {
            get { return M->MaxTessellationControlPerPatchOutputComponents; }
            set { M->MaxTessellationControlPerPatchOutputComponents = value; }
        }

        /// <summary>
        /// max total number of per-vertex and per-patch output components in TCS
        /// </summary>
        public UInt32 MaxTessellationControlTotalOutputComponents
        {
            get { return M->MaxTessellationControlTotalOutputComponents; }
            set { M->MaxTessellationControlTotalOutputComponents = value; }
        }

        /// <summary>
        /// max number of input components per vertex in TES
        /// </summary>
        public UInt32 MaxTessellationEvaluationInputComponents
        {
            get { return M->MaxTessellationEvaluationInputComponents; }
            set { M->MaxTessellationEvaluationInputComponents = value; }
        }

        /// <summary>
        /// max number of output components per vertex in TES
        /// </summary>
        public UInt32 MaxTessellationEvaluationOutputComponents
        {
            get { return M->MaxTessellationEvaluationOutputComponents; }
            set { M->MaxTessellationEvaluationOutputComponents = value; }
        }

        /// <summary>
        /// max invocation count supported in geometry shader
        /// </summary>
        public UInt32 MaxGeometryShaderInvocations
        {
            get { return M->MaxGeometryShaderInvocations; }
            set { M->MaxGeometryShaderInvocations = value; }
        }

        /// <summary>
        /// max number of input components read in geometry stage
        /// </summary>
        public UInt32 MaxGeometryInputComponents
        {
            get { return M->MaxGeometryInputComponents; }
            set { M->MaxGeometryInputComponents = value; }
        }

        /// <summary>
        /// max number of output components written in geometry stage
        /// </summary>
        public UInt32 MaxGeometryOutputComponents
        {
            get { return M->MaxGeometryOutputComponents; }
            set { M->MaxGeometryOutputComponents = value; }
        }

        /// <summary>
        /// max number of vertices that can be emitted in geometry stage
        /// </summary>
        public UInt32 MaxGeometryOutputVertices
        {
            get { return M->MaxGeometryOutputVertices; }
            set { M->MaxGeometryOutputVertices = value; }
        }

        /// <summary>
        /// max total number of components(all vertices) written in geometry stage
        /// </summary>
        public UInt32 MaxGeometryTotalOutputComponents
        {
            get { return M->MaxGeometryTotalOutputComponents; }
            set { M->MaxGeometryTotalOutputComponents = value; }
        }

        /// <summary>
        /// max number of input components read in fragment stage
        /// </summary>
        public UInt32 MaxFragmentInputComponents
        {
            get { return M->MaxFragmentInputComponents; }
            set { M->MaxFragmentInputComponents = value; }
        }

        /// <summary>
        /// max number of output attachments written in fragment stage
        /// </summary>
        public UInt32 MaxFragmentOutputAttachments
        {
            get { return M->MaxFragmentOutputAttachments; }
            set { M->MaxFragmentOutputAttachments = value; }
        }

        /// <summary>
        /// max number of output attachments written when using dual source blending
        /// </summary>
        public UInt32 MaxFragmentDualSrcAttachments
        {
            get { return M->MaxFragmentDualSrcAttachments; }
            set { M->MaxFragmentDualSrcAttachments = value; }
        }

        /// <summary>
        /// max total number of storage buffers, storage images and output buffers
        /// </summary>
        public UInt32 MaxFragmentCombinedOutputResources
        {
            get { return M->MaxFragmentCombinedOutputResources; }
            set { M->MaxFragmentCombinedOutputResources = value; }
        }

        /// <summary>
        /// max total storage size of work group local storage(bytes)
        /// </summary>
        public UInt32 MaxComputeSharedMemorySize
        {
            get { return M->MaxComputeSharedMemorySize; }
            set { M->MaxComputeSharedMemorySize = value; }
        }

        /// <summary>
        /// max num of compute work groups that may be dispatched by a single command(x,y,z)
        /// </summary>
        public UInt32[] MaxComputeWorkGroupCount
        {
            get
            {
                var arr = new UInt32[3];
                for (int i = 0; i < 3; i++)
                    arr[i] = M->MaxComputeWorkGroupCount[i];
                return arr;
            }
            set
            {
                if (value.Length > 3)
                    throw new Exception("array too long");
                for (int i = 0; i < value.Length; i++)
                    M->MaxComputeWorkGroupCount[i] = value[i];
                for (int i = value.Length; i < 3; i++)
                    M->MaxComputeWorkGroupCount[i] = 0;
            }
        }

        /// <summary>
        /// max total compute invocations in a single local work group
        /// </summary>
        public UInt32 MaxComputeWorkGroupInvocations
        {
            get { return M->MaxComputeWorkGroupInvocations; }
            set { M->MaxComputeWorkGroupInvocations = value; }
        }

        /// <summary>
        /// max local size of a compute work group(x,y,z)
        /// </summary>
        public UInt32[] MaxComputeWorkGroupSize
        {
            get
            {
                var arr = new UInt32[3];
                for (int i = 0; i < 3; i++)
                    arr[i] = M->MaxComputeWorkGroupSize[i];
                return arr;
            }
            set
            {
                if (value.Length > 3)
                    throw new Exception("array too long");
                for (int i = 0; i < value.Length; i++)
                    M->MaxComputeWorkGroupSize[i] = value[i];
                for (int i = value.Length; i < 3; i++)
                    M->MaxComputeWorkGroupSize[i] = 0;
            }
        }

        /// <summary>
        /// number bits of subpixel precision in screen x and y
        /// </summary>
        public UInt32 SubPixelPrecisionBits
        {
            get { return M->SubPixelPrecisionBits; }
            set { M->SubPixelPrecisionBits = value; }
        }

        /// <summary>
        /// number bits of precision for selecting texel weights
        /// </summary>
        public UInt32 SubTexelPrecisionBits
        {
            get { return M->SubTexelPrecisionBits; }
            set { M->SubTexelPrecisionBits = value; }
        }

        /// <summary>
        /// number bits of precision for selecting mipmap weights
        /// </summary>
        public UInt32 MipmapPrecisionBits
        {
            get { return M->MipmapPrecisionBits; }
            set { M->MipmapPrecisionBits = value; }
        }

        /// <summary>
        /// max index value for indexed draw calls(for 32-bit indices)
        /// </summary>
        public UInt32 MaxDrawIndexedIndexValue
        {
            get { return M->MaxDrawIndexedIndexValue; }
            set { M->MaxDrawIndexedIndexValue = value; }
        }

        /// <summary>
        /// max draw count for indirect draw calls
        /// </summary>
        public UInt32 MaxDrawIndirectCount
        {
            get { return M->MaxDrawIndirectCount; }
            set { M->MaxDrawIndirectCount = value; }
        }

        /// <summary>
        /// max absolute sampler LOD bias
        /// </summary>
        public float MaxSamplerLodBias
        {
            get { return M->MaxSamplerLodBias; }
            set { M->MaxSamplerLodBias = value; }
        }

        /// <summary>
        /// max degree of sampler anisotropy
        /// </summary>
        public float MaxSamplerAnisotropy
        {
            get { return M->MaxSamplerAnisotropy; }
            set { M->MaxSamplerAnisotropy = value; }
        }

        /// <summary>
        /// max number of active viewports
        /// </summary>
        public UInt32 MaxViewports
        {
            get { return M->MaxViewports; }
            set { M->MaxViewports = value; }
        }

        /// <summary>
        /// max viewport dimensions(x,y)
        /// </summary>
        public UInt32[] MaxViewportDimensions
        {
            get
            {
                var arr = new UInt32[2];
                for (int i = 0; i < 2; i++)
                    arr[i] = M->MaxViewportDimensions[i];
                return arr;
            }
            set
            {
                if (value.Length > 2)
                    throw new Exception("array too long");
                for (int i = 0; i < value.Length; i++)
                    M->MaxViewportDimensions[i] = value[i];
                for (int i = value.Length; i < 2; i++)
                    M->MaxViewportDimensions[i] = 0;
            }
        }

        /// <summary>
        /// viewport bounds range(min,max)
        /// </summary>
        public float[] ViewportBoundsRange
        {
            get
            {
                var arr = new float[2];
                for (int i = 0; i < 2; i++)
                    arr[i] = M->ViewportBoundsRange[i];
                return arr;
            }
            set
            {
                if (value.Length > 2)
                    throw new Exception("array too long");
                for (int i = 0; i < value.Length; i++)
                    M->ViewportBoundsRange[i] = value[i];
                for (int i = value.Length; i < 2; i++)
                    M->ViewportBoundsRange[i] = 0;
            }
        }

        /// <summary>
        /// number bits of subpixel precision for viewport
        /// </summary>
        public UInt32 ViewportSubPixelBits
        {
            get { return M->ViewportSubPixelBits; }
            set { M->ViewportSubPixelBits = value; }
        }

        /// <summary>
        /// min required alignment of pointers returned by MapMemory(bytes)
        /// </summary>
        public UIntPtr MinMemoryMapAlignment
        {
            get { return M->MinMemoryMapAlignment; }
            set { M->MinMemoryMapAlignment = value; }
        }

        /// <summary>
        /// min required alignment for texel buffer offsets(bytes) 
        /// </summary>
        public DeviceSize MinTexelBufferOffsetAlignment
        {
            get { return M->MinTexelBufferOffsetAlignment; }
            set { M->MinTexelBufferOffsetAlignment = value; }
        }

        /// <summary>
        /// min required alignment for uniform buffer sizes and offsets(bytes)
        /// </summary>
        public DeviceSize MinUniformBufferOffsetAlignment
        {
            get { return M->MinUniformBufferOffsetAlignment; }
            set { M->MinUniformBufferOffsetAlignment = value; }
        }

        /// <summary>
        /// min required alignment for storage buffer offsets(bytes)
        /// </summary>
        public DeviceSize MinStorageBufferOffsetAlignment
        {
            get { return M->MinStorageBufferOffsetAlignment; }
            set { M->MinStorageBufferOffsetAlignment = value; }
        }

        /// <summary>
        /// min texel offset for OpTextureSampleOffset
        /// </summary>
        public Int32 MinTexelOffset
        {
            get { return M->MinTexelOffset; }
            set { M->MinTexelOffset = value; }
        }

        /// <summary>
        /// max texel offset for OpTextureSampleOffset
        /// </summary>
        public UInt32 MaxTexelOffset
        {
            get { return M->MaxTexelOffset; }
            set { M->MaxTexelOffset = value; }
        }

        /// <summary>
        /// min texel offset for OpTextureGatherOffset
        /// </summary>
        public Int32 MinTexelGatherOffset
        {
            get { return M->MinTexelGatherOffset; }
            set { M->MinTexelGatherOffset = value; }
        }

        /// <summary>
        /// max texel offset for OpTextureGatherOffset
        /// </summary>
        public UInt32 MaxTexelGatherOffset
        {
            get { return M->MaxTexelGatherOffset; }
            set { M->MaxTexelGatherOffset = value; }
        }

        /// <summary>
        /// furthest negative offset for interpolateAtOffset
        /// </summary>
        public float MinInterpolationOffset
        {
            get { return M->MinInterpolationOffset; }
            set { M->MinInterpolationOffset = value; }
        }

        /// <summary>
        /// furthest positive offset for interpolateAtOffset
        /// </summary>
        public float MaxInterpolationOffset
        {
            get { return M->MaxInterpolationOffset; }
            set { M->MaxInterpolationOffset = value; }
        }

        /// <summary>
        /// number of subpixel bits for interpolateAtOffset
        /// </summary>
        public UInt32 SubPixelInterpolationOffsetBits
        {
            get { return M->SubPixelInterpolationOffsetBits; }
            set { M->SubPixelInterpolationOffsetBits = value; }
        }

        /// <summary>
        /// max width for a framebuffer
        /// </summary>
        public UInt32 MaxFramebufferWidth
        {
            get { return M->MaxFramebufferWidth; }
            set { M->MaxFramebufferWidth = value; }
        }

        /// <summary>
        /// max height for a framebuffer
        /// </summary>
        public UInt32 MaxFramebufferHeight
        {
            get { return M->MaxFramebufferHeight; }
            set { M->MaxFramebufferHeight = value; }
        }

        /// <summary>
        /// max layer count for a layered framebuffer
        /// </summary>
        public UInt32 MaxFramebufferLayers
        {
            get { return M->MaxFramebufferLayers; }
            set { M->MaxFramebufferLayers = value; }
        }

        /// <summary>
        /// supported color sample counts for a framebuffer
        /// </summary>
        public SampleCountFlags FramebufferColorSampleCounts
        {
            get { return M->FramebufferColorSampleCounts; }
            set { M->FramebufferColorSampleCounts = value; }
        }

        /// <summary>
        /// supported depth sample counts for a framebuffer
        /// </summary>
        public SampleCountFlags FramebufferDepthSampleCounts
        {
            get { return M->FramebufferDepthSampleCounts; }
            set { M->FramebufferDepthSampleCounts = value; }
        }

        /// <summary>
        /// supported stencil sample counts for a framebuffer
        /// </summary>
        public SampleCountFlags FramebufferStencilSampleCounts
        {
            get { return M->FramebufferStencilSampleCounts; }
            set { M->FramebufferStencilSampleCounts = value; }
        }

        /// <summary>
        /// supported sample counts for a framebuffer with no attachments
        /// </summary>
        public SampleCountFlags FramebufferNoAttachmentsSampleCounts
        {
            get { return M->FramebufferNoAttachmentsSampleCounts; }
            set { M->FramebufferNoAttachmentsSampleCounts = value; }
        }

        /// <summary>
        /// max number of color attachments per subpass
        /// </summary>
        public UInt32 MaxColorAttachments
        {
            get { return M->MaxColorAttachments; }
            set { M->MaxColorAttachments = value; }
        }

        /// <summary>
        /// supported color sample counts for a non-integer sampled image
        /// </summary>
        public SampleCountFlags SampledImageColorSampleCounts
        {
            get { return M->SampledImageColorSampleCounts; }
            set { M->SampledImageColorSampleCounts = value; }
        }

        /// <summary>
        /// supported sample counts for an integer image
        /// </summary>
        public SampleCountFlags SampledImageIntegerSampleCounts
        {
            get { return M->SampledImageIntegerSampleCounts; }
            set { M->SampledImageIntegerSampleCounts = value; }
        }

        /// <summary>
        /// supported depth sample counts for a sampled image
        /// </summary>
        public SampleCountFlags SampledImageDepthSampleCounts
        {
            get { return M->SampledImageDepthSampleCounts; }
            set { M->SampledImageDepthSampleCounts = value; }
        }

        /// <summary>
        /// supported stencil sample counts for a sampled image
        /// </summary>
        public SampleCountFlags SampledImageStencilSampleCounts
        {
            get { return M->SampledImageStencilSampleCounts; }
            set { M->SampledImageStencilSampleCounts = value; }
        }

        /// <summary>
        /// supported sample counts for a storage image
        /// </summary>
        public SampleCountFlags StorageImageSampleCounts
        {
            get { return M->StorageImageSampleCounts; }
            set { M->StorageImageSampleCounts = value; }
        }

        /// <summary>
        /// max number of sample mask words
        /// </summary>
        public UInt32 MaxSampleMaskWords
        {
            get { return M->MaxSampleMaskWords; }
            set { M->MaxSampleMaskWords = value; }
        }

        /// <summary>
        /// timestamps on graphics and compute queues
        /// </summary>
        public bool TimestampComputeAndGraphics
        {
            get { return M->TimestampComputeAndGraphics; }
            set { M->TimestampComputeAndGraphics = value; }
        }

        /// <summary>
        /// number of nanoseconds it takes for timestamp query value to increment by 1
        /// </summary>
        public float TimestampPeriod
        {
            get { return M->TimestampPeriod; }
            set { M->TimestampPeriod = value; }
        }

        /// <summary>
        /// max number of clip distances
        /// </summary>
        public UInt32 MaxClipDistances
        {
            get { return M->MaxClipDistances; }
            set { M->MaxClipDistances = value; }
        }

        /// <summary>
        /// max number of cull distances
        /// </summary>
        public UInt32 MaxCullDistances
        {
            get { return M->MaxCullDistances; }
            set { M->MaxCullDistances = value; }
        }

        /// <summary>
        /// max combined number of user clipping
        /// </summary>
        public UInt32 MaxCombinedClipAndCullDistances
        {
            get { return M->MaxCombinedClipAndCullDistances; }
            set { M->MaxCombinedClipAndCullDistances = value; }
        }

        /// <summary>
        /// distinct queue priorities available 
        /// </summary>
        public UInt32 DiscreteQueuePriorities
        {
            get { return M->DiscreteQueuePriorities; }
            set { M->DiscreteQueuePriorities = value; }
        }

        /// <summary>
        /// range(min,max) of supported point sizes
        /// </summary>
        public float[] PointSizeRange
        {
            get
            {
                var arr = new float[2];
                for (int i = 0; i < 2; i++)
                    arr[i] = M->PointSizeRange[i];
                return arr;
            }
            set
            {
                if (value.Length > 2)
                    throw new Exception("array too long");
                for (int i = 0; i < value.Length; i++)
                    M->PointSizeRange[i] = value[i];
                for (int i = value.Length; i < 2; i++)
                    M->PointSizeRange[i] = 0;
            }
        }

        /// <summary>
        /// range(min,max) of supported line widths
        /// </summary>
        public float[] LineWidthRange
        {
            get
            {
                var arr = new float[2];
                for (int i = 0; i < 2; i++)
                    arr[i] = M->LineWidthRange[i];
                return arr;
            }
            set
            {
                if (value.Length > 2)
                    throw new Exception("array too long");
                for (int i = 0; i < value.Length; i++)
                    M->LineWidthRange[i] = value[i];
                for (int i = value.Length; i < 2; i++)
                    M->LineWidthRange[i] = 0;
            }
        }

        /// <summary>
        /// granularity of supported point sizes
        /// </summary>
        public float PointSizeGranularity
        {
            get { return M->PointSizeGranularity; }
            set { M->PointSizeGranularity = value; }
        }

        /// <summary>
        /// granularity of supported line widths
        /// </summary>
        public float LineWidthGranularity
        {
            get { return M->LineWidthGranularity; }
            set { M->LineWidthGranularity = value; }
        }

        /// <summary>
        /// line rasterization follows preferred rules
        /// </summary>
        public bool StrictLines
        {
            get { return M->StrictLines; }
            set { M->StrictLines = value; }
        }

        /// <summary>
        /// supports standard sample locations for all supported sample counts
        /// </summary>
        public bool StandardSampleLocations
        {
            get { return M->StandardSampleLocations; }
            set { M->StandardSampleLocations = value; }
        }

        /// <summary>
        /// optimal offset of buffer copies
        /// </summary>
        public DeviceSize OptimalBufferCopyOffsetAlignment
        {
            get { return M->OptimalBufferCopyOffsetAlignment; }
            set { M->OptimalBufferCopyOffsetAlignment = value; }
        }

        /// <summary>
        /// optimal pitch of buffer copies
        /// </summary>
        public DeviceSize OptimalBufferCopyRowPitchAlignment
        {
            get { return M->OptimalBufferCopyRowPitchAlignment; }
            set { M->OptimalBufferCopyRowPitchAlignment = value; }
        }

        /// <summary>
        /// minimum size and alignment for non-coherent host-mapped device memory access
        /// </summary>
        public DeviceSize NonCoherentAtomSize
        {
            get { return M->NonCoherentAtomSize; }
            set { M->NonCoherentAtomSize = value; }
        }

        internal Interop.PhysicalDeviceLimits* M
        {
            get { return (Interop.PhysicalDeviceLimits*)native.Handle; }
        }

        public PhysicalDeviceLimits()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PhysicalDeviceLimits));
        }

        internal PhysicalDeviceLimits(NativePointer pointer)
        {
            native = pointer;
        }
    }

    unsafe public partial class SemaphoreCreateInfo : MarshalledObject
    {
        /// <summary>
        /// Semaphore creation flags
        /// </summary>
        public SemaphoreCreateFlags Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        internal Interop.SemaphoreCreateInfo* M
        {
            get { return (Interop.SemaphoreCreateInfo*)native.Handle; }
        }

        public SemaphoreCreateInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.SemaphoreCreateInfo));

            M->SType = StructureType.SemaphoreCreateInfo;
        }

        internal SemaphoreCreateInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.SemaphoreCreateInfo;
        }
    }

    unsafe public partial class QueryPoolCreateInfo : MarshalledObject
    {
        public QueryPoolCreateFlags Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        public QueryType QueryType
        {
            get { return M->QueryType; }
            set { M->QueryType = value; }
        }

        public UInt32 QueryCount
        {
            get { return M->QueryCount; }
            set { M->QueryCount = value; }
        }

        /// <summary>
        /// Optional
        /// </summary>
        public QueryPipelineStatisticFlags PipelineStatistics
        {
            get { return M->PipelineStatistics; }
            set { M->PipelineStatistics = value; }
        }

        internal Interop.QueryPoolCreateInfo* M
        {
            get { return (Interop.QueryPoolCreateInfo*)native.Handle; }
        }

        public QueryPoolCreateInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.QueryPoolCreateInfo));

            M->SType = StructureType.QueryPoolCreateInfo;
        }

        internal QueryPoolCreateInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.QueryPoolCreateInfo;
        }
    }

    unsafe public partial class FramebufferCreateInfo : MarshalledObject
    {
        public FramebufferCreateFlags Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        RenderPass lRenderPass;
        public RenderPass RenderPass
        {
            get { return lRenderPass; }
            set { lRenderPass = value; M->RenderPass = value != null ? (UInt64)value.M : default(UInt64); }
        }

        public UInt32 AttachmentCount
        {
            get { return M->AttachmentCount; }
            set { M->AttachmentCount = value; }
        }

        NativeReference refAttachments;
        public ImageView[] Attachments
        {
            get
            {
                if (M->AttachmentCount == 0)
                    return null;
                var values = new ImageView[M->AttachmentCount];
                unsafe
                {
                    UInt64* ptr = (UInt64*)M->Attachments;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = new ImageView();
                        values[i].M = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->AttachmentCount = 0;
                    M->Attachments = IntPtr.Zero;
                    return;
                }
                M->AttachmentCount = (uint)value.Length;
                refAttachments = new NativeReference((int)(sizeof(UInt64) * value.Length));
                M->Attachments = refAttachments.Handle;
                unsafe
                {
                    UInt64* ptr = (UInt64*)M->Attachments;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i].M;
                    }
                }
            }
        }

        public UInt32 Width
        {
            get { return M->Width; }
            set { M->Width = value; }
        }

        public UInt32 Height
        {
            get { return M->Height; }
            set { M->Height = value; }
        }

        public UInt32 Layers
        {
            get { return M->Layers; }
            set { M->Layers = value; }
        }

        internal Interop.FramebufferCreateInfo* M
        {
            get { return (Interop.FramebufferCreateInfo*)native.Handle; }
        }

        public FramebufferCreateInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.FramebufferCreateInfo));

            M->SType = StructureType.FramebufferCreateInfo;
        }

        internal FramebufferCreateInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.FramebufferCreateInfo;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refAttachments.Dispose();
            refAttachments = null;
        }
    }

    unsafe public partial struct DrawIndirectCommand
    {
        public UInt32 VertexCount;
        public UInt32 InstanceCount;
        public UInt32 FirstVertex;
        public UInt32 FirstInstance;
    }

    unsafe public partial struct DrawIndexedIndirectCommand
    {
        public UInt32 IndexCount;
        public UInt32 InstanceCount;
        public UInt32 FirstIndex;
        public Int32 VertexOffset;
        public UInt32 FirstInstance;
    }

    unsafe public partial struct DispatchIndirectCommand
    {
        public UInt32 X;
        public UInt32 Y;
        public UInt32 Z;
    }

    unsafe public partial class SubmitInfo : MarshalledObject
    {
        public UInt32 WaitSemaphoreCount
        {
            get { return M->WaitSemaphoreCount; }
            set { M->WaitSemaphoreCount = value; }
        }

        NativeReference refWaitSemaphores;
        public Semaphore[] WaitSemaphores
        {
            get
            {
                if (M->WaitSemaphoreCount == 0)
                    return null;
                var values = new Semaphore[M->WaitSemaphoreCount];
                unsafe
                {
                    UInt64* ptr = (UInt64*)M->WaitSemaphores;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = new Semaphore();
                        values[i].M = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->WaitSemaphoreCount = 0;
                    M->WaitSemaphores = IntPtr.Zero;
                    return;
                }
                M->WaitSemaphoreCount = (uint)value.Length;
                refWaitSemaphores = new NativeReference((int)(sizeof(UInt64) * value.Length));
                M->WaitSemaphores = refWaitSemaphores.Handle;
                unsafe
                {
                    UInt64* ptr = (UInt64*)M->WaitSemaphores;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i].M;
                    }
                }
            }
        }

        NativeReference refWaitDstStageMask;
        public PipelineStageFlags[] WaitDstStageMask
        {
            get
            {
                if (M->WaitSemaphoreCount == 0)
                    return null;
                var values = new PipelineStageFlags[M->WaitSemaphoreCount];
                unsafe
                {
                    PipelineStageFlags* ptr = (PipelineStageFlags*)M->WaitDstStageMask;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->WaitSemaphoreCount = 0;
                    M->WaitDstStageMask = IntPtr.Zero;
                    return;
                }
                M->WaitSemaphoreCount = (uint)value.Length;
                refWaitDstStageMask = new NativeReference((int)(sizeof(PipelineStageFlags) * value.Length));
                M->WaitDstStageMask = refWaitDstStageMask.Handle;
                unsafe
                {
                    PipelineStageFlags* ptr = (PipelineStageFlags*)M->WaitDstStageMask;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        public UInt32 CommandBufferCount
        {
            get { return M->CommandBufferCount; }
            set { M->CommandBufferCount = value; }
        }

        NativeReference refCommandBuffers;
        public CommandBuffer[] CommandBuffers
        {
            get
            {
                if (M->CommandBufferCount == 0)
                    return null;
                var values = new CommandBuffer[M->CommandBufferCount];
                unsafe
                {
                    IntPtr* ptr = (IntPtr*)M->CommandBuffers;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = new CommandBuffer();
                        values[i].M = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->CommandBufferCount = 0;
                    M->CommandBuffers = IntPtr.Zero;
                    return;
                }
                M->CommandBufferCount = (uint)value.Length;
                refCommandBuffers = new NativeReference((int)(sizeof(IntPtr) * value.Length));
                M->CommandBuffers = refCommandBuffers.Handle;
                unsafe
                {
                    IntPtr* ptr = (IntPtr*)M->CommandBuffers;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i].M;
                    }
                }
            }
        }

        public UInt32 SignalSemaphoreCount
        {
            get { return M->SignalSemaphoreCount; }
            set { M->SignalSemaphoreCount = value; }
        }

        NativeReference refSignalSemaphores;
        public Semaphore[] SignalSemaphores
        {
            get
            {
                if (M->SignalSemaphoreCount == 0)
                    return null;
                var values = new Semaphore[M->SignalSemaphoreCount];
                unsafe
                {
                    UInt64* ptr = (UInt64*)M->SignalSemaphores;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = new Semaphore();
                        values[i].M = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->SignalSemaphoreCount = 0;
                    M->SignalSemaphores = IntPtr.Zero;
                    return;
                }
                M->SignalSemaphoreCount = (uint)value.Length;
                refSignalSemaphores = new NativeReference((int)(sizeof(UInt64) * value.Length));
                M->SignalSemaphores = refSignalSemaphores.Handle;
                unsafe
                {
                    UInt64* ptr = (UInt64*)M->SignalSemaphores;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i].M;
                    }
                }
            }
        }

        internal Interop.SubmitInfo* M
        {
            get { return (Interop.SubmitInfo*)native.Handle; }
        }

        public SubmitInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.SubmitInfo));

            M->SType = StructureType.SubmitInfo;
        }

        internal SubmitInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.SubmitInfo;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refWaitSemaphores.Dispose();
            refWaitSemaphores = null;
            refWaitDstStageMask.Dispose();
            refWaitDstStageMask = null;
            refCommandBuffers.Dispose();
            refCommandBuffers = null;
            refSignalSemaphores.Dispose();
            refSignalSemaphores = null;
        }
    }

    unsafe public partial class DisplayPropertiesKhr : MarshalledObject
    {
        /// <summary>
        /// Handle of the display object
        /// </summary>
        DisplayKhr lDisplay;
        public DisplayKhr Display
        {
            get { return lDisplay; }
            set { lDisplay = value; M->Display = value != null ? (UInt64)value.M : default(UInt64); }
        }

        /// <summary>
        /// Name of the display
        /// </summary>
        public string DisplayName
        {
            get { return Marshal.PtrToStringAnsi(M->DisplayName); }
            set { M->DisplayName = Marshal.StringToHGlobalAnsi(value); }
        }

        /// <summary>
        /// In millimeters?
        /// </summary>
        public Extent2D PhysicalDimensions
        {
            get { return M->PhysicalDimensions; }
            set { M->PhysicalDimensions = value; }
        }

        /// <summary>
        /// Max resolution for CRT?
        /// </summary>
        public Extent2D PhysicalResolution
        {
            get { return M->PhysicalResolution; }
            set { M->PhysicalResolution = value; }
        }

        /// <summary>
        /// one or more bits from VkSurfaceTransformFlagsKHR
        /// </summary>
        public SurfaceTransformFlagsKhr SupportedTransforms
        {
            get { return M->SupportedTransforms; }
            set { M->SupportedTransforms = value; }
        }

        /// <summary>
        /// VK_TRUE if the overlay plane's z-order can be changed on this display.
        /// </summary>
        public bool PlaneReorderPossible
        {
            get { return M->PlaneReorderPossible; }
            set { M->PlaneReorderPossible = value; }
        }

        /// <summary>
        /// VK_TRUE if this is a "smart" display that supports self-refresh/internal buffering.
        /// </summary>
        public bool PersistentContent
        {
            get { return M->PersistentContent; }
            set { M->PersistentContent = value; }
        }

        internal Interop.DisplayPropertiesKhr* M
        {
            get { return (Interop.DisplayPropertiesKhr*)native.Handle; }
        }

        public DisplayPropertiesKhr()
        {
            native = Interop.Structure.Allocate(typeof(Interop.DisplayPropertiesKhr));

        }

        internal DisplayPropertiesKhr(NativePointer pointer)
        {
            native = pointer;

        }
    }

    unsafe public partial class DisplayPlanePropertiesKhr : MarshalledObject
    {
        /// <summary>
        /// Display the plane is currently associated with.  Will be VK_NULL_HANDLE if the plane is not in use.
        /// </summary>
        DisplayKhr lCurrentDisplay;
        public DisplayKhr CurrentDisplay
        {
            get { return lCurrentDisplay; }
            set { lCurrentDisplay = value; M->CurrentDisplay = value != null ? (UInt64)value.M : default(UInt64); }
        }

        /// <summary>
        /// Current z-order of the plane.
        /// </summary>
        public UInt32 CurrentStackIndex
        {
            get { return M->CurrentStackIndex; }
            set { M->CurrentStackIndex = value; }
        }

        internal Interop.DisplayPlanePropertiesKhr* M
        {
            get { return (Interop.DisplayPlanePropertiesKhr*)native.Handle; }
        }

        public DisplayPlanePropertiesKhr()
        {
            native = Interop.Structure.Allocate(typeof(Interop.DisplayPlanePropertiesKhr));

        }

        internal DisplayPlanePropertiesKhr(NativePointer pointer)
        {
            native = pointer;

        }
    }

    unsafe public partial struct DisplayModeParametersKhr
    {
        /// <summary>
        /// Visible scanout region.
        /// </summary>
        public Extent2D VisibleRegion;
        /// <summary>
        /// Number of times per second the display is updated.
        /// </summary>
        public UInt32 RefreshRate;
    }

    unsafe public partial class DisplayModePropertiesKhr : MarshalledObject
    {
        /// <summary>
        /// Handle of this display mode.
        /// </summary>
        DisplayModeKhr lDisplayMode;
        public DisplayModeKhr DisplayMode
        {
            get { return lDisplayMode; }
            set { lDisplayMode = value; M->DisplayMode = value != null ? (UInt64)value.M : default(UInt64); }
        }

        /// <summary>
        /// The parameters this mode uses.
        /// </summary>
        public DisplayModeParametersKhr Parameters
        {
            get { return M->Parameters; }
            set { M->Parameters = value; }
        }

        internal Interop.DisplayModePropertiesKhr* M
        {
            get { return (Interop.DisplayModePropertiesKhr*)native.Handle; }
        }

        public DisplayModePropertiesKhr()
        {
            native = Interop.Structure.Allocate(typeof(Interop.DisplayModePropertiesKhr));

        }

        internal DisplayModePropertiesKhr(NativePointer pointer)
        {
            native = pointer;

        }
    }

    unsafe public partial class DisplayModeCreateInfoKhr : MarshalledObject
    {
        public DisplayModeCreateFlagsKhr Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        /// <summary>
        /// The parameters this mode uses.
        /// </summary>
        public DisplayModeParametersKhr Parameters
        {
            get { return M->Parameters; }
            set { M->Parameters = value; }
        }

        internal Interop.DisplayModeCreateInfoKhr* M
        {
            get { return (Interop.DisplayModeCreateInfoKhr*)native.Handle; }
        }

        public DisplayModeCreateInfoKhr()
        {
            native = Interop.Structure.Allocate(typeof(Interop.DisplayModeCreateInfoKhr));

            M->SType = StructureType.DisplayModeCreateInfoKhr;
        }

        internal DisplayModeCreateInfoKhr(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.DisplayModeCreateInfoKhr;
        }
    }

    unsafe public partial struct DisplayPlaneCapabilitiesKhr
    {
        /// <summary>
        /// Types of alpha blending supported, if any.
        /// </summary>
        public DisplayPlaneAlphaFlagsKhr SupportedAlpha;
        /// <summary>
        /// Does the plane have any position and extent restrictions?
        /// </summary>
        public Offset2D MinSrcPosition;
        public Offset2D MaxSrcPosition;
        public Extent2D MinSrcExtent;
        public Extent2D MaxSrcExtent;
        public Offset2D MinDstPosition;
        public Offset2D MaxDstPosition;
        public Extent2D MinDstExtent;
        public Extent2D MaxDstExtent;
    }

    unsafe public partial class DisplaySurfaceCreateInfoKhr : MarshalledObject
    {
        public DisplaySurfaceCreateFlagsKhr Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        /// <summary>
        /// The mode to use when displaying this surface
        /// </summary>
        DisplayModeKhr lDisplayMode;
        public DisplayModeKhr DisplayMode
        {
            get { return lDisplayMode; }
            set { lDisplayMode = value; M->DisplayMode = value != null ? (UInt64)value.M : default(UInt64); }
        }

        /// <summary>
        /// The plane on which this surface appears.  Must be between 0 and the value returned by vkGetPhysicalDeviceDisplayPlanePropertiesKHR() in pPropertyCount.
        /// </summary>
        public UInt32 PlaneIndex
        {
            get { return M->PlaneIndex; }
            set { M->PlaneIndex = value; }
        }

        /// <summary>
        /// The z-order of the plane.
        /// </summary>
        public UInt32 PlaneStackIndex
        {
            get { return M->PlaneStackIndex; }
            set { M->PlaneStackIndex = value; }
        }

        /// <summary>
        /// Transform to apply to the images as part of the scanout operation
        /// </summary>
        public SurfaceTransformFlagsKhr Transform
        {
            get { return M->Transform; }
            set { M->Transform = value; }
        }

        /// <summary>
        /// Global alpha value.  Must be between 0 and 1, inclusive.  Ignored if alphaMode is not VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR
        /// </summary>
        public float GlobalAlpha
        {
            get { return M->GlobalAlpha; }
            set { M->GlobalAlpha = value; }
        }

        /// <summary>
        /// What type of alpha blending to use.  Must be a bit from vkGetDisplayPlanePropertiesKHR::supportedAlpha.
        /// </summary>
        public DisplayPlaneAlphaFlagsKhr AlphaMode
        {
            get { return M->AlphaMode; }
            set { M->AlphaMode = value; }
        }

        /// <summary>
        /// size of the images to use with this surface
        /// </summary>
        public Extent2D ImageExtent
        {
            get { return M->ImageExtent; }
            set { M->ImageExtent = value; }
        }

        internal Interop.DisplaySurfaceCreateInfoKhr* M
        {
            get { return (Interop.DisplaySurfaceCreateInfoKhr*)native.Handle; }
        }

        public DisplaySurfaceCreateInfoKhr()
        {
            native = Interop.Structure.Allocate(typeof(Interop.DisplaySurfaceCreateInfoKhr));

            M->SType = StructureType.DisplaySurfaceCreateInfoKhr;
        }

        internal DisplaySurfaceCreateInfoKhr(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.DisplaySurfaceCreateInfoKhr;
        }
    }

    unsafe public partial class DisplayPresentInfoKhr : PresentInfoKhr
    {
        /// <summary>
        /// Rectangle within the presentable image to read pixel data from when presenting to the display.
        /// </summary>
        public Rect2D SrcRect
        {
            get { return M->SrcRect; }
            set { M->SrcRect = value; }
        }

        /// <summary>
        /// Rectangle within the current display mode's visible region to display srcRectangle in.
        /// </summary>
        public Rect2D DstRect
        {
            get { return M->DstRect; }
            set { M->DstRect = value; }
        }

        /// <summary>
        /// For smart displays, use buffered mode.  If the display properties member "persistentMode" is VK_FALSE, this member must always be VK_FALSE.
        /// </summary>
        public bool Persistent
        {
            get { return M->Persistent; }
            set { M->Persistent = value; }
        }

        internal new Interop.DisplayPresentInfoKhr* M
        {
            get { return (Interop.DisplayPresentInfoKhr*)native.Handle; }
        }

        public DisplayPresentInfoKhr()
        {
            native = Interop.Structure.Allocate(typeof(Interop.DisplayPresentInfoKhr));

            M->SType = StructureType.DisplayPresentInfoKhr;
        }

        internal DisplayPresentInfoKhr(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.DisplayPresentInfoKhr;
        }
    }

    unsafe public partial struct SurfaceCapabilitiesKhr
    {
        /// <summary>
        /// Supported minimum number of images for the surface
        /// </summary>
        public UInt32 MinImageCount;
        /// <summary>
        /// Supported maximum number of images for the surface, 0 for unlimited
        /// </summary>
        public UInt32 MaxImageCount;
        /// <summary>
        /// Current image width and height for the surface, (0, 0) if undefined
        /// </summary>
        public Extent2D CurrentExtent;
        /// <summary>
        /// Supported minimum image width and height for the surface
        /// </summary>
        public Extent2D MinImageExtent;
        /// <summary>
        /// Supported maximum image width and height for the surface
        /// </summary>
        public Extent2D MaxImageExtent;
        /// <summary>
        /// Supported maximum number of image layers for the surface
        /// </summary>
        public UInt32 MaxImageArrayLayers;
        /// <summary>
        /// 1 or more bits representing the transforms supported
        /// </summary>
        public SurfaceTransformFlagsKhr SupportedTransforms;
        /// <summary>
        /// The surface's current transform relative to the device's natural orientation
        /// </summary>
        public SurfaceTransformFlagsKhr CurrentTransform;
        /// <summary>
        /// 1 or more bits representing the alpha compositing modes supported
        /// </summary>
        public CompositeAlphaFlagsKhr SupportedCompositeAlpha;
        /// <summary>
        /// Supported image usage flags for the surface
        /// </summary>
        public ImageUsageFlags SupportedUsageFlags;
    }

    unsafe public partial class AndroidSurfaceCreateInfoKhr : MarshalledObject
    {
        public AndroidSurfaceCreateFlagsKhr Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        public IntPtr Window
        {
            get { return M->Window; }
            set { M->Window = value; }
        }

        internal Interop.AndroidSurfaceCreateInfoKhr* M
        {
            get { return (Interop.AndroidSurfaceCreateInfoKhr*)native.Handle; }
        }

        public AndroidSurfaceCreateInfoKhr()
        {
            native = Interop.Structure.Allocate(typeof(Interop.AndroidSurfaceCreateInfoKhr));

            M->SType = StructureType.AndroidSurfaceCreateInfoKhr;
        }

        internal AndroidSurfaceCreateInfoKhr(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.AndroidSurfaceCreateInfoKhr;
        }
    }

    unsafe public partial class ViSurfaceCreateInfoNn : MarshalledObject
    {
        public ViSurfaceCreateFlagsNn Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        public IntPtr Window
        {
            get { return M->Window; }
            set { M->Window = value; }
        }

        internal Interop.ViSurfaceCreateInfoNn* M
        {
            get { return (Interop.ViSurfaceCreateInfoNn*)native.Handle; }
        }

        public ViSurfaceCreateInfoNn()
        {
            native = Interop.Structure.Allocate(typeof(Interop.ViSurfaceCreateInfoNn));

            M->SType = StructureType.ViSurfaceCreateInfoNn;
        }

        internal ViSurfaceCreateInfoNn(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.ViSurfaceCreateInfoNn;
        }
    }

    unsafe public partial class Win32SurfaceCreateInfoKhr : MarshalledObject
    {
        public Win32SurfaceCreateFlagsKhr Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        public IntPtr Hinstance
        {
            get { return M->Hinstance; }
            set { M->Hinstance = value; }
        }

        public IntPtr Hwnd
        {
            get { return M->Hwnd; }
            set { M->Hwnd = value; }
        }

        internal Interop.Win32SurfaceCreateInfoKhr* M
        {
            get { return (Interop.Win32SurfaceCreateInfoKhr*)native.Handle; }
        }

        public Win32SurfaceCreateInfoKhr()
        {
            native = Interop.Structure.Allocate(typeof(Interop.Win32SurfaceCreateInfoKhr));

            M->SType = StructureType.Win32SurfaceCreateInfoKhr;
        }

        internal Win32SurfaceCreateInfoKhr(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.Win32SurfaceCreateInfoKhr;
        }
    }

    unsafe public partial struct SurfaceFormatKhr
    {
        /// <summary>
        /// Supported pair of rendering format
        /// </summary>
        public Format Format;
        /// <summary>
        /// and color space for the surface
        /// </summary>
        public ColorSpaceKhr ColorSpace;
    }

    unsafe public partial class SwapchainCreateInfoKhr : MarshalledObject
    {
        public SwapchainCreateFlagsKhr Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        /// <summary>
        /// The swapchain's target surface
        /// </summary>
        SurfaceKhr lSurface;
        public SurfaceKhr Surface
        {
            get { return lSurface; }
            set { lSurface = value; M->Surface = value != null ? (UInt64)value.M : default(UInt64); }
        }

        /// <summary>
        /// Minimum number of presentation images the application needs
        /// </summary>
        public UInt32 MinImageCount
        {
            get { return M->MinImageCount; }
            set { M->MinImageCount = value; }
        }

        /// <summary>
        /// Format of the presentation images
        /// </summary>
        public Format ImageFormat
        {
            get { return M->ImageFormat; }
            set { M->ImageFormat = value; }
        }

        /// <summary>
        /// Colorspace of the presentation images
        /// </summary>
        public ColorSpaceKhr ImageColorSpace
        {
            get { return M->ImageColorSpace; }
            set { M->ImageColorSpace = value; }
        }

        /// <summary>
        /// Dimensions of the presentation images
        /// </summary>
        public Extent2D ImageExtent
        {
            get { return M->ImageExtent; }
            set { M->ImageExtent = value; }
        }

        /// <summary>
        /// Determines the number of views for multiview/stereo presentation
        /// </summary>
        public UInt32 ImageArrayLayers
        {
            get { return M->ImageArrayLayers; }
            set { M->ImageArrayLayers = value; }
        }

        /// <summary>
        /// Bits indicating how the presentation images will be used
        /// </summary>
        public ImageUsageFlags ImageUsage
        {
            get { return M->ImageUsage; }
            set { M->ImageUsage = value; }
        }

        /// <summary>
        /// Sharing mode used for the presentation images
        /// </summary>
        public SharingMode ImageSharingMode
        {
            get { return M->ImageSharingMode; }
            set { M->ImageSharingMode = value; }
        }

        /// <summary>
        /// Number of queue families having access to the images in case of concurrent sharing mode
        /// </summary>
        public UInt32 QueueFamilyIndexCount
        {
            get { return M->QueueFamilyIndexCount; }
            set { M->QueueFamilyIndexCount = value; }
        }

        /// <summary>
        /// Array of queue family indices having access to the images in case of concurrent sharing mode
        /// </summary>
        NativeReference refQueueFamilyIndices;
        public UInt32[] QueueFamilyIndices
        {
            get
            {
                if (M->QueueFamilyIndexCount == 0)
                    return null;
                var values = new UInt32[M->QueueFamilyIndexCount];
                unsafe
                {
                    UInt32* ptr = (UInt32*)M->QueueFamilyIndices;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->QueueFamilyIndexCount = 0;
                    M->QueueFamilyIndices = IntPtr.Zero;
                    return;
                }
                M->QueueFamilyIndexCount = (uint)value.Length;
                refQueueFamilyIndices = new NativeReference((int)(sizeof(UInt32) * value.Length));
                M->QueueFamilyIndices = refQueueFamilyIndices.Handle;
                unsafe
                {
                    UInt32* ptr = (UInt32*)M->QueueFamilyIndices;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        /// <summary>
        /// The transform, relative to the device's natural orientation, applied to the image content prior to presentation
        /// </summary>
        public SurfaceTransformFlagsKhr PreTransform
        {
            get { return M->PreTransform; }
            set { M->PreTransform = value; }
        }

        /// <summary>
        /// The alpha blending mode used when compositing this surface with other surfaces in the window system
        /// </summary>
        public CompositeAlphaFlagsKhr CompositeAlpha
        {
            get { return M->CompositeAlpha; }
            set { M->CompositeAlpha = value; }
        }

        /// <summary>
        /// Which presentation mode to use for presents on this swap chain
        /// </summary>
        public PresentModeKhr PresentMode
        {
            get { return M->PresentMode; }
            set { M->PresentMode = value; }
        }

        /// <summary>
        /// Specifies whether presentable images may be affected by window clip regions
        /// </summary>
        public bool Clipped
        {
            get { return M->Clipped; }
            set { M->Clipped = value; }
        }

        /// <summary>
        /// Existing swap chain to replace, if any
        /// </summary>
        SwapchainKhr lOldSwapchain;
        public SwapchainKhr OldSwapchain
        {
            get { return lOldSwapchain; }
            set { lOldSwapchain = value; M->OldSwapchain = value != null ? (UInt64)value.M : default(UInt64); }
        }

        internal Interop.SwapchainCreateInfoKhr* M
        {
            get { return (Interop.SwapchainCreateInfoKhr*)native.Handle; }
        }

        public SwapchainCreateInfoKhr()
        {
            native = Interop.Structure.Allocate(typeof(Interop.SwapchainCreateInfoKhr));

            M->SType = StructureType.SwapchainCreateInfoKhr;
        }

        internal SwapchainCreateInfoKhr(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.SwapchainCreateInfoKhr;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refQueueFamilyIndices.Dispose();
            refQueueFamilyIndices = null;
        }
    }

    unsafe public partial class PresentInfoKhr : MarshalledObject
    {
        /// <summary>
        /// Number of semaphores to wait for before presenting
        /// </summary>
        public UInt32 WaitSemaphoreCount
        {
            get { return M->WaitSemaphoreCount; }
            set { M->WaitSemaphoreCount = value; }
        }

        /// <summary>
        /// Semaphores to wait for before presenting
        /// </summary>
        NativeReference refWaitSemaphores;
        public Semaphore[] WaitSemaphores
        {
            get
            {
                if (M->WaitSemaphoreCount == 0)
                    return null;
                var values = new Semaphore[M->WaitSemaphoreCount];
                unsafe
                {
                    UInt64* ptr = (UInt64*)M->WaitSemaphores;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = new Semaphore();
                        values[i].M = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->WaitSemaphoreCount = 0;
                    M->WaitSemaphores = IntPtr.Zero;
                    return;
                }
                M->WaitSemaphoreCount = (uint)value.Length;
                refWaitSemaphores = new NativeReference((int)(sizeof(UInt64) * value.Length));
                M->WaitSemaphores = refWaitSemaphores.Handle;
                unsafe
                {
                    UInt64* ptr = (UInt64*)M->WaitSemaphores;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i].M;
                    }
                }
            }
        }

        /// <summary>
        /// Number of swapchains to present in this call
        /// </summary>
        public UInt32 SwapchainCount
        {
            get { return M->SwapchainCount; }
            set { M->SwapchainCount = value; }
        }

        /// <summary>
        /// Swapchains to present an image from
        /// </summary>
        NativeReference refSwapchains;
        public SwapchainKhr[] Swapchains
        {
            get
            {
                if (M->SwapchainCount == 0)
                    return null;
                var values = new SwapchainKhr[M->SwapchainCount];
                unsafe
                {
                    UInt64* ptr = (UInt64*)M->Swapchains;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = new SwapchainKhr();
                        values[i].M = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->SwapchainCount = 0;
                    M->Swapchains = IntPtr.Zero;
                    return;
                }
                M->SwapchainCount = (uint)value.Length;
                refSwapchains = new NativeReference((int)(sizeof(UInt64) * value.Length));
                M->Swapchains = refSwapchains.Handle;
                unsafe
                {
                    UInt64* ptr = (UInt64*)M->Swapchains;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i].M;
                    }
                }
            }
        }

        /// <summary>
        /// Indices of which presentable images to present
        /// </summary>
        NativeReference refImageIndices;
        public UInt32[] ImageIndices
        {
            get
            {
                if (M->SwapchainCount == 0)
                    return null;
                var values = new UInt32[M->SwapchainCount];
                unsafe
                {
                    UInt32* ptr = (UInt32*)M->ImageIndices;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->SwapchainCount = 0;
                    M->ImageIndices = IntPtr.Zero;
                    return;
                }
                M->SwapchainCount = (uint)value.Length;
                refImageIndices = new NativeReference((int)(sizeof(UInt32) * value.Length));
                M->ImageIndices = refImageIndices.Handle;
                unsafe
                {
                    UInt32* ptr = (UInt32*)M->ImageIndices;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        /// <summary>
        /// Optional(i.e. if non-NULL) VkResult for each swapchain
        /// </summary>
        NativeReference refResults;
        public Result[] Results
        {
            get
            {
                if (M->SwapchainCount == 0)
                    return null;
                var values = new Result[M->SwapchainCount];
                unsafe
                {
                    Result* ptr = (Result*)M->Results;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->SwapchainCount = 0;
                    M->Results = IntPtr.Zero;
                    return;
                }
                M->SwapchainCount = (uint)value.Length;
                refResults = new NativeReference((int)(sizeof(Result) * value.Length));
                M->Results = refResults.Handle;
                unsafe
                {
                    Result* ptr = (Result*)M->Results;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        internal Interop.PresentInfoKhr* M
        {
            get { return (Interop.PresentInfoKhr*)native.Handle; }
        }

        public PresentInfoKhr()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PresentInfoKhr));

            M->SType = StructureType.PresentInfoKhr;
        }

        internal PresentInfoKhr(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PresentInfoKhr;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refWaitSemaphores.Dispose();
            refWaitSemaphores = null;
            refSwapchains.Dispose();
            refSwapchains = null;
            refImageIndices.Dispose();
            refImageIndices = null;
            refResults.Dispose();
            refResults = null;
        }
    }

    unsafe public partial class DebugReportCallbackCreateInfoExt : InstanceCreateInfo
    {
        /// <summary>
        /// Indicates which events call this callback
        /// </summary>
        public new DebugReportFlagsExt Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        /// <summary>
        /// Function pointer of a callback function
        /// </summary>
        public IntPtr PfnCallback
        {
            get { return M->PfnCallback; }
            set { M->PfnCallback = value; }
        }

        /// <summary>
        /// User data provided to callback function
        /// </summary>
        public IntPtr UserData
        {
            get { return M->UserData; }
            set { M->UserData = value; }
        }

        internal new Interop.DebugReportCallbackCreateInfoExt* M
        {
            get { return (Interop.DebugReportCallbackCreateInfoExt*)native.Handle; }
        }

        public DebugReportCallbackCreateInfoExt()
        {
            native = Interop.Structure.Allocate(typeof(Interop.DebugReportCallbackCreateInfoExt));

            M->SType = StructureType.DebugReportCallbackCreateInfoExt;
        }

        internal DebugReportCallbackCreateInfoExt(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.DebugReportCallbackCreateInfoExt;
        }
    }

    unsafe public partial class ValidationFlagsExt : InstanceCreateInfo
    {
        /// <summary>
        /// Number of validation checks to disable
        /// </summary>
        public UInt32 DisabledValidationCheckCount
        {
            get { return M->DisabledValidationCheckCount; }
            set { M->DisabledValidationCheckCount = value; }
        }

        /// <summary>
        /// Validation checks to disable
        /// </summary>
        NativeReference refDisabledValidationChecks;
        public ValidationCheckExt[] DisabledValidationChecks
        {
            get
            {
                if (M->DisabledValidationCheckCount == 0)
                    return null;
                var values = new ValidationCheckExt[M->DisabledValidationCheckCount];
                unsafe
                {
                    ValidationCheckExt* ptr = (ValidationCheckExt*)M->DisabledValidationChecks;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->DisabledValidationCheckCount = 0;
                    M->DisabledValidationChecks = IntPtr.Zero;
                    return;
                }
                M->DisabledValidationCheckCount = (uint)value.Length;
                refDisabledValidationChecks = new NativeReference((int)(sizeof(ValidationCheckExt) * value.Length));
                M->DisabledValidationChecks = refDisabledValidationChecks.Handle;
                unsafe
                {
                    ValidationCheckExt* ptr = (ValidationCheckExt*)M->DisabledValidationChecks;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        internal new Interop.ValidationFlagsExt* M
        {
            get { return (Interop.ValidationFlagsExt*)native.Handle; }
        }

        public ValidationFlagsExt()
        {
            native = Interop.Structure.Allocate(typeof(Interop.ValidationFlagsExt));

            M->SType = StructureType.ValidationFlagsExt;
        }

        internal ValidationFlagsExt(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.ValidationFlagsExt;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refDisabledValidationChecks.Dispose();
            refDisabledValidationChecks = null;
        }
    }

    unsafe public partial class PipelineRasterizationStateRasterizationOrderAmd : PipelineRasterizationStateCreateInfo
    {
        /// <summary>
        /// Rasterization order to use for the pipeline
        /// </summary>
        public RasterizationOrderAmd RasterizationOrder
        {
            get { return M->RasterizationOrder; }
            set { M->RasterizationOrder = value; }
        }

        internal new Interop.PipelineRasterizationStateRasterizationOrderAmd* M
        {
            get { return (Interop.PipelineRasterizationStateRasterizationOrderAmd*)native.Handle; }
        }

        public PipelineRasterizationStateRasterizationOrderAmd()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PipelineRasterizationStateRasterizationOrderAmd));

            M->SType = StructureType.PipelineRasterizationStateRasterizationOrderAmd;
        }

        internal PipelineRasterizationStateRasterizationOrderAmd(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PipelineRasterizationStateRasterizationOrderAmd;
        }
    }

    unsafe public partial class DebugMarkerObjectNameInfoExt : MarshalledObject
    {
        /// <summary>
        /// The type of the object
        /// </summary>
        public DebugReportObjectTypeExt ObjectType
        {
            get { return M->ObjectType; }
            set { M->ObjectType = value; }
        }

        /// <summary>
        /// The handle of the object, cast to uint64_t
        /// </summary>
        public UInt64 Object
        {
            get { return M->Object; }
            set { M->Object = value; }
        }

        /// <summary>
        /// Name to apply to the object
        /// </summary>
        public string ObjectName
        {
            get { return Marshal.PtrToStringAnsi(M->ObjectName); }
            set { M->ObjectName = Marshal.StringToHGlobalAnsi(value); }
        }

        internal Interop.DebugMarkerObjectNameInfoExt* M
        {
            get { return (Interop.DebugMarkerObjectNameInfoExt*)native.Handle; }
        }

        public DebugMarkerObjectNameInfoExt()
        {
            native = Interop.Structure.Allocate(typeof(Interop.DebugMarkerObjectNameInfoExt));

            M->SType = StructureType.DebugMarkerObjectNameInfoExt;
        }

        internal DebugMarkerObjectNameInfoExt(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.DebugMarkerObjectNameInfoExt;
        }
    }

    unsafe public partial class DebugMarkerObjectTagInfoExt : MarshalledObject
    {
        /// <summary>
        /// The type of the object
        /// </summary>
        public DebugReportObjectTypeExt ObjectType
        {
            get { return M->ObjectType; }
            set { M->ObjectType = value; }
        }

        /// <summary>
        /// The handle of the object, cast to uint64_t
        /// </summary>
        public UInt64 Object
        {
            get { return M->Object; }
            set { M->Object = value; }
        }

        /// <summary>
        /// The name of the tag to set on the object
        /// </summary>
        public UInt64 TagName
        {
            get { return M->TagName; }
            set { M->TagName = value; }
        }

        /// <summary>
        /// The length in bytes of the tag data
        /// </summary>
        public UIntPtr TagSize
        {
            get { return M->TagSize; }
            set { M->TagSize = value; }
        }

        /// <summary>
        /// Tag data to attach to the object
        /// </summary>
        public IntPtr Tag
        {
            get { return M->Tag; }
            set { M->Tag = value; }
        }

        internal Interop.DebugMarkerObjectTagInfoExt* M
        {
            get { return (Interop.DebugMarkerObjectTagInfoExt*)native.Handle; }
        }

        public DebugMarkerObjectTagInfoExt()
        {
            native = Interop.Structure.Allocate(typeof(Interop.DebugMarkerObjectTagInfoExt));

            M->SType = StructureType.DebugMarkerObjectTagInfoExt;
        }

        internal DebugMarkerObjectTagInfoExt(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.DebugMarkerObjectTagInfoExt;
        }
    }

    unsafe public partial class DebugMarkerMarkerInfoExt : MarshalledObject
    {
        /// <summary>
        /// Name of the debug marker
        /// </summary>
        public string MarkerName
        {
            get { return Marshal.PtrToStringAnsi(M->MarkerName); }
            set { M->MarkerName = Marshal.StringToHGlobalAnsi(value); }
        }

        /// <summary>
        /// Optional color for debug marker
        /// </summary>
        public float[] Color
        {
            get
            {
                var arr = new float[4];
                for (int i = 0; i < 4; i++)
                    arr[i] = M->Color[i];
                return arr;
            }
            set
            {
                if (value.Length > 4)
                    throw new Exception("array too long");
                for (int i = 0; i < value.Length; i++)
                    M->Color[i] = value[i];
                for (int i = value.Length; i < 4; i++)
                    M->Color[i] = 0;
            }
        }

        internal Interop.DebugMarkerMarkerInfoExt* M
        {
            get { return (Interop.DebugMarkerMarkerInfoExt*)native.Handle; }
        }

        public DebugMarkerMarkerInfoExt()
        {
            native = Interop.Structure.Allocate(typeof(Interop.DebugMarkerMarkerInfoExt));

            M->SType = StructureType.DebugMarkerMarkerInfoExt;
        }

        internal DebugMarkerMarkerInfoExt(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.DebugMarkerMarkerInfoExt;
        }
    }

    unsafe public partial class DedicatedAllocationImageCreateInfoNv : ImageCreateInfo
    {
        /// <summary>
        /// Whether this image uses a dedicated allocation
        /// </summary>
        public bool DedicatedAllocation
        {
            get { return M->DedicatedAllocation; }
            set { M->DedicatedAllocation = value; }
        }

        internal new Interop.DedicatedAllocationImageCreateInfoNv* M
        {
            get { return (Interop.DedicatedAllocationImageCreateInfoNv*)native.Handle; }
        }

        public DedicatedAllocationImageCreateInfoNv()
        {
            native = Interop.Structure.Allocate(typeof(Interop.DedicatedAllocationImageCreateInfoNv));

            M->SType = StructureType.DedicatedAllocationImageCreateInfoNv;
        }

        internal DedicatedAllocationImageCreateInfoNv(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.DedicatedAllocationImageCreateInfoNv;
        }
    }

    unsafe public partial class DedicatedAllocationBufferCreateInfoNv : BufferCreateInfo
    {
        /// <summary>
        /// Whether this buffer uses a dedicated allocation
        /// </summary>
        public bool DedicatedAllocation
        {
            get { return M->DedicatedAllocation; }
            set { M->DedicatedAllocation = value; }
        }

        internal new Interop.DedicatedAllocationBufferCreateInfoNv* M
        {
            get { return (Interop.DedicatedAllocationBufferCreateInfoNv*)native.Handle; }
        }

        public DedicatedAllocationBufferCreateInfoNv()
        {
            native = Interop.Structure.Allocate(typeof(Interop.DedicatedAllocationBufferCreateInfoNv));

            M->SType = StructureType.DedicatedAllocationBufferCreateInfoNv;
        }

        internal DedicatedAllocationBufferCreateInfoNv(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.DedicatedAllocationBufferCreateInfoNv;
        }
    }

    unsafe public partial class DedicatedAllocationMemoryAllocateInfoNv : MemoryAllocateInfo
    {
        /// <summary>
        /// Image that this allocation will be bound to
        /// </summary>
        Image lImage;
        public Image Image
        {
            get { return lImage; }
            set { lImage = value; M->Image = value != null ? (UInt64)value.M : default(UInt64); }
        }

        /// <summary>
        /// Buffer that this allocation will be bound to
        /// </summary>
        Buffer lBuffer;
        public Buffer Buffer
        {
            get { return lBuffer; }
            set { lBuffer = value; M->Buffer = value != null ? (UInt64)value.M : default(UInt64); }
        }

        internal new Interop.DedicatedAllocationMemoryAllocateInfoNv* M
        {
            get { return (Interop.DedicatedAllocationMemoryAllocateInfoNv*)native.Handle; }
        }

        public DedicatedAllocationMemoryAllocateInfoNv()
        {
            native = Interop.Structure.Allocate(typeof(Interop.DedicatedAllocationMemoryAllocateInfoNv));

            M->SType = StructureType.DedicatedAllocationMemoryAllocateInfoNv;
        }

        internal DedicatedAllocationMemoryAllocateInfoNv(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.DedicatedAllocationMemoryAllocateInfoNv;
        }
    }

    unsafe public partial struct ExternalImageFormatPropertiesNv
    {
        public ImageFormatProperties ImageFormatProperties;
        public ExternalMemoryFeatureFlagsNv ExternalMemoryFeatures;
        public ExternalMemoryHandleTypeFlagsNv ExportFromImportedHandleTypes;
        public ExternalMemoryHandleTypeFlagsNv CompatibleHandleTypes;
    }

    unsafe public partial class ExternalMemoryImageCreateInfoNv : ImageCreateInfo
    {
        public ExternalMemoryHandleTypeFlagsNv HandleTypes
        {
            get { return M->HandleTypes; }
            set { M->HandleTypes = value; }
        }

        internal new Interop.ExternalMemoryImageCreateInfoNv* M
        {
            get { return (Interop.ExternalMemoryImageCreateInfoNv*)native.Handle; }
        }

        public ExternalMemoryImageCreateInfoNv()
        {
            native = Interop.Structure.Allocate(typeof(Interop.ExternalMemoryImageCreateInfoNv));

            M->SType = StructureType.ExternalMemoryImageCreateInfoNv;
        }

        internal ExternalMemoryImageCreateInfoNv(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.ExternalMemoryImageCreateInfoNv;
        }
    }

    unsafe public partial class ExportMemoryAllocateInfoNv : MemoryAllocateInfo
    {
        public ExternalMemoryHandleTypeFlagsNv HandleTypes
        {
            get { return M->HandleTypes; }
            set { M->HandleTypes = value; }
        }

        internal new Interop.ExportMemoryAllocateInfoNv* M
        {
            get { return (Interop.ExportMemoryAllocateInfoNv*)native.Handle; }
        }

        public ExportMemoryAllocateInfoNv()
        {
            native = Interop.Structure.Allocate(typeof(Interop.ExportMemoryAllocateInfoNv));

            M->SType = StructureType.ExportMemoryAllocateInfoNv;
        }

        internal ExportMemoryAllocateInfoNv(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.ExportMemoryAllocateInfoNv;
        }
    }

    unsafe public partial class Win32KeyedMutexAcquireReleaseInfoNv : SubmitInfo
    {
        public UInt32 AcquireCount
        {
            get { return M->AcquireCount; }
            set { M->AcquireCount = value; }
        }

        NativeReference refAcquireSyncs;
        public DeviceMemory[] AcquireSyncs
        {
            get
            {
                if (M->AcquireCount == 0)
                    return null;
                var values = new DeviceMemory[M->AcquireCount];
                unsafe
                {
                    UInt64* ptr = (UInt64*)M->AcquireSyncs;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = new DeviceMemory();
                        values[i].M = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->AcquireCount = 0;
                    M->AcquireSyncs = IntPtr.Zero;
                    return;
                }
                M->AcquireCount = (uint)value.Length;
                refAcquireSyncs = new NativeReference((int)(sizeof(UInt64) * value.Length));
                M->AcquireSyncs = refAcquireSyncs.Handle;
                unsafe
                {
                    UInt64* ptr = (UInt64*)M->AcquireSyncs;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i].M;
                    }
                }
            }
        }

        NativeReference refAcquireKeys;
        public UInt64[] AcquireKeys
        {
            get
            {
                if (M->AcquireCount == 0)
                    return null;
                var values = new UInt64[M->AcquireCount];
                unsafe
                {
                    UInt64* ptr = (UInt64*)M->AcquireKeys;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->AcquireCount = 0;
                    M->AcquireKeys = IntPtr.Zero;
                    return;
                }
                M->AcquireCount = (uint)value.Length;
                refAcquireKeys = new NativeReference((int)(sizeof(UInt64) * value.Length));
                M->AcquireKeys = refAcquireKeys.Handle;
                unsafe
                {
                    UInt64* ptr = (UInt64*)M->AcquireKeys;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        NativeReference refAcquireTimeoutMilliseconds;
        public UInt32[] AcquireTimeoutMilliseconds
        {
            get
            {
                if (M->AcquireCount == 0)
                    return null;
                var values = new UInt32[M->AcquireCount];
                unsafe
                {
                    UInt32* ptr = (UInt32*)M->AcquireTimeoutMilliseconds;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->AcquireCount = 0;
                    M->AcquireTimeoutMilliseconds = IntPtr.Zero;
                    return;
                }
                M->AcquireCount = (uint)value.Length;
                refAcquireTimeoutMilliseconds = new NativeReference((int)(sizeof(UInt32) * value.Length));
                M->AcquireTimeoutMilliseconds = refAcquireTimeoutMilliseconds.Handle;
                unsafe
                {
                    UInt32* ptr = (UInt32*)M->AcquireTimeoutMilliseconds;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        public UInt32 ReleaseCount
        {
            get { return M->ReleaseCount; }
            set { M->ReleaseCount = value; }
        }

        NativeReference refReleaseSyncs;
        public DeviceMemory[] ReleaseSyncs
        {
            get
            {
                if (M->ReleaseCount == 0)
                    return null;
                var values = new DeviceMemory[M->ReleaseCount];
                unsafe
                {
                    UInt64* ptr = (UInt64*)M->ReleaseSyncs;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = new DeviceMemory();
                        values[i].M = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->ReleaseCount = 0;
                    M->ReleaseSyncs = IntPtr.Zero;
                    return;
                }
                M->ReleaseCount = (uint)value.Length;
                refReleaseSyncs = new NativeReference((int)(sizeof(UInt64) * value.Length));
                M->ReleaseSyncs = refReleaseSyncs.Handle;
                unsafe
                {
                    UInt64* ptr = (UInt64*)M->ReleaseSyncs;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i].M;
                    }
                }
            }
        }

        NativeReference refReleaseKeys;
        public UInt64[] ReleaseKeys
        {
            get
            {
                if (M->ReleaseCount == 0)
                    return null;
                var values = new UInt64[M->ReleaseCount];
                unsafe
                {
                    UInt64* ptr = (UInt64*)M->ReleaseKeys;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->ReleaseCount = 0;
                    M->ReleaseKeys = IntPtr.Zero;
                    return;
                }
                M->ReleaseCount = (uint)value.Length;
                refReleaseKeys = new NativeReference((int)(sizeof(UInt64) * value.Length));
                M->ReleaseKeys = refReleaseKeys.Handle;
                unsafe
                {
                    UInt64* ptr = (UInt64*)M->ReleaseKeys;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        internal new Interop.Win32KeyedMutexAcquireReleaseInfoNv* M
        {
            get { return (Interop.Win32KeyedMutexAcquireReleaseInfoNv*)native.Handle; }
        }

        public Win32KeyedMutexAcquireReleaseInfoNv()
        {
            native = Interop.Structure.Allocate(typeof(Interop.Win32KeyedMutexAcquireReleaseInfoNv));

            M->SType = StructureType.Win32KeyedMutexAcquireReleaseInfoNv;
        }

        internal Win32KeyedMutexAcquireReleaseInfoNv(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.Win32KeyedMutexAcquireReleaseInfoNv;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refAcquireSyncs.Dispose();
            refAcquireSyncs = null;
            refAcquireKeys.Dispose();
            refAcquireKeys = null;
            refAcquireTimeoutMilliseconds.Dispose();
            refAcquireTimeoutMilliseconds = null;
            refReleaseSyncs.Dispose();
            refReleaseSyncs = null;
            refReleaseKeys.Dispose();
            refReleaseKeys = null;
        }
    }

    unsafe public partial class DeviceGeneratedCommandsFeaturesNvx : MarshalledObject
    {
        public bool ComputeBindingPointSupport
        {
            get { return M->ComputeBindingPointSupport; }
            set { M->ComputeBindingPointSupport = value; }
        }

        internal Interop.DeviceGeneratedCommandsFeaturesNvx* M
        {
            get { return (Interop.DeviceGeneratedCommandsFeaturesNvx*)native.Handle; }
        }

        public DeviceGeneratedCommandsFeaturesNvx()
        {
            native = Interop.Structure.Allocate(typeof(Interop.DeviceGeneratedCommandsFeaturesNvx));

            M->SType = StructureType.DeviceGeneratedCommandsFeaturesNvx;
        }

        internal DeviceGeneratedCommandsFeaturesNvx(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.DeviceGeneratedCommandsFeaturesNvx;
        }
    }

    unsafe public partial class DeviceGeneratedCommandsLimitsNvx : MarshalledObject
    {
        public UInt32 MaxIndirectCommandsLayoutTokenCount
        {
            get { return M->MaxIndirectCommandsLayoutTokenCount; }
            set { M->MaxIndirectCommandsLayoutTokenCount = value; }
        }

        public UInt32 MaxObjectEntryCounts
        {
            get { return M->MaxObjectEntryCounts; }
            set { M->MaxObjectEntryCounts = value; }
        }

        public UInt32 MinSequenceCountBufferOffsetAlignment
        {
            get { return M->MinSequenceCountBufferOffsetAlignment; }
            set { M->MinSequenceCountBufferOffsetAlignment = value; }
        }

        public UInt32 MinSequenceIndexBufferOffsetAlignment
        {
            get { return M->MinSequenceIndexBufferOffsetAlignment; }
            set { M->MinSequenceIndexBufferOffsetAlignment = value; }
        }

        public UInt32 MinCommandsTokenBufferOffsetAlignment
        {
            get { return M->MinCommandsTokenBufferOffsetAlignment; }
            set { M->MinCommandsTokenBufferOffsetAlignment = value; }
        }

        internal Interop.DeviceGeneratedCommandsLimitsNvx* M
        {
            get { return (Interop.DeviceGeneratedCommandsLimitsNvx*)native.Handle; }
        }

        public DeviceGeneratedCommandsLimitsNvx()
        {
            native = Interop.Structure.Allocate(typeof(Interop.DeviceGeneratedCommandsLimitsNvx));

            M->SType = StructureType.DeviceGeneratedCommandsLimitsNvx;
        }

        internal DeviceGeneratedCommandsLimitsNvx(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.DeviceGeneratedCommandsLimitsNvx;
        }
    }

    unsafe public partial class IndirectCommandsTokenNvx : MarshalledObject
    {
        public IndirectCommandsTokenTypeNvx TokenType
        {
            get { return M->TokenType; }
            set { M->TokenType = value; }
        }

        /// <summary>
        /// buffer containing tableEntries and additional data for indirectCommands
        /// </summary>
        Buffer lBuffer;
        public Buffer Buffer
        {
            get { return lBuffer; }
            set { lBuffer = value; M->Buffer = value != null ? (UInt64)value.M : default(UInt64); }
        }

        /// <summary>
        /// offset from the base address of the buffer
        /// </summary>
        public DeviceSize Offset
        {
            get { return M->Offset; }
            set { M->Offset = value; }
        }

        internal Interop.IndirectCommandsTokenNvx* M
        {
            get { return (Interop.IndirectCommandsTokenNvx*)native.Handle; }
        }

        public IndirectCommandsTokenNvx()
        {
            native = Interop.Structure.Allocate(typeof(Interop.IndirectCommandsTokenNvx));

        }

        internal IndirectCommandsTokenNvx(NativePointer pointer)
        {
            native = pointer;

        }
    }

    unsafe public partial struct IndirectCommandsLayoutTokenNvx
    {
        public IndirectCommandsTokenTypeNvx TokenType;
        /// <summary>
        /// Binding unit for vertex attribute / descriptor set, offset for pushconstants
        /// </summary>
        public UInt32 BindingUnit;
        /// <summary>
        /// Number of variable dynamic values for descriptor set / push constants
        /// </summary>
        public UInt32 DynamicCount;
        /// <summary>
        /// Rate the which the array is advanced per element(must be power of 2, minimum 1)
        /// </summary>
        public UInt32 Divisor;
    }

    unsafe public partial class IndirectCommandsLayoutCreateInfoNvx : MarshalledObject
    {
        public PipelineBindPoint PipelineBindPoint
        {
            get { return M->PipelineBindPoint; }
            set { M->PipelineBindPoint = value; }
        }

        public IndirectCommandsLayoutUsageFlagsNvx Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        public UInt32 TokenCount
        {
            get { return M->TokenCount; }
            set { M->TokenCount = value; }
        }

        NativeReference refTokens;
        public IndirectCommandsLayoutTokenNvx[] Tokens
        {
            get
            {
                if (M->TokenCount == 0)
                    return null;
                var values = new IndirectCommandsLayoutTokenNvx[M->TokenCount];
                unsafe
                {
                    IndirectCommandsLayoutTokenNvx* ptr = (IndirectCommandsLayoutTokenNvx*)M->Tokens;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->TokenCount = 0;
                    M->Tokens = IntPtr.Zero;
                    return;
                }
                M->TokenCount = (uint)value.Length;
                refTokens = new NativeReference((int)(sizeof(IndirectCommandsLayoutTokenNvx) * value.Length));
                M->Tokens = refTokens.Handle;
                unsafe
                {
                    IndirectCommandsLayoutTokenNvx* ptr = (IndirectCommandsLayoutTokenNvx*)M->Tokens;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        internal Interop.IndirectCommandsLayoutCreateInfoNvx* M
        {
            get { return (Interop.IndirectCommandsLayoutCreateInfoNvx*)native.Handle; }
        }

        public IndirectCommandsLayoutCreateInfoNvx()
        {
            native = Interop.Structure.Allocate(typeof(Interop.IndirectCommandsLayoutCreateInfoNvx));

            M->SType = StructureType.IndirectCommandsLayoutCreateInfoNvx;
        }

        internal IndirectCommandsLayoutCreateInfoNvx(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.IndirectCommandsLayoutCreateInfoNvx;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refTokens.Dispose();
            refTokens = null;
        }
    }

    unsafe public partial class CmdProcessCommandsInfoNvx : MarshalledObject
    {
        ObjectTableNvx lObjectTable;
        public ObjectTableNvx ObjectTable
        {
            get { return lObjectTable; }
            set { lObjectTable = value; M->ObjectTable = value != null ? (UInt64)value.M : default(UInt64); }
        }

        IndirectCommandsLayoutNvx lIndirectCommandsLayout;
        public IndirectCommandsLayoutNvx IndirectCommandsLayout
        {
            get { return lIndirectCommandsLayout; }
            set { lIndirectCommandsLayout = value; M->IndirectCommandsLayout = value != null ? (UInt64)value.M : default(UInt64); }
        }

        public UInt32 IndirectCommandsTokenCount
        {
            get { return M->IndirectCommandsTokenCount; }
            set { M->IndirectCommandsTokenCount = value; }
        }

        NativeReference refIndirectCommandsTokens;
        public IndirectCommandsTokenNvx[] IndirectCommandsTokens
        {
            get
            {
                if (M->IndirectCommandsTokenCount == 0)
                    return null;
                var values = new IndirectCommandsTokenNvx[M->IndirectCommandsTokenCount];
                unsafe
                {
                    Interop.IndirectCommandsTokenNvx* ptr = (Interop.IndirectCommandsTokenNvx*)M->IndirectCommandsTokens;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = new IndirectCommandsTokenNvx();
                        *values[i].M = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->IndirectCommandsTokenCount = 0;
                    M->IndirectCommandsTokens = IntPtr.Zero;
                    return;
                }
                M->IndirectCommandsTokenCount = (uint)value.Length;
                refIndirectCommandsTokens = new NativeReference((int)(sizeof(Interop.IndirectCommandsTokenNvx) * value.Length));
                M->IndirectCommandsTokens = refIndirectCommandsTokens.Handle;
                unsafe
                {
                    Interop.IndirectCommandsTokenNvx* ptr = (Interop.IndirectCommandsTokenNvx*)M->IndirectCommandsTokens;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = *value[i].M;
                    }
                }
            }
        }

        public UInt32 MaxSequencesCount
        {
            get { return M->MaxSequencesCount; }
            set { M->MaxSequencesCount = value; }
        }

        CommandBuffer lTargetCommandBuffer;
        public CommandBuffer TargetCommandBuffer
        {
            get { return lTargetCommandBuffer; }
            set { lTargetCommandBuffer = value; M->TargetCommandBuffer = value != null ? (IntPtr)value.M : default(IntPtr); }
        }

        Buffer lSequencesCountBuffer;
        public Buffer SequencesCountBuffer
        {
            get { return lSequencesCountBuffer; }
            set { lSequencesCountBuffer = value; M->SequencesCountBuffer = value != null ? (UInt64)value.M : default(UInt64); }
        }

        public DeviceSize SequencesCountOffset
        {
            get { return M->SequencesCountOffset; }
            set { M->SequencesCountOffset = value; }
        }

        Buffer lSequencesIndexBuffer;
        public Buffer SequencesIndexBuffer
        {
            get { return lSequencesIndexBuffer; }
            set { lSequencesIndexBuffer = value; M->SequencesIndexBuffer = value != null ? (UInt64)value.M : default(UInt64); }
        }

        public DeviceSize SequencesIndexOffset
        {
            get { return M->SequencesIndexOffset; }
            set { M->SequencesIndexOffset = value; }
        }

        internal Interop.CmdProcessCommandsInfoNvx* M
        {
            get { return (Interop.CmdProcessCommandsInfoNvx*)native.Handle; }
        }

        public CmdProcessCommandsInfoNvx()
        {
            native = Interop.Structure.Allocate(typeof(Interop.CmdProcessCommandsInfoNvx));

            M->SType = StructureType.CmdProcessCommandsInfoNvx;
        }

        internal CmdProcessCommandsInfoNvx(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.CmdProcessCommandsInfoNvx;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refIndirectCommandsTokens.Dispose();
            refIndirectCommandsTokens = null;
        }
    }

    unsafe public partial class CmdReserveSpaceForCommandsInfoNvx : MarshalledObject
    {
        ObjectTableNvx lObjectTable;
        public ObjectTableNvx ObjectTable
        {
            get { return lObjectTable; }
            set { lObjectTable = value; M->ObjectTable = value != null ? (UInt64)value.M : default(UInt64); }
        }

        IndirectCommandsLayoutNvx lIndirectCommandsLayout;
        public IndirectCommandsLayoutNvx IndirectCommandsLayout
        {
            get { return lIndirectCommandsLayout; }
            set { lIndirectCommandsLayout = value; M->IndirectCommandsLayout = value != null ? (UInt64)value.M : default(UInt64); }
        }

        public UInt32 MaxSequencesCount
        {
            get { return M->MaxSequencesCount; }
            set { M->MaxSequencesCount = value; }
        }

        internal Interop.CmdReserveSpaceForCommandsInfoNvx* M
        {
            get { return (Interop.CmdReserveSpaceForCommandsInfoNvx*)native.Handle; }
        }

        public CmdReserveSpaceForCommandsInfoNvx()
        {
            native = Interop.Structure.Allocate(typeof(Interop.CmdReserveSpaceForCommandsInfoNvx));

            M->SType = StructureType.CmdReserveSpaceForCommandsInfoNvx;
        }

        internal CmdReserveSpaceForCommandsInfoNvx(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.CmdReserveSpaceForCommandsInfoNvx;
        }
    }

    unsafe public partial class ObjectTableCreateInfoNvx : MarshalledObject
    {
        public UInt32 ObjectCount
        {
            get { return M->ObjectCount; }
            set { M->ObjectCount = value; }
        }

        NativeReference refObjectEntryTypes;
        public ObjectEntryTypeNvx[] ObjectEntryTypes
        {
            get
            {
                if (M->ObjectCount == 0)
                    return null;
                var values = new ObjectEntryTypeNvx[M->ObjectCount];
                unsafe
                {
                    ObjectEntryTypeNvx* ptr = (ObjectEntryTypeNvx*)M->ObjectEntryTypes;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->ObjectCount = 0;
                    M->ObjectEntryTypes = IntPtr.Zero;
                    return;
                }
                M->ObjectCount = (uint)value.Length;
                refObjectEntryTypes = new NativeReference((int)(sizeof(ObjectEntryTypeNvx) * value.Length));
                M->ObjectEntryTypes = refObjectEntryTypes.Handle;
                unsafe
                {
                    ObjectEntryTypeNvx* ptr = (ObjectEntryTypeNvx*)M->ObjectEntryTypes;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        NativeReference refObjectEntryCounts;
        public UInt32[] ObjectEntryCounts
        {
            get
            {
                if (M->ObjectCount == 0)
                    return null;
                var values = new UInt32[M->ObjectCount];
                unsafe
                {
                    UInt32* ptr = (UInt32*)M->ObjectEntryCounts;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->ObjectCount = 0;
                    M->ObjectEntryCounts = IntPtr.Zero;
                    return;
                }
                M->ObjectCount = (uint)value.Length;
                refObjectEntryCounts = new NativeReference((int)(sizeof(UInt32) * value.Length));
                M->ObjectEntryCounts = refObjectEntryCounts.Handle;
                unsafe
                {
                    UInt32* ptr = (UInt32*)M->ObjectEntryCounts;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        NativeReference refObjectEntryUsageFlags;
        public ObjectEntryUsageFlagsNvx[] ObjectEntryUsageFlags
        {
            get
            {
                if (M->ObjectCount == 0)
                    return null;
                var values = new ObjectEntryUsageFlagsNvx[M->ObjectCount];
                unsafe
                {
                    ObjectEntryUsageFlagsNvx* ptr = (ObjectEntryUsageFlagsNvx*)M->ObjectEntryUsageFlags;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->ObjectCount = 0;
                    M->ObjectEntryUsageFlags = IntPtr.Zero;
                    return;
                }
                M->ObjectCount = (uint)value.Length;
                refObjectEntryUsageFlags = new NativeReference((int)(sizeof(ObjectEntryUsageFlagsNvx) * value.Length));
                M->ObjectEntryUsageFlags = refObjectEntryUsageFlags.Handle;
                unsafe
                {
                    ObjectEntryUsageFlagsNvx* ptr = (ObjectEntryUsageFlagsNvx*)M->ObjectEntryUsageFlags;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        public UInt32 MaxUniformBuffersPerDescriptor
        {
            get { return M->MaxUniformBuffersPerDescriptor; }
            set { M->MaxUniformBuffersPerDescriptor = value; }
        }

        public UInt32 MaxStorageBuffersPerDescriptor
        {
            get { return M->MaxStorageBuffersPerDescriptor; }
            set { M->MaxStorageBuffersPerDescriptor = value; }
        }

        public UInt32 MaxStorageImagesPerDescriptor
        {
            get { return M->MaxStorageImagesPerDescriptor; }
            set { M->MaxStorageImagesPerDescriptor = value; }
        }

        public UInt32 MaxSampledImagesPerDescriptor
        {
            get { return M->MaxSampledImagesPerDescriptor; }
            set { M->MaxSampledImagesPerDescriptor = value; }
        }

        public UInt32 MaxPipelineLayouts
        {
            get { return M->MaxPipelineLayouts; }
            set { M->MaxPipelineLayouts = value; }
        }

        internal Interop.ObjectTableCreateInfoNvx* M
        {
            get { return (Interop.ObjectTableCreateInfoNvx*)native.Handle; }
        }

        public ObjectTableCreateInfoNvx()
        {
            native = Interop.Structure.Allocate(typeof(Interop.ObjectTableCreateInfoNvx));

            M->SType = StructureType.ObjectTableCreateInfoNvx;
        }

        internal ObjectTableCreateInfoNvx(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.ObjectTableCreateInfoNvx;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refObjectEntryTypes.Dispose();
            refObjectEntryTypes = null;
            refObjectEntryCounts.Dispose();
            refObjectEntryCounts = null;
            refObjectEntryUsageFlags.Dispose();
            refObjectEntryUsageFlags = null;
        }
    }

    unsafe public partial struct ObjectTableEntryNvx
    {
        public ObjectEntryTypeNvx Type;
        public ObjectEntryUsageFlagsNvx Flags;
    }

    unsafe public partial class ObjectTablePipelineEntryNvx : MarshalledObject
    {
        public ObjectEntryTypeNvx Type
        {
            get { return M->Type; }
            set { M->Type = value; }
        }

        public ObjectEntryUsageFlagsNvx Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        Pipeline lPipeline;
        public Pipeline Pipeline
        {
            get { return lPipeline; }
            set { lPipeline = value; M->Pipeline = value != null ? (UInt64)value.M : default(UInt64); }
        }

        internal Interop.ObjectTablePipelineEntryNvx* M
        {
            get { return (Interop.ObjectTablePipelineEntryNvx*)native.Handle; }
        }

        public ObjectTablePipelineEntryNvx()
        {
            native = Interop.Structure.Allocate(typeof(Interop.ObjectTablePipelineEntryNvx));

        }

        internal ObjectTablePipelineEntryNvx(NativePointer pointer)
        {
            native = pointer;

        }
    }

    unsafe public partial class ObjectTableDescriptorSetEntryNvx : MarshalledObject
    {
        public ObjectEntryTypeNvx Type
        {
            get { return M->Type; }
            set { M->Type = value; }
        }

        public ObjectEntryUsageFlagsNvx Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        PipelineLayout lPipelineLayout;
        public PipelineLayout PipelineLayout
        {
            get { return lPipelineLayout; }
            set { lPipelineLayout = value; M->PipelineLayout = value != null ? (UInt64)value.M : default(UInt64); }
        }

        DescriptorSet lDescriptorSet;
        public DescriptorSet DescriptorSet
        {
            get { return lDescriptorSet; }
            set { lDescriptorSet = value; M->DescriptorSet = value != null ? (UInt64)value.M : default(UInt64); }
        }

        internal Interop.ObjectTableDescriptorSetEntryNvx* M
        {
            get { return (Interop.ObjectTableDescriptorSetEntryNvx*)native.Handle; }
        }

        public ObjectTableDescriptorSetEntryNvx()
        {
            native = Interop.Structure.Allocate(typeof(Interop.ObjectTableDescriptorSetEntryNvx));

        }

        internal ObjectTableDescriptorSetEntryNvx(NativePointer pointer)
        {
            native = pointer;

        }
    }

    unsafe public partial class ObjectTableVertexBufferEntryNvx : MarshalledObject
    {
        public ObjectEntryTypeNvx Type
        {
            get { return M->Type; }
            set { M->Type = value; }
        }

        public ObjectEntryUsageFlagsNvx Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        Buffer lBuffer;
        public Buffer Buffer
        {
            get { return lBuffer; }
            set { lBuffer = value; M->Buffer = value != null ? (UInt64)value.M : default(UInt64); }
        }

        internal Interop.ObjectTableVertexBufferEntryNvx* M
        {
            get { return (Interop.ObjectTableVertexBufferEntryNvx*)native.Handle; }
        }

        public ObjectTableVertexBufferEntryNvx()
        {
            native = Interop.Structure.Allocate(typeof(Interop.ObjectTableVertexBufferEntryNvx));

        }

        internal ObjectTableVertexBufferEntryNvx(NativePointer pointer)
        {
            native = pointer;

        }
    }

    unsafe public partial class ObjectTableIndexBufferEntryNvx : MarshalledObject
    {
        public ObjectEntryTypeNvx Type
        {
            get { return M->Type; }
            set { M->Type = value; }
        }

        public ObjectEntryUsageFlagsNvx Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        Buffer lBuffer;
        public Buffer Buffer
        {
            get { return lBuffer; }
            set { lBuffer = value; M->Buffer = value != null ? (UInt64)value.M : default(UInt64); }
        }

        public IndexType IndexType
        {
            get { return M->IndexType; }
            set { M->IndexType = value; }
        }

        internal Interop.ObjectTableIndexBufferEntryNvx* M
        {
            get { return (Interop.ObjectTableIndexBufferEntryNvx*)native.Handle; }
        }

        public ObjectTableIndexBufferEntryNvx()
        {
            native = Interop.Structure.Allocate(typeof(Interop.ObjectTableIndexBufferEntryNvx));

        }

        internal ObjectTableIndexBufferEntryNvx(NativePointer pointer)
        {
            native = pointer;

        }
    }

    unsafe public partial class ObjectTablePushConstantEntryNvx : MarshalledObject
    {
        public ObjectEntryTypeNvx Type
        {
            get { return M->Type; }
            set { M->Type = value; }
        }

        public ObjectEntryUsageFlagsNvx Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        PipelineLayout lPipelineLayout;
        public PipelineLayout PipelineLayout
        {
            get { return lPipelineLayout; }
            set { lPipelineLayout = value; M->PipelineLayout = value != null ? (UInt64)value.M : default(UInt64); }
        }

        public ShaderStageFlags StageFlags
        {
            get { return M->StageFlags; }
            set { M->StageFlags = value; }
        }

        internal Interop.ObjectTablePushConstantEntryNvx* M
        {
            get { return (Interop.ObjectTablePushConstantEntryNvx*)native.Handle; }
        }

        public ObjectTablePushConstantEntryNvx()
        {
            native = Interop.Structure.Allocate(typeof(Interop.ObjectTablePushConstantEntryNvx));

        }

        internal ObjectTablePushConstantEntryNvx(NativePointer pointer)
        {
            native = pointer;

        }
    }

    unsafe public partial class PhysicalDeviceFeatures2 : DeviceCreateInfo
    {
        public PhysicalDeviceFeatures Features
        {
            get { return M->Features; }
            set { M->Features = value; }
        }

        internal new Interop.PhysicalDeviceFeatures2* M
        {
            get { return (Interop.PhysicalDeviceFeatures2*)native.Handle; }
        }

        public PhysicalDeviceFeatures2()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PhysicalDeviceFeatures2));

            M->SType = StructureType.PhysicalDeviceFeatures2;
        }

        internal PhysicalDeviceFeatures2(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PhysicalDeviceFeatures2;
        }
    }

    unsafe public partial class PhysicalDeviceProperties2 : MarshalledObject
    {
        PhysicalDeviceProperties lProperties;
        public PhysicalDeviceProperties Properties
        {
            get { return lProperties; }
            set { lProperties = value; M->Properties = value != null ? *value.M : default(Interop.PhysicalDeviceProperties); }
        }

        internal Interop.PhysicalDeviceProperties2* M
        {
            get { return (Interop.PhysicalDeviceProperties2*)native.Handle; }
        }

        public PhysicalDeviceProperties2()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PhysicalDeviceProperties2));

            M->SType = StructureType.PhysicalDeviceProperties2;
            lProperties = new PhysicalDeviceProperties(new NativePointer(native.Reference, (IntPtr)(&M->Properties)));
        }

        internal PhysicalDeviceProperties2(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PhysicalDeviceProperties2;
            lProperties = new PhysicalDeviceProperties(new NativePointer(native.Reference, (IntPtr)(&M->Properties)));
        }
    }

    unsafe public partial class FormatProperties2 : MarshalledObject
    {
        public FormatProperties FormatProperties
        {
            get { return M->FormatProperties; }
            set { M->FormatProperties = value; }
        }

        internal Interop.FormatProperties2* M
        {
            get { return (Interop.FormatProperties2*)native.Handle; }
        }

        public FormatProperties2()
        {
            native = Interop.Structure.Allocate(typeof(Interop.FormatProperties2));

            M->SType = StructureType.FormatProperties2;
        }

        internal FormatProperties2(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.FormatProperties2;
        }
    }

    unsafe public partial class ImageFormatProperties2 : MarshalledObject
    {
        public ImageFormatProperties ImageFormatProperties
        {
            get { return M->ImageFormatProperties; }
            set { M->ImageFormatProperties = value; }
        }

        internal Interop.ImageFormatProperties2* M
        {
            get { return (Interop.ImageFormatProperties2*)native.Handle; }
        }

        public ImageFormatProperties2()
        {
            native = Interop.Structure.Allocate(typeof(Interop.ImageFormatProperties2));

            M->SType = StructureType.ImageFormatProperties2;
        }

        internal ImageFormatProperties2(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.ImageFormatProperties2;
        }
    }

    unsafe public partial class PhysicalDeviceImageFormatInfo2 : MarshalledObject
    {
        public Format Format
        {
            get { return M->Format; }
            set { M->Format = value; }
        }

        public ImageType Type
        {
            get { return M->Type; }
            set { M->Type = value; }
        }

        public ImageTiling Tiling
        {
            get { return M->Tiling; }
            set { M->Tiling = value; }
        }

        public ImageUsageFlags Usage
        {
            get { return M->Usage; }
            set { M->Usage = value; }
        }

        public ImageCreateFlags Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        internal Interop.PhysicalDeviceImageFormatInfo2* M
        {
            get { return (Interop.PhysicalDeviceImageFormatInfo2*)native.Handle; }
        }

        public PhysicalDeviceImageFormatInfo2()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PhysicalDeviceImageFormatInfo2));

            M->SType = StructureType.PhysicalDeviceImageFormatInfo2;
        }

        internal PhysicalDeviceImageFormatInfo2(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PhysicalDeviceImageFormatInfo2;
        }
    }

    unsafe public partial class QueueFamilyProperties2 : MarshalledObject
    {
        public QueueFamilyProperties QueueFamilyProperties
        {
            get { return M->QueueFamilyProperties; }
            set { M->QueueFamilyProperties = value; }
        }

        internal Interop.QueueFamilyProperties2* M
        {
            get { return (Interop.QueueFamilyProperties2*)native.Handle; }
        }

        public QueueFamilyProperties2()
        {
            native = Interop.Structure.Allocate(typeof(Interop.QueueFamilyProperties2));

            M->SType = StructureType.QueueFamilyProperties2;
        }

        internal QueueFamilyProperties2(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.QueueFamilyProperties2;
        }
    }

    unsafe public partial class PhysicalDeviceMemoryProperties2 : MarshalledObject
    {
        PhysicalDeviceMemoryProperties lMemoryProperties;
        public PhysicalDeviceMemoryProperties MemoryProperties
        {
            get { return lMemoryProperties; }
            set { lMemoryProperties = value; M->MemoryProperties = value != null ? *value.M : default(Interop.PhysicalDeviceMemoryProperties); }
        }

        internal Interop.PhysicalDeviceMemoryProperties2* M
        {
            get { return (Interop.PhysicalDeviceMemoryProperties2*)native.Handle; }
        }

        public PhysicalDeviceMemoryProperties2()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PhysicalDeviceMemoryProperties2));

            M->SType = StructureType.PhysicalDeviceMemoryProperties2;
            lMemoryProperties = new PhysicalDeviceMemoryProperties(new NativePointer(native.Reference, (IntPtr)(&M->MemoryProperties)));
        }

        internal PhysicalDeviceMemoryProperties2(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PhysicalDeviceMemoryProperties2;
            lMemoryProperties = new PhysicalDeviceMemoryProperties(new NativePointer(native.Reference, (IntPtr)(&M->MemoryProperties)));
        }
    }

    unsafe public partial class SparseImageFormatProperties2 : MarshalledObject
    {
        public SparseImageFormatProperties Properties
        {
            get { return M->Properties; }
            set { M->Properties = value; }
        }

        internal Interop.SparseImageFormatProperties2* M
        {
            get { return (Interop.SparseImageFormatProperties2*)native.Handle; }
        }

        public SparseImageFormatProperties2()
        {
            native = Interop.Structure.Allocate(typeof(Interop.SparseImageFormatProperties2));

            M->SType = StructureType.SparseImageFormatProperties2;
        }

        internal SparseImageFormatProperties2(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.SparseImageFormatProperties2;
        }
    }

    unsafe public partial class PhysicalDeviceSparseImageFormatInfo2 : MarshalledObject
    {
        public Format Format
        {
            get { return M->Format; }
            set { M->Format = value; }
        }

        public ImageType Type
        {
            get { return M->Type; }
            set { M->Type = value; }
        }

        public SampleCountFlags Samples
        {
            get { return M->Samples; }
            set { M->Samples = value; }
        }

        public ImageUsageFlags Usage
        {
            get { return M->Usage; }
            set { M->Usage = value; }
        }

        public ImageTiling Tiling
        {
            get { return M->Tiling; }
            set { M->Tiling = value; }
        }

        internal Interop.PhysicalDeviceSparseImageFormatInfo2* M
        {
            get { return (Interop.PhysicalDeviceSparseImageFormatInfo2*)native.Handle; }
        }

        public PhysicalDeviceSparseImageFormatInfo2()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PhysicalDeviceSparseImageFormatInfo2));

            M->SType = StructureType.PhysicalDeviceSparseImageFormatInfo2;
        }

        internal PhysicalDeviceSparseImageFormatInfo2(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PhysicalDeviceSparseImageFormatInfo2;
        }
    }

    unsafe public partial class PhysicalDevicePushDescriptorPropertiesKhr : PhysicalDeviceProperties2
    {
        public UInt32 MaxPushDescriptors
        {
            get { return M->MaxPushDescriptors; }
            set { M->MaxPushDescriptors = value; }
        }

        internal new Interop.PhysicalDevicePushDescriptorPropertiesKhr* M
        {
            get { return (Interop.PhysicalDevicePushDescriptorPropertiesKhr*)native.Handle; }
        }

        public PhysicalDevicePushDescriptorPropertiesKhr()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PhysicalDevicePushDescriptorPropertiesKhr));

            M->SType = StructureType.PhysicalDevicePushDescriptorPropertiesKhr;
        }

        internal PhysicalDevicePushDescriptorPropertiesKhr(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PhysicalDevicePushDescriptorPropertiesKhr;
        }
    }

    unsafe public partial struct ConformanceVersionKhr
    {
        public byte Major;
        public byte Minor;
        public byte Subminor;
        public byte Patch;
    }

    unsafe public partial class PhysicalDeviceDriverPropertiesKhr : PhysicalDeviceProperties2
    {
        public UInt32 DriverId
        {
            get { return M->DriverId; }
            set { M->DriverId = value; }
        }

        public string DriverName
        {
            get { return Marshal.PtrToStringAnsi((IntPtr)M->DriverName); }
            set { Interop.Structure.MarshalFixedSizeString(M->DriverName, value, 256); }
        }

        public string DriverInfo
        {
            get { return Marshal.PtrToStringAnsi((IntPtr)M->DriverInfo); }
            set { Interop.Structure.MarshalFixedSizeString(M->DriverInfo, value, 256); }
        }

        public ConformanceVersionKhr ConformanceVersion
        {
            get { return M->ConformanceVersion; }
            set { M->ConformanceVersion = value; }
        }

        internal new Interop.PhysicalDeviceDriverPropertiesKhr* M
        {
            get { return (Interop.PhysicalDeviceDriverPropertiesKhr*)native.Handle; }
        }

        public PhysicalDeviceDriverPropertiesKhr()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PhysicalDeviceDriverPropertiesKhr));

            M->SType = StructureType.PhysicalDeviceDriverPropertiesKhr;
        }

        internal PhysicalDeviceDriverPropertiesKhr(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PhysicalDeviceDriverPropertiesKhr;
        }
    }

    unsafe public partial class PresentRegionsKhr : PresentInfoKhr
    {
        /// <summary>
        /// Copy of VkPresentInfoKHR::swapchainCount
        /// </summary>
        public new UInt32 SwapchainCount
        {
            get { return M->SwapchainCount; }
            set { M->SwapchainCount = value; }
        }

        /// <summary>
        /// The regions that have changed
        /// </summary>
        NativeReference refRegions;
        public PresentRegionKhr[] Regions
        {
            get
            {
                if (M->SwapchainCount == 0)
                    return null;
                var values = new PresentRegionKhr[M->SwapchainCount];
                unsafe
                {
                    Interop.PresentRegionKhr* ptr = (Interop.PresentRegionKhr*)M->Regions;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = new PresentRegionKhr();
                        *values[i].M = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->SwapchainCount = 0;
                    M->Regions = IntPtr.Zero;
                    return;
                }
                M->SwapchainCount = (uint)value.Length;
                refRegions = new NativeReference((int)(sizeof(Interop.PresentRegionKhr) * value.Length));
                M->Regions = refRegions.Handle;
                unsafe
                {
                    Interop.PresentRegionKhr* ptr = (Interop.PresentRegionKhr*)M->Regions;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = *value[i].M;
                    }
                }
            }
        }

        internal new Interop.PresentRegionsKhr* M
        {
            get { return (Interop.PresentRegionsKhr*)native.Handle; }
        }

        public PresentRegionsKhr()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PresentRegionsKhr));

            M->SType = StructureType.PresentRegionsKhr;
        }

        internal PresentRegionsKhr(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PresentRegionsKhr;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refRegions.Dispose();
            refRegions = null;
        }
    }

    unsafe public partial class PresentRegionKhr : MarshalledObject
    {
        /// <summary>
        /// Number of rectangles in pRectangles
        /// </summary>
        public UInt32 RectangleCount
        {
            get { return M->RectangleCount; }
            set { M->RectangleCount = value; }
        }

        /// <summary>
        /// Array of rectangles that have changed in a swapchain's image(s)
        /// </summary>
        NativeReference refRectangles;
        public RectLayerKhr[] Rectangles
        {
            get
            {
                if (M->RectangleCount == 0)
                    return null;
                var values = new RectLayerKhr[M->RectangleCount];
                unsafe
                {
                    RectLayerKhr* ptr = (RectLayerKhr*)M->Rectangles;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->RectangleCount = 0;
                    M->Rectangles = IntPtr.Zero;
                    return;
                }
                M->RectangleCount = (uint)value.Length;
                refRectangles = new NativeReference((int)(sizeof(RectLayerKhr) * value.Length));
                M->Rectangles = refRectangles.Handle;
                unsafe
                {
                    RectLayerKhr* ptr = (RectLayerKhr*)M->Rectangles;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        internal Interop.PresentRegionKhr* M
        {
            get { return (Interop.PresentRegionKhr*)native.Handle; }
        }

        public PresentRegionKhr()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PresentRegionKhr));
        }

        internal PresentRegionKhr(NativePointer pointer)
        {
            native = pointer;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refRectangles.Dispose();
            refRectangles = null;
        }
    }

    unsafe public partial struct RectLayerKhr
    {
        /// <summary>
        /// upper-left corner of a rectangle that has not changed, in pixels of a presentation images
        /// </summary>
        public Offset2D Offset;
        /// <summary>
        /// Dimensions of a rectangle that has not changed, in pixels of a presentation images
        /// </summary>
        public Extent2D Extent;
        /// <summary>
        /// Layer of a swapchain's image(s), for stereoscopic-3D images
        /// </summary>
        public UInt32 Layer;
    }

    unsafe public partial class PhysicalDeviceVariablePointerFeatures : PhysicalDeviceFeatures2
    {
        public bool VariablePointersStorageBuffer
        {
            get { return M->VariablePointersStorageBuffer; }
            set { M->VariablePointersStorageBuffer = value; }
        }

        public bool VariablePointers
        {
            get { return M->VariablePointers; }
            set { M->VariablePointers = value; }
        }

        internal new Interop.PhysicalDeviceVariablePointerFeatures* M
        {
            get { return (Interop.PhysicalDeviceVariablePointerFeatures*)native.Handle; }
        }

        public PhysicalDeviceVariablePointerFeatures()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PhysicalDeviceVariablePointerFeatures));

            M->SType = StructureType.PhysicalDeviceVariablePointerFeatures;
        }

        internal PhysicalDeviceVariablePointerFeatures(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PhysicalDeviceVariablePointerFeatures;
        }
    }

    unsafe public partial struct ExternalMemoryProperties
    {
        public ExternalMemoryFeatureFlags ExternalMemoryFeatures;
        public ExternalMemoryHandleTypeFlags ExportFromImportedHandleTypes;
        public ExternalMemoryHandleTypeFlags CompatibleHandleTypes;
    }

    unsafe public partial class PhysicalDeviceExternalImageFormatInfo : PhysicalDeviceImageFormatInfo2
    {
        public ExternalMemoryHandleTypeFlags HandleType
        {
            get { return M->HandleType; }
            set { M->HandleType = value; }
        }

        internal new Interop.PhysicalDeviceExternalImageFormatInfo* M
        {
            get { return (Interop.PhysicalDeviceExternalImageFormatInfo*)native.Handle; }
        }

        public PhysicalDeviceExternalImageFormatInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PhysicalDeviceExternalImageFormatInfo));

            M->SType = StructureType.PhysicalDeviceExternalImageFormatInfo;
        }

        internal PhysicalDeviceExternalImageFormatInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PhysicalDeviceExternalImageFormatInfo;
        }
    }

    unsafe public partial class ExternalImageFormatProperties : ImageFormatProperties2
    {
        public ExternalMemoryProperties ExternalMemoryProperties
        {
            get { return M->ExternalMemoryProperties; }
            set { M->ExternalMemoryProperties = value; }
        }

        internal new Interop.ExternalImageFormatProperties* M
        {
            get { return (Interop.ExternalImageFormatProperties*)native.Handle; }
        }

        public ExternalImageFormatProperties()
        {
            native = Interop.Structure.Allocate(typeof(Interop.ExternalImageFormatProperties));

            M->SType = StructureType.ExternalImageFormatProperties;
        }

        internal ExternalImageFormatProperties(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.ExternalImageFormatProperties;
        }
    }

    unsafe public partial class PhysicalDeviceExternalBufferInfo : MarshalledObject
    {
        public BufferCreateFlags Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        public BufferUsageFlags Usage
        {
            get { return M->Usage; }
            set { M->Usage = value; }
        }

        public ExternalMemoryHandleTypeFlags HandleType
        {
            get { return M->HandleType; }
            set { M->HandleType = value; }
        }

        internal Interop.PhysicalDeviceExternalBufferInfo* M
        {
            get { return (Interop.PhysicalDeviceExternalBufferInfo*)native.Handle; }
        }

        public PhysicalDeviceExternalBufferInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PhysicalDeviceExternalBufferInfo));

            M->SType = StructureType.PhysicalDeviceExternalBufferInfo;
        }

        internal PhysicalDeviceExternalBufferInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PhysicalDeviceExternalBufferInfo;
        }
    }

    unsafe public partial class ExternalBufferProperties : MarshalledObject
    {
        public ExternalMemoryProperties ExternalMemoryProperties
        {
            get { return M->ExternalMemoryProperties; }
            set { M->ExternalMemoryProperties = value; }
        }

        internal Interop.ExternalBufferProperties* M
        {
            get { return (Interop.ExternalBufferProperties*)native.Handle; }
        }

        public ExternalBufferProperties()
        {
            native = Interop.Structure.Allocate(typeof(Interop.ExternalBufferProperties));

            M->SType = StructureType.ExternalBufferProperties;
        }

        internal ExternalBufferProperties(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.ExternalBufferProperties;
        }
    }

    unsafe public partial class PhysicalDeviceIDProperties : PhysicalDeviceProperties2
    {
        public byte[] DeviceUuid
        {
            get
            {
                var arr = new byte[16];
                for (int i = 0; i < 16; i++)
                    arr[i] = M->DeviceUuid[i];
                return arr;
            }
            set
            {
                if (value.Length > 16)
                    throw new Exception("array too long");
                for (int i = 0; i < value.Length; i++)
                    M->DeviceUuid[i] = value[i];
                for (int i = value.Length; i < 16; i++)
                    M->DeviceUuid[i] = 0;
            }
        }

        public byte[] DriverUuid
        {
            get
            {
                var arr = new byte[16];
                for (int i = 0; i < 16; i++)
                    arr[i] = M->DriverUuid[i];
                return arr;
            }
            set
            {
                if (value.Length > 16)
                    throw new Exception("array too long");
                for (int i = 0; i < value.Length; i++)
                    M->DriverUuid[i] = value[i];
                for (int i = value.Length; i < 16; i++)
                    M->DriverUuid[i] = 0;
            }
        }

        public byte[] DeviceLuid
        {
            get
            {
                var arr = new byte[8];
                for (int i = 0; i < 8; i++)
                    arr[i] = M->DeviceLuid[i];
                return arr;
            }
            set
            {
                if (value.Length > 8)
                    throw new Exception("array too long");
                for (int i = 0; i < value.Length; i++)
                    M->DeviceLuid[i] = value[i];
                for (int i = value.Length; i < 8; i++)
                    M->DeviceLuid[i] = 0;
            }
        }

        public UInt32 DeviceNodeMask
        {
            get { return M->DeviceNodeMask; }
            set { M->DeviceNodeMask = value; }
        }

        public bool DeviceLuidvalid
        {
            get { return M->DeviceLuidvalid; }
            set { M->DeviceLuidvalid = value; }
        }

        internal new Interop.PhysicalDeviceIDProperties* M
        {
            get { return (Interop.PhysicalDeviceIDProperties*)native.Handle; }
        }

        public PhysicalDeviceIDProperties()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PhysicalDeviceIDProperties));

            M->SType = StructureType.PhysicalDeviceIDProperties;
        }

        internal PhysicalDeviceIDProperties(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PhysicalDeviceIDProperties;
        }
    }

    unsafe public partial class ExternalMemoryImageCreateInfo : ImageCreateInfo
    {
        public ExternalMemoryHandleTypeFlags HandleTypes
        {
            get { return M->HandleTypes; }
            set { M->HandleTypes = value; }
        }

        internal new Interop.ExternalMemoryImageCreateInfo* M
        {
            get { return (Interop.ExternalMemoryImageCreateInfo*)native.Handle; }
        }

        public ExternalMemoryImageCreateInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.ExternalMemoryImageCreateInfo));

            M->SType = StructureType.ExternalMemoryImageCreateInfo;
        }

        internal ExternalMemoryImageCreateInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.ExternalMemoryImageCreateInfo;
        }
    }

    unsafe public partial class ExternalMemoryBufferCreateInfo : BufferCreateInfo
    {
        public ExternalMemoryHandleTypeFlags HandleTypes
        {
            get { return M->HandleTypes; }
            set { M->HandleTypes = value; }
        }

        internal new Interop.ExternalMemoryBufferCreateInfo* M
        {
            get { return (Interop.ExternalMemoryBufferCreateInfo*)native.Handle; }
        }

        public ExternalMemoryBufferCreateInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.ExternalMemoryBufferCreateInfo));

            M->SType = StructureType.ExternalMemoryBufferCreateInfo;
        }

        internal ExternalMemoryBufferCreateInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.ExternalMemoryBufferCreateInfo;
        }
    }

    unsafe public partial class ExportMemoryAllocateInfo : MemoryAllocateInfo
    {
        public ExternalMemoryHandleTypeFlags HandleTypes
        {
            get { return M->HandleTypes; }
            set { M->HandleTypes = value; }
        }

        internal new Interop.ExportMemoryAllocateInfo* M
        {
            get { return (Interop.ExportMemoryAllocateInfo*)native.Handle; }
        }

        public ExportMemoryAllocateInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.ExportMemoryAllocateInfo));

            M->SType = StructureType.ExportMemoryAllocateInfo;
        }

        internal ExportMemoryAllocateInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.ExportMemoryAllocateInfo;
        }
    }

    unsafe public partial class MemoryWin32HandlePropertiesKhr : MarshalledObject
    {
        public UInt32 MemoryTypeBits
        {
            get { return M->MemoryTypeBits; }
            set { M->MemoryTypeBits = value; }
        }

        internal Interop.MemoryWin32HandlePropertiesKhr* M
        {
            get { return (Interop.MemoryWin32HandlePropertiesKhr*)native.Handle; }
        }

        public MemoryWin32HandlePropertiesKhr()
        {
            native = Interop.Structure.Allocate(typeof(Interop.MemoryWin32HandlePropertiesKhr));

            M->SType = StructureType.MemoryWin32HandlePropertiesKhr;
        }

        internal MemoryWin32HandlePropertiesKhr(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.MemoryWin32HandlePropertiesKhr;
        }
    }

    unsafe public partial class MemoryGetWin32HandleInfoKhr : MarshalledObject
    {
        DeviceMemory lMemory;
        public DeviceMemory Memory
        {
            get { return lMemory; }
            set { lMemory = value; M->Memory = value != null ? (UInt64)value.M : default(UInt64); }
        }

        public ExternalMemoryHandleTypeFlags HandleType
        {
            get { return M->HandleType; }
            set { M->HandleType = value; }
        }

        internal Interop.MemoryGetWin32HandleInfoKhr* M
        {
            get { return (Interop.MemoryGetWin32HandleInfoKhr*)native.Handle; }
        }

        public MemoryGetWin32HandleInfoKhr()
        {
            native = Interop.Structure.Allocate(typeof(Interop.MemoryGetWin32HandleInfoKhr));

            M->SType = StructureType.MemoryGetWin32HandleInfoKhr;
        }

        internal MemoryGetWin32HandleInfoKhr(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.MemoryGetWin32HandleInfoKhr;
        }
    }

    unsafe public partial class ImportMemoryFdInfoKhr : MemoryAllocateInfo
    {
        public ExternalMemoryHandleTypeFlags HandleType
        {
            get { return M->HandleType; }
            set { M->HandleType = value; }
        }

        public int Fd
        {
            get { return M->Fd; }
            set { M->Fd = value; }
        }

        internal new Interop.ImportMemoryFdInfoKhr* M
        {
            get { return (Interop.ImportMemoryFdInfoKhr*)native.Handle; }
        }

        public ImportMemoryFdInfoKhr()
        {
            native = Interop.Structure.Allocate(typeof(Interop.ImportMemoryFdInfoKhr));

            M->SType = StructureType.ImportMemoryFdInfoKhr;
        }

        internal ImportMemoryFdInfoKhr(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.ImportMemoryFdInfoKhr;
        }
    }

    unsafe public partial class MemoryFdPropertiesKhr : MarshalledObject
    {
        public UInt32 MemoryTypeBits
        {
            get { return M->MemoryTypeBits; }
            set { M->MemoryTypeBits = value; }
        }

        internal Interop.MemoryFdPropertiesKhr* M
        {
            get { return (Interop.MemoryFdPropertiesKhr*)native.Handle; }
        }

        public MemoryFdPropertiesKhr()
        {
            native = Interop.Structure.Allocate(typeof(Interop.MemoryFdPropertiesKhr));

            M->SType = StructureType.MemoryFdPropertiesKhr;
        }

        internal MemoryFdPropertiesKhr(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.MemoryFdPropertiesKhr;
        }
    }

    unsafe public partial class MemoryGetFdInfoKhr : MarshalledObject
    {
        DeviceMemory lMemory;
        public DeviceMemory Memory
        {
            get { return lMemory; }
            set { lMemory = value; M->Memory = value != null ? (UInt64)value.M : default(UInt64); }
        }

        public ExternalMemoryHandleTypeFlags HandleType
        {
            get { return M->HandleType; }
            set { M->HandleType = value; }
        }

        internal Interop.MemoryGetFdInfoKhr* M
        {
            get { return (Interop.MemoryGetFdInfoKhr*)native.Handle; }
        }

        public MemoryGetFdInfoKhr()
        {
            native = Interop.Structure.Allocate(typeof(Interop.MemoryGetFdInfoKhr));

            M->SType = StructureType.MemoryGetFdInfoKhr;
        }

        internal MemoryGetFdInfoKhr(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.MemoryGetFdInfoKhr;
        }
    }

    unsafe public partial class Win32KeyedMutexAcquireReleaseInfoKhr : SubmitInfo
    {
        public UInt32 AcquireCount
        {
            get { return M->AcquireCount; }
            set { M->AcquireCount = value; }
        }

        NativeReference refAcquireSyncs;
        public DeviceMemory[] AcquireSyncs
        {
            get
            {
                if (M->AcquireCount == 0)
                    return null;
                var values = new DeviceMemory[M->AcquireCount];
                unsafe
                {
                    UInt64* ptr = (UInt64*)M->AcquireSyncs;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = new DeviceMemory();
                        values[i].M = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->AcquireCount = 0;
                    M->AcquireSyncs = IntPtr.Zero;
                    return;
                }
                M->AcquireCount = (uint)value.Length;
                refAcquireSyncs = new NativeReference((int)(sizeof(UInt64) * value.Length));
                M->AcquireSyncs = refAcquireSyncs.Handle;
                unsafe
                {
                    UInt64* ptr = (UInt64*)M->AcquireSyncs;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i].M;
                    }
                }
            }
        }

        NativeReference refAcquireKeys;
        public UInt64[] AcquireKeys
        {
            get
            {
                if (M->AcquireCount == 0)
                    return null;
                var values = new UInt64[M->AcquireCount];
                unsafe
                {
                    UInt64* ptr = (UInt64*)M->AcquireKeys;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->AcquireCount = 0;
                    M->AcquireKeys = IntPtr.Zero;
                    return;
                }
                M->AcquireCount = (uint)value.Length;
                refAcquireKeys = new NativeReference((int)(sizeof(UInt64) * value.Length));
                M->AcquireKeys = refAcquireKeys.Handle;
                unsafe
                {
                    UInt64* ptr = (UInt64*)M->AcquireKeys;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        NativeReference refAcquireTimeouts;
        public UInt32[] AcquireTimeouts
        {
            get
            {
                if (M->AcquireCount == 0)
                    return null;
                var values = new UInt32[M->AcquireCount];
                unsafe
                {
                    UInt32* ptr = (UInt32*)M->AcquireTimeouts;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->AcquireCount = 0;
                    M->AcquireTimeouts = IntPtr.Zero;
                    return;
                }
                M->AcquireCount = (uint)value.Length;
                refAcquireTimeouts = new NativeReference((int)(sizeof(UInt32) * value.Length));
                M->AcquireTimeouts = refAcquireTimeouts.Handle;
                unsafe
                {
                    UInt32* ptr = (UInt32*)M->AcquireTimeouts;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        public UInt32 ReleaseCount
        {
            get { return M->ReleaseCount; }
            set { M->ReleaseCount = value; }
        }

        NativeReference refReleaseSyncs;
        public DeviceMemory[] ReleaseSyncs
        {
            get
            {
                if (M->ReleaseCount == 0)
                    return null;
                var values = new DeviceMemory[M->ReleaseCount];
                unsafe
                {
                    UInt64* ptr = (UInt64*)M->ReleaseSyncs;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = new DeviceMemory();
                        values[i].M = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->ReleaseCount = 0;
                    M->ReleaseSyncs = IntPtr.Zero;
                    return;
                }
                M->ReleaseCount = (uint)value.Length;
                refReleaseSyncs = new NativeReference((int)(sizeof(UInt64) * value.Length));
                M->ReleaseSyncs = refReleaseSyncs.Handle;
                unsafe
                {
                    UInt64* ptr = (UInt64*)M->ReleaseSyncs;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i].M;
                    }
                }
            }
        }

        NativeReference refReleaseKeys;
        public UInt64[] ReleaseKeys
        {
            get
            {
                if (M->ReleaseCount == 0)
                    return null;
                var values = new UInt64[M->ReleaseCount];
                unsafe
                {
                    UInt64* ptr = (UInt64*)M->ReleaseKeys;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->ReleaseCount = 0;
                    M->ReleaseKeys = IntPtr.Zero;
                    return;
                }
                M->ReleaseCount = (uint)value.Length;
                refReleaseKeys = new NativeReference((int)(sizeof(UInt64) * value.Length));
                M->ReleaseKeys = refReleaseKeys.Handle;
                unsafe
                {
                    UInt64* ptr = (UInt64*)M->ReleaseKeys;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        internal new Interop.Win32KeyedMutexAcquireReleaseInfoKhr* M
        {
            get { return (Interop.Win32KeyedMutexAcquireReleaseInfoKhr*)native.Handle; }
        }

        public Win32KeyedMutexAcquireReleaseInfoKhr()
        {
            native = Interop.Structure.Allocate(typeof(Interop.Win32KeyedMutexAcquireReleaseInfoKhr));

            M->SType = StructureType.Win32KeyedMutexAcquireReleaseInfoKhr;
        }

        internal Win32KeyedMutexAcquireReleaseInfoKhr(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.Win32KeyedMutexAcquireReleaseInfoKhr;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refAcquireSyncs.Dispose();
            refAcquireSyncs = null;
            refAcquireKeys.Dispose();
            refAcquireKeys = null;
            refAcquireTimeouts.Dispose();
            refAcquireTimeouts = null;
            refReleaseSyncs.Dispose();
            refReleaseSyncs = null;
            refReleaseKeys.Dispose();
            refReleaseKeys = null;
        }
    }

    unsafe public partial class PhysicalDeviceExternalSemaphoreInfo : MarshalledObject
    {
        public ExternalSemaphoreHandleTypeFlags HandleType
        {
            get { return M->HandleType; }
            set { M->HandleType = value; }
        }

        internal Interop.PhysicalDeviceExternalSemaphoreInfo* M
        {
            get { return (Interop.PhysicalDeviceExternalSemaphoreInfo*)native.Handle; }
        }

        public PhysicalDeviceExternalSemaphoreInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PhysicalDeviceExternalSemaphoreInfo));

            M->SType = StructureType.PhysicalDeviceExternalSemaphoreInfo;
        }

        internal PhysicalDeviceExternalSemaphoreInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PhysicalDeviceExternalSemaphoreInfo;
        }
    }

    unsafe public partial class ExternalSemaphoreProperties : MarshalledObject
    {
        public ExternalSemaphoreHandleTypeFlags ExportFromImportedHandleTypes
        {
            get { return M->ExportFromImportedHandleTypes; }
            set { M->ExportFromImportedHandleTypes = value; }
        }

        public ExternalSemaphoreHandleTypeFlags CompatibleHandleTypes
        {
            get { return M->CompatibleHandleTypes; }
            set { M->CompatibleHandleTypes = value; }
        }

        public ExternalSemaphoreFeatureFlags ExternalSemaphoreFeatures
        {
            get { return M->ExternalSemaphoreFeatures; }
            set { M->ExternalSemaphoreFeatures = value; }
        }

        internal Interop.ExternalSemaphoreProperties* M
        {
            get { return (Interop.ExternalSemaphoreProperties*)native.Handle; }
        }

        public ExternalSemaphoreProperties()
        {
            native = Interop.Structure.Allocate(typeof(Interop.ExternalSemaphoreProperties));

            M->SType = StructureType.ExternalSemaphoreProperties;
        }

        internal ExternalSemaphoreProperties(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.ExternalSemaphoreProperties;
        }
    }

    unsafe public partial class ExportSemaphoreCreateInfo : SemaphoreCreateInfo
    {
        public ExternalSemaphoreHandleTypeFlags HandleTypes
        {
            get { return M->HandleTypes; }
            set { M->HandleTypes = value; }
        }

        internal new Interop.ExportSemaphoreCreateInfo* M
        {
            get { return (Interop.ExportSemaphoreCreateInfo*)native.Handle; }
        }

        public ExportSemaphoreCreateInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.ExportSemaphoreCreateInfo));

            M->SType = StructureType.ExportSemaphoreCreateInfo;
        }

        internal ExportSemaphoreCreateInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.ExportSemaphoreCreateInfo;
        }
    }

    unsafe public partial class D3D12FenceSubmitInfoKhr : SubmitInfo
    {
        public UInt32 WaitSemaphoreValuesCount
        {
            get { return M->WaitSemaphoreValuesCount; }
            set { M->WaitSemaphoreValuesCount = value; }
        }

        NativeReference refWaitSemaphoreValues;
        public UInt64[] WaitSemaphoreValues
        {
            get
            {
                if (M->WaitSemaphoreValuesCount == 0)
                    return null;
                var values = new UInt64[M->WaitSemaphoreValuesCount];
                unsafe
                {
                    UInt64* ptr = (UInt64*)M->WaitSemaphoreValues;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->WaitSemaphoreValuesCount = 0;
                    M->WaitSemaphoreValues = IntPtr.Zero;
                    return;
                }
                M->WaitSemaphoreValuesCount = (uint)value.Length;
                refWaitSemaphoreValues = new NativeReference((int)(sizeof(UInt64) * value.Length));
                M->WaitSemaphoreValues = refWaitSemaphoreValues.Handle;
                unsafe
                {
                    UInt64* ptr = (UInt64*)M->WaitSemaphoreValues;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        public UInt32 SignalSemaphoreValuesCount
        {
            get { return M->SignalSemaphoreValuesCount; }
            set { M->SignalSemaphoreValuesCount = value; }
        }

        NativeReference refSignalSemaphoreValues;
        public UInt64[] SignalSemaphoreValues
        {
            get
            {
                if (M->SignalSemaphoreValuesCount == 0)
                    return null;
                var values = new UInt64[M->SignalSemaphoreValuesCount];
                unsafe
                {
                    UInt64* ptr = (UInt64*)M->SignalSemaphoreValues;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->SignalSemaphoreValuesCount = 0;
                    M->SignalSemaphoreValues = IntPtr.Zero;
                    return;
                }
                M->SignalSemaphoreValuesCount = (uint)value.Length;
                refSignalSemaphoreValues = new NativeReference((int)(sizeof(UInt64) * value.Length));
                M->SignalSemaphoreValues = refSignalSemaphoreValues.Handle;
                unsafe
                {
                    UInt64* ptr = (UInt64*)M->SignalSemaphoreValues;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        internal new Interop.D3D12FenceSubmitInfoKhr* M
        {
            get { return (Interop.D3D12FenceSubmitInfoKhr*)native.Handle; }
        }

        public D3D12FenceSubmitInfoKhr()
        {
            native = Interop.Structure.Allocate(typeof(Interop.D3D12FenceSubmitInfoKhr));

            M->SType = StructureType.D3D12FenceSubmitInfoKhr;
        }

        internal D3D12FenceSubmitInfoKhr(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.D3D12FenceSubmitInfoKhr;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refWaitSemaphoreValues.Dispose();
            refWaitSemaphoreValues = null;
            refSignalSemaphoreValues.Dispose();
            refSignalSemaphoreValues = null;
        }
    }

    unsafe public partial class SemaphoreGetWin32HandleInfoKhr : MarshalledObject
    {
        Semaphore lSemaphore;
        public Semaphore Semaphore
        {
            get { return lSemaphore; }
            set { lSemaphore = value; M->Semaphore = value != null ? (UInt64)value.M : default(UInt64); }
        }

        public ExternalSemaphoreHandleTypeFlags HandleType
        {
            get { return M->HandleType; }
            set { M->HandleType = value; }
        }

        internal Interop.SemaphoreGetWin32HandleInfoKhr* M
        {
            get { return (Interop.SemaphoreGetWin32HandleInfoKhr*)native.Handle; }
        }

        public SemaphoreGetWin32HandleInfoKhr()
        {
            native = Interop.Structure.Allocate(typeof(Interop.SemaphoreGetWin32HandleInfoKhr));

            M->SType = StructureType.SemaphoreGetWin32HandleInfoKhr;
        }

        internal SemaphoreGetWin32HandleInfoKhr(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.SemaphoreGetWin32HandleInfoKhr;
        }
    }

    unsafe public partial class ImportSemaphoreFdInfoKhr : MarshalledObject
    {
        Semaphore lSemaphore;
        public Semaphore Semaphore
        {
            get { return lSemaphore; }
            set { lSemaphore = value; M->Semaphore = value != null ? (UInt64)value.M : default(UInt64); }
        }

        public SemaphoreImportFlags Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        public ExternalSemaphoreHandleTypeFlags HandleType
        {
            get { return M->HandleType; }
            set { M->HandleType = value; }
        }

        public int Fd
        {
            get { return M->Fd; }
            set { M->Fd = value; }
        }

        internal Interop.ImportSemaphoreFdInfoKhr* M
        {
            get { return (Interop.ImportSemaphoreFdInfoKhr*)native.Handle; }
        }

        public ImportSemaphoreFdInfoKhr()
        {
            native = Interop.Structure.Allocate(typeof(Interop.ImportSemaphoreFdInfoKhr));

            M->SType = StructureType.ImportSemaphoreFdInfoKhr;
        }

        internal ImportSemaphoreFdInfoKhr(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.ImportSemaphoreFdInfoKhr;
        }
    }

    unsafe public partial class SemaphoreGetFdInfoKhr : MarshalledObject
    {
        Semaphore lSemaphore;
        public Semaphore Semaphore
        {
            get { return lSemaphore; }
            set { lSemaphore = value; M->Semaphore = value != null ? (UInt64)value.M : default(UInt64); }
        }

        public ExternalSemaphoreHandleTypeFlags HandleType
        {
            get { return M->HandleType; }
            set { M->HandleType = value; }
        }

        internal Interop.SemaphoreGetFdInfoKhr* M
        {
            get { return (Interop.SemaphoreGetFdInfoKhr*)native.Handle; }
        }

        public SemaphoreGetFdInfoKhr()
        {
            native = Interop.Structure.Allocate(typeof(Interop.SemaphoreGetFdInfoKhr));

            M->SType = StructureType.SemaphoreGetFdInfoKhr;
        }

        internal SemaphoreGetFdInfoKhr(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.SemaphoreGetFdInfoKhr;
        }
    }

    unsafe public partial class PhysicalDeviceExternalFenceInfo : MarshalledObject
    {
        public ExternalFenceHandleTypeFlags HandleType
        {
            get { return M->HandleType; }
            set { M->HandleType = value; }
        }

        internal Interop.PhysicalDeviceExternalFenceInfo* M
        {
            get { return (Interop.PhysicalDeviceExternalFenceInfo*)native.Handle; }
        }

        public PhysicalDeviceExternalFenceInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PhysicalDeviceExternalFenceInfo));

            M->SType = StructureType.PhysicalDeviceExternalFenceInfo;
        }

        internal PhysicalDeviceExternalFenceInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PhysicalDeviceExternalFenceInfo;
        }
    }

    unsafe public partial class ExternalFenceProperties : MarshalledObject
    {
        public ExternalFenceHandleTypeFlags ExportFromImportedHandleTypes
        {
            get { return M->ExportFromImportedHandleTypes; }
            set { M->ExportFromImportedHandleTypes = value; }
        }

        public ExternalFenceHandleTypeFlags CompatibleHandleTypes
        {
            get { return M->CompatibleHandleTypes; }
            set { M->CompatibleHandleTypes = value; }
        }

        public ExternalFenceFeatureFlags ExternalFenceFeatures
        {
            get { return M->ExternalFenceFeatures; }
            set { M->ExternalFenceFeatures = value; }
        }

        internal Interop.ExternalFenceProperties* M
        {
            get { return (Interop.ExternalFenceProperties*)native.Handle; }
        }

        public ExternalFenceProperties()
        {
            native = Interop.Structure.Allocate(typeof(Interop.ExternalFenceProperties));

            M->SType = StructureType.ExternalFenceProperties;
        }

        internal ExternalFenceProperties(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.ExternalFenceProperties;
        }
    }

    unsafe public partial class ExportFenceCreateInfo : FenceCreateInfo
    {
        public ExternalFenceHandleTypeFlags HandleTypes
        {
            get { return M->HandleTypes; }
            set { M->HandleTypes = value; }
        }

        internal new Interop.ExportFenceCreateInfo* M
        {
            get { return (Interop.ExportFenceCreateInfo*)native.Handle; }
        }

        public ExportFenceCreateInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.ExportFenceCreateInfo));

            M->SType = StructureType.ExportFenceCreateInfo;
        }

        internal ExportFenceCreateInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.ExportFenceCreateInfo;
        }
    }

    unsafe public partial class FenceGetWin32HandleInfoKhr : MarshalledObject
    {
        Fence lFence;
        public Fence Fence
        {
            get { return lFence; }
            set { lFence = value; M->Fence = value != null ? (UInt64)value.M : default(UInt64); }
        }

        public ExternalFenceHandleTypeFlags HandleType
        {
            get { return M->HandleType; }
            set { M->HandleType = value; }
        }

        internal Interop.FenceGetWin32HandleInfoKhr* M
        {
            get { return (Interop.FenceGetWin32HandleInfoKhr*)native.Handle; }
        }

        public FenceGetWin32HandleInfoKhr()
        {
            native = Interop.Structure.Allocate(typeof(Interop.FenceGetWin32HandleInfoKhr));

            M->SType = StructureType.FenceGetWin32HandleInfoKhr;
        }

        internal FenceGetWin32HandleInfoKhr(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.FenceGetWin32HandleInfoKhr;
        }
    }

    unsafe public partial class ImportFenceFdInfoKhr : MarshalledObject
    {
        Fence lFence;
        public Fence Fence
        {
            get { return lFence; }
            set { lFence = value; M->Fence = value != null ? (UInt64)value.M : default(UInt64); }
        }

        public FenceImportFlags Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        public ExternalFenceHandleTypeFlags HandleType
        {
            get { return M->HandleType; }
            set { M->HandleType = value; }
        }

        public int Fd
        {
            get { return M->Fd; }
            set { M->Fd = value; }
        }

        internal Interop.ImportFenceFdInfoKhr* M
        {
            get { return (Interop.ImportFenceFdInfoKhr*)native.Handle; }
        }

        public ImportFenceFdInfoKhr()
        {
            native = Interop.Structure.Allocate(typeof(Interop.ImportFenceFdInfoKhr));

            M->SType = StructureType.ImportFenceFdInfoKhr;
        }

        internal ImportFenceFdInfoKhr(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.ImportFenceFdInfoKhr;
        }
    }

    unsafe public partial class FenceGetFdInfoKhr : MarshalledObject
    {
        Fence lFence;
        public Fence Fence
        {
            get { return lFence; }
            set { lFence = value; M->Fence = value != null ? (UInt64)value.M : default(UInt64); }
        }

        public ExternalFenceHandleTypeFlags HandleType
        {
            get { return M->HandleType; }
            set { M->HandleType = value; }
        }

        internal Interop.FenceGetFdInfoKhr* M
        {
            get { return (Interop.FenceGetFdInfoKhr*)native.Handle; }
        }

        public FenceGetFdInfoKhr()
        {
            native = Interop.Structure.Allocate(typeof(Interop.FenceGetFdInfoKhr));

            M->SType = StructureType.FenceGetFdInfoKhr;
        }

        internal FenceGetFdInfoKhr(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.FenceGetFdInfoKhr;
        }
    }

    unsafe public partial class PhysicalDeviceMultiviewFeatures : PhysicalDeviceFeatures2
    {
        /// <summary>
        /// Multiple views in a renderpass
        /// </summary>
        public bool Multiview
        {
            get { return M->Multiview; }
            set { M->Multiview = value; }
        }

        /// <summary>
        /// Multiple views in a renderpass w/ geometry shader
        /// </summary>
        public bool MultiviewGeometryShader
        {
            get { return M->MultiviewGeometryShader; }
            set { M->MultiviewGeometryShader = value; }
        }

        /// <summary>
        /// Multiple views in a renderpass w/ tessellation shader
        /// </summary>
        public bool MultiviewTessellationShader
        {
            get { return M->MultiviewTessellationShader; }
            set { M->MultiviewTessellationShader = value; }
        }

        internal new Interop.PhysicalDeviceMultiviewFeatures* M
        {
            get { return (Interop.PhysicalDeviceMultiviewFeatures*)native.Handle; }
        }

        public PhysicalDeviceMultiviewFeatures()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PhysicalDeviceMultiviewFeatures));

            M->SType = StructureType.PhysicalDeviceMultiviewFeatures;
        }

        internal PhysicalDeviceMultiviewFeatures(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PhysicalDeviceMultiviewFeatures;
        }
    }

    unsafe public partial class PhysicalDeviceMultiviewProperties : PhysicalDeviceProperties2
    {
        /// <summary>
        /// max number of views in a subpass
        /// </summary>
        public UInt32 MaxMultiviewViewCount
        {
            get { return M->MaxMultiviewViewCount; }
            set { M->MaxMultiviewViewCount = value; }
        }

        /// <summary>
        /// max instance index for a draw in a multiview subpass
        /// </summary>
        public UInt32 MaxMultiviewInstanceIndex
        {
            get { return M->MaxMultiviewInstanceIndex; }
            set { M->MaxMultiviewInstanceIndex = value; }
        }

        internal new Interop.PhysicalDeviceMultiviewProperties* M
        {
            get { return (Interop.PhysicalDeviceMultiviewProperties*)native.Handle; }
        }

        public PhysicalDeviceMultiviewProperties()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PhysicalDeviceMultiviewProperties));

            M->SType = StructureType.PhysicalDeviceMultiviewProperties;
        }

        internal PhysicalDeviceMultiviewProperties(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PhysicalDeviceMultiviewProperties;
        }
    }

    unsafe public partial class RenderPassMultiviewCreateInfo : RenderPassCreateInfo
    {
        public new UInt32 SubpassCount
        {
            get { return M->SubpassCount; }
            set { M->SubpassCount = value; }
        }

        NativeReference refViewMasks;
        public UInt32[] ViewMasks
        {
            get
            {
                if (M->SubpassCount == 0)
                    return null;
                var values = new UInt32[M->SubpassCount];
                unsafe
                {
                    UInt32* ptr = (UInt32*)M->ViewMasks;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->SubpassCount = 0;
                    M->ViewMasks = IntPtr.Zero;
                    return;
                }
                M->SubpassCount = (uint)value.Length;
                refViewMasks = new NativeReference((int)(sizeof(UInt32) * value.Length));
                M->ViewMasks = refViewMasks.Handle;
                unsafe
                {
                    UInt32* ptr = (UInt32*)M->ViewMasks;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        public new UInt32 DependencyCount
        {
            get { return M->DependencyCount; }
            set { M->DependencyCount = value; }
        }

        NativeReference refViewOffsets;
        public Int32[] ViewOffsets
        {
            get
            {
                if (M->DependencyCount == 0)
                    return null;
                var values = new Int32[M->DependencyCount];
                unsafe
                {
                    Int32* ptr = (Int32*)M->ViewOffsets;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->DependencyCount = 0;
                    M->ViewOffsets = IntPtr.Zero;
                    return;
                }
                M->DependencyCount = (uint)value.Length;
                refViewOffsets = new NativeReference((int)(sizeof(Int32) * value.Length));
                M->ViewOffsets = refViewOffsets.Handle;
                unsafe
                {
                    Int32* ptr = (Int32*)M->ViewOffsets;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        public UInt32 CorrelationMaskCount
        {
            get { return M->CorrelationMaskCount; }
            set { M->CorrelationMaskCount = value; }
        }

        NativeReference refCorrelationMasks;
        public UInt32[] CorrelationMasks
        {
            get
            {
                if (M->CorrelationMaskCount == 0)
                    return null;
                var values = new UInt32[M->CorrelationMaskCount];
                unsafe
                {
                    UInt32* ptr = (UInt32*)M->CorrelationMasks;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->CorrelationMaskCount = 0;
                    M->CorrelationMasks = IntPtr.Zero;
                    return;
                }
                M->CorrelationMaskCount = (uint)value.Length;
                refCorrelationMasks = new NativeReference((int)(sizeof(UInt32) * value.Length));
                M->CorrelationMasks = refCorrelationMasks.Handle;
                unsafe
                {
                    UInt32* ptr = (UInt32*)M->CorrelationMasks;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        internal new Interop.RenderPassMultiviewCreateInfo* M
        {
            get { return (Interop.RenderPassMultiviewCreateInfo*)native.Handle; }
        }

        public RenderPassMultiviewCreateInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.RenderPassMultiviewCreateInfo));

            M->SType = StructureType.RenderPassMultiviewCreateInfo;
        }

        internal RenderPassMultiviewCreateInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.RenderPassMultiviewCreateInfo;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refViewMasks.Dispose();
            refViewMasks = null;
            refViewOffsets.Dispose();
            refViewOffsets = null;
            refCorrelationMasks.Dispose();
            refCorrelationMasks = null;
        }
    }

    unsafe public partial class SurfaceCapabilities2Ext : MarshalledObject
    {
        /// <summary>
        /// Supported minimum number of images for the surface
        /// </summary>
        public UInt32 MinImageCount
        {
            get { return M->MinImageCount; }
            set { M->MinImageCount = value; }
        }

        /// <summary>
        /// Supported maximum number of images for the surface, 0 for unlimited
        /// </summary>
        public UInt32 MaxImageCount
        {
            get { return M->MaxImageCount; }
            set { M->MaxImageCount = value; }
        }

        /// <summary>
        /// Current image width and height for the surface, (0, 0) if undefined
        /// </summary>
        public Extent2D CurrentExtent
        {
            get { return M->CurrentExtent; }
            set { M->CurrentExtent = value; }
        }

        /// <summary>
        /// Supported minimum image width and height for the surface
        /// </summary>
        public Extent2D MinImageExtent
        {
            get { return M->MinImageExtent; }
            set { M->MinImageExtent = value; }
        }

        /// <summary>
        /// Supported maximum image width and height for the surface
        /// </summary>
        public Extent2D MaxImageExtent
        {
            get { return M->MaxImageExtent; }
            set { M->MaxImageExtent = value; }
        }

        /// <summary>
        /// Supported maximum number of image layers for the surface
        /// </summary>
        public UInt32 MaxImageArrayLayers
        {
            get { return M->MaxImageArrayLayers; }
            set { M->MaxImageArrayLayers = value; }
        }

        /// <summary>
        /// 1 or more bits representing the transforms supported
        /// </summary>
        public SurfaceTransformFlagsKhr SupportedTransforms
        {
            get { return M->SupportedTransforms; }
            set { M->SupportedTransforms = value; }
        }

        /// <summary>
        /// The surface's current transform relative to the device's natural orientation
        /// </summary>
        public SurfaceTransformFlagsKhr CurrentTransform
        {
            get { return M->CurrentTransform; }
            set { M->CurrentTransform = value; }
        }

        /// <summary>
        /// 1 or more bits representing the alpha compositing modes supported
        /// </summary>
        public CompositeAlphaFlagsKhr SupportedCompositeAlpha
        {
            get { return M->SupportedCompositeAlpha; }
            set { M->SupportedCompositeAlpha = value; }
        }

        /// <summary>
        /// Supported image usage flags for the surface
        /// </summary>
        public ImageUsageFlags SupportedUsageFlags
        {
            get { return M->SupportedUsageFlags; }
            set { M->SupportedUsageFlags = value; }
        }

        public SurfaceCounterFlagsExt SupportedSurfaceCounters
        {
            get { return M->SupportedSurfaceCounters; }
            set { M->SupportedSurfaceCounters = value; }
        }

        internal Interop.SurfaceCapabilities2Ext* M
        {
            get { return (Interop.SurfaceCapabilities2Ext*)native.Handle; }
        }

        public SurfaceCapabilities2Ext()
        {
            native = Interop.Structure.Allocate(typeof(Interop.SurfaceCapabilities2Ext));

            M->SType = StructureType.SurfaceCapabilities2Ext;
        }

        internal SurfaceCapabilities2Ext(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.SurfaceCapabilities2Ext;
        }
    }

    unsafe public partial class DisplayPowerInfoExt : MarshalledObject
    {
        public DisplayPowerStateExt PowerState
        {
            get { return M->PowerState; }
            set { M->PowerState = value; }
        }

        internal Interop.DisplayPowerInfoExt* M
        {
            get { return (Interop.DisplayPowerInfoExt*)native.Handle; }
        }

        public DisplayPowerInfoExt()
        {
            native = Interop.Structure.Allocate(typeof(Interop.DisplayPowerInfoExt));

            M->SType = StructureType.DisplayPowerInfoExt;
        }

        internal DisplayPowerInfoExt(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.DisplayPowerInfoExt;
        }
    }

    unsafe public partial class DeviceEventInfoExt : MarshalledObject
    {
        public DeviceEventTypeExt DeviceEvent
        {
            get { return M->DeviceEvent; }
            set { M->DeviceEvent = value; }
        }

        internal Interop.DeviceEventInfoExt* M
        {
            get { return (Interop.DeviceEventInfoExt*)native.Handle; }
        }

        public DeviceEventInfoExt()
        {
            native = Interop.Structure.Allocate(typeof(Interop.DeviceEventInfoExt));

            M->SType = StructureType.DeviceEventInfoExt;
        }

        internal DeviceEventInfoExt(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.DeviceEventInfoExt;
        }
    }

    unsafe public partial class DisplayEventInfoExt : MarshalledObject
    {
        public DisplayEventTypeExt DisplayEvent
        {
            get { return M->DisplayEvent; }
            set { M->DisplayEvent = value; }
        }

        internal Interop.DisplayEventInfoExt* M
        {
            get { return (Interop.DisplayEventInfoExt*)native.Handle; }
        }

        public DisplayEventInfoExt()
        {
            native = Interop.Structure.Allocate(typeof(Interop.DisplayEventInfoExt));

            M->SType = StructureType.DisplayEventInfoExt;
        }

        internal DisplayEventInfoExt(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.DisplayEventInfoExt;
        }
    }

    unsafe public partial class SwapchainCounterCreateInfoExt : SwapchainCreateInfoKhr
    {
        public SurfaceCounterFlagsExt SurfaceCounters
        {
            get { return M->SurfaceCounters; }
            set { M->SurfaceCounters = value; }
        }

        internal new Interop.SwapchainCounterCreateInfoExt* M
        {
            get { return (Interop.SwapchainCounterCreateInfoExt*)native.Handle; }
        }

        public SwapchainCounterCreateInfoExt()
        {
            native = Interop.Structure.Allocate(typeof(Interop.SwapchainCounterCreateInfoExt));

            M->SType = StructureType.SwapchainCounterCreateInfoExt;
        }

        internal SwapchainCounterCreateInfoExt(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.SwapchainCounterCreateInfoExt;
        }
    }

    unsafe public partial class MemoryAllocateFlagsInfo : MemoryAllocateInfo
    {
        public MemoryAllocateFlags Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        public UInt32 DeviceMask
        {
            get { return M->DeviceMask; }
            set { M->DeviceMask = value; }
        }

        internal new Interop.MemoryAllocateFlagsInfo* M
        {
            get { return (Interop.MemoryAllocateFlagsInfo*)native.Handle; }
        }

        public MemoryAllocateFlagsInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.MemoryAllocateFlagsInfo));

            M->SType = StructureType.MemoryAllocateFlagsInfo;
        }

        internal MemoryAllocateFlagsInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.MemoryAllocateFlagsInfo;
        }
    }

    unsafe public partial class BindBufferMemoryInfo : MarshalledObject
    {
        Buffer lBuffer;
        public Buffer Buffer
        {
            get { return lBuffer; }
            set { lBuffer = value; M->Buffer = value != null ? (UInt64)value.M : default(UInt64); }
        }

        DeviceMemory lMemory;
        public DeviceMemory Memory
        {
            get { return lMemory; }
            set { lMemory = value; M->Memory = value != null ? (UInt64)value.M : default(UInt64); }
        }

        public DeviceSize MemoryOffset
        {
            get { return M->MemoryOffset; }
            set { M->MemoryOffset = value; }
        }

        internal Interop.BindBufferMemoryInfo* M
        {
            get { return (Interop.BindBufferMemoryInfo*)native.Handle; }
        }

        public BindBufferMemoryInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.BindBufferMemoryInfo));

            M->SType = StructureType.BindBufferMemoryInfo;
        }

        internal BindBufferMemoryInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.BindBufferMemoryInfo;
        }
    }

    unsafe public partial class BindBufferMemoryDeviceGroupInfo : BindBufferMemoryInfo
    {
        public UInt32 DeviceIndexCount
        {
            get { return M->DeviceIndexCount; }
            set { M->DeviceIndexCount = value; }
        }

        NativeReference refDeviceIndices;
        public UInt32[] DeviceIndices
        {
            get
            {
                if (M->DeviceIndexCount == 0)
                    return null;
                var values = new UInt32[M->DeviceIndexCount];
                unsafe
                {
                    UInt32* ptr = (UInt32*)M->DeviceIndices;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->DeviceIndexCount = 0;
                    M->DeviceIndices = IntPtr.Zero;
                    return;
                }
                M->DeviceIndexCount = (uint)value.Length;
                refDeviceIndices = new NativeReference((int)(sizeof(UInt32) * value.Length));
                M->DeviceIndices = refDeviceIndices.Handle;
                unsafe
                {
                    UInt32* ptr = (UInt32*)M->DeviceIndices;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        internal new Interop.BindBufferMemoryDeviceGroupInfo* M
        {
            get { return (Interop.BindBufferMemoryDeviceGroupInfo*)native.Handle; }
        }

        public BindBufferMemoryDeviceGroupInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.BindBufferMemoryDeviceGroupInfo));

            M->SType = StructureType.BindBufferMemoryDeviceGroupInfo;
        }

        internal BindBufferMemoryDeviceGroupInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.BindBufferMemoryDeviceGroupInfo;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refDeviceIndices.Dispose();
            refDeviceIndices = null;
        }
    }

    unsafe public partial class BindImageMemoryInfo : MarshalledObject
    {
        Image lImage;
        public Image Image
        {
            get { return lImage; }
            set { lImage = value; M->Image = value != null ? (UInt64)value.M : default(UInt64); }
        }

        DeviceMemory lMemory;
        public DeviceMemory Memory
        {
            get { return lMemory; }
            set { lMemory = value; M->Memory = value != null ? (UInt64)value.M : default(UInt64); }
        }

        public DeviceSize MemoryOffset
        {
            get { return M->MemoryOffset; }
            set { M->MemoryOffset = value; }
        }

        internal Interop.BindImageMemoryInfo* M
        {
            get { return (Interop.BindImageMemoryInfo*)native.Handle; }
        }

        public BindImageMemoryInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.BindImageMemoryInfo));

            M->SType = StructureType.BindImageMemoryInfo;
        }

        internal BindImageMemoryInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.BindImageMemoryInfo;
        }
    }

    unsafe public partial class BindImageMemoryDeviceGroupInfo : BindImageMemoryInfo
    {
        public UInt32 DeviceIndexCount
        {
            get { return M->DeviceIndexCount; }
            set { M->DeviceIndexCount = value; }
        }

        NativeReference refDeviceIndices;
        public UInt32[] DeviceIndices
        {
            get
            {
                if (M->DeviceIndexCount == 0)
                    return null;
                var values = new UInt32[M->DeviceIndexCount];
                unsafe
                {
                    UInt32* ptr = (UInt32*)M->DeviceIndices;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->DeviceIndexCount = 0;
                    M->DeviceIndices = IntPtr.Zero;
                    return;
                }
                M->DeviceIndexCount = (uint)value.Length;
                refDeviceIndices = new NativeReference((int)(sizeof(UInt32) * value.Length));
                M->DeviceIndices = refDeviceIndices.Handle;
                unsafe
                {
                    UInt32* ptr = (UInt32*)M->DeviceIndices;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        public UInt32 SplitInstanceBindRegionCount
        {
            get { return M->SplitInstanceBindRegionCount; }
            set { M->SplitInstanceBindRegionCount = value; }
        }

        NativeReference refSplitInstanceBindRegions;
        public Rect2D[] SplitInstanceBindRegions
        {
            get
            {
                if (M->SplitInstanceBindRegionCount == 0)
                    return null;
                var values = new Rect2D[M->SplitInstanceBindRegionCount];
                unsafe
                {
                    Rect2D* ptr = (Rect2D*)M->SplitInstanceBindRegions;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->SplitInstanceBindRegionCount = 0;
                    M->SplitInstanceBindRegions = IntPtr.Zero;
                    return;
                }
                M->SplitInstanceBindRegionCount = (uint)value.Length;
                refSplitInstanceBindRegions = new NativeReference((int)(sizeof(Rect2D) * value.Length));
                M->SplitInstanceBindRegions = refSplitInstanceBindRegions.Handle;
                unsafe
                {
                    Rect2D* ptr = (Rect2D*)M->SplitInstanceBindRegions;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        internal new Interop.BindImageMemoryDeviceGroupInfo* M
        {
            get { return (Interop.BindImageMemoryDeviceGroupInfo*)native.Handle; }
        }

        public BindImageMemoryDeviceGroupInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.BindImageMemoryDeviceGroupInfo));

            M->SType = StructureType.BindImageMemoryDeviceGroupInfo;
        }

        internal BindImageMemoryDeviceGroupInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.BindImageMemoryDeviceGroupInfo;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refDeviceIndices.Dispose();
            refDeviceIndices = null;
            refSplitInstanceBindRegions.Dispose();
            refSplitInstanceBindRegions = null;
        }
    }

    unsafe public partial class DeviceGroupRenderPassBeginInfo : RenderPassBeginInfo
    {
        public UInt32 DeviceMask
        {
            get { return M->DeviceMask; }
            set { M->DeviceMask = value; }
        }

        public UInt32 DeviceRenderAreaCount
        {
            get { return M->DeviceRenderAreaCount; }
            set { M->DeviceRenderAreaCount = value; }
        }

        NativeReference refDeviceRenderAreas;
        public Rect2D[] DeviceRenderAreas
        {
            get
            {
                if (M->DeviceRenderAreaCount == 0)
                    return null;
                var values = new Rect2D[M->DeviceRenderAreaCount];
                unsafe
                {
                    Rect2D* ptr = (Rect2D*)M->DeviceRenderAreas;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->DeviceRenderAreaCount = 0;
                    M->DeviceRenderAreas = IntPtr.Zero;
                    return;
                }
                M->DeviceRenderAreaCount = (uint)value.Length;
                refDeviceRenderAreas = new NativeReference((int)(sizeof(Rect2D) * value.Length));
                M->DeviceRenderAreas = refDeviceRenderAreas.Handle;
                unsafe
                {
                    Rect2D* ptr = (Rect2D*)M->DeviceRenderAreas;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        internal new Interop.DeviceGroupRenderPassBeginInfo* M
        {
            get { return (Interop.DeviceGroupRenderPassBeginInfo*)native.Handle; }
        }

        public DeviceGroupRenderPassBeginInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.DeviceGroupRenderPassBeginInfo));

            M->SType = StructureType.DeviceGroupRenderPassBeginInfo;
        }

        internal DeviceGroupRenderPassBeginInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.DeviceGroupRenderPassBeginInfo;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refDeviceRenderAreas.Dispose();
            refDeviceRenderAreas = null;
        }
    }

    unsafe public partial class DeviceGroupCommandBufferBeginInfo : CommandBufferBeginInfo
    {
        public UInt32 DeviceMask
        {
            get { return M->DeviceMask; }
            set { M->DeviceMask = value; }
        }

        internal new Interop.DeviceGroupCommandBufferBeginInfo* M
        {
            get { return (Interop.DeviceGroupCommandBufferBeginInfo*)native.Handle; }
        }

        public DeviceGroupCommandBufferBeginInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.DeviceGroupCommandBufferBeginInfo));

            M->SType = StructureType.DeviceGroupCommandBufferBeginInfo;
        }

        internal DeviceGroupCommandBufferBeginInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.DeviceGroupCommandBufferBeginInfo;
        }
    }

    unsafe public partial class DeviceGroupSubmitInfo : SubmitInfo
    {
        public new UInt32 WaitSemaphoreCount
        {
            get { return M->WaitSemaphoreCount; }
            set { M->WaitSemaphoreCount = value; }
        }

        NativeReference refWaitSemaphoreDeviceIndices;
        public UInt32[] WaitSemaphoreDeviceIndices
        {
            get
            {
                if (M->WaitSemaphoreCount == 0)
                    return null;
                var values = new UInt32[M->WaitSemaphoreCount];
                unsafe
                {
                    UInt32* ptr = (UInt32*)M->WaitSemaphoreDeviceIndices;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->WaitSemaphoreCount = 0;
                    M->WaitSemaphoreDeviceIndices = IntPtr.Zero;
                    return;
                }
                M->WaitSemaphoreCount = (uint)value.Length;
                refWaitSemaphoreDeviceIndices = new NativeReference((int)(sizeof(UInt32) * value.Length));
                M->WaitSemaphoreDeviceIndices = refWaitSemaphoreDeviceIndices.Handle;
                unsafe
                {
                    UInt32* ptr = (UInt32*)M->WaitSemaphoreDeviceIndices;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        public new UInt32 CommandBufferCount
        {
            get { return M->CommandBufferCount; }
            set { M->CommandBufferCount = value; }
        }

        NativeReference refCommandBufferDeviceMasks;
        public UInt32[] CommandBufferDeviceMasks
        {
            get
            {
                if (M->CommandBufferCount == 0)
                    return null;
                var values = new UInt32[M->CommandBufferCount];
                unsafe
                {
                    UInt32* ptr = (UInt32*)M->CommandBufferDeviceMasks;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->CommandBufferCount = 0;
                    M->CommandBufferDeviceMasks = IntPtr.Zero;
                    return;
                }
                M->CommandBufferCount = (uint)value.Length;
                refCommandBufferDeviceMasks = new NativeReference((int)(sizeof(UInt32) * value.Length));
                M->CommandBufferDeviceMasks = refCommandBufferDeviceMasks.Handle;
                unsafe
                {
                    UInt32* ptr = (UInt32*)M->CommandBufferDeviceMasks;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        public new UInt32 SignalSemaphoreCount
        {
            get { return M->SignalSemaphoreCount; }
            set { M->SignalSemaphoreCount = value; }
        }

        NativeReference refSignalSemaphoreDeviceIndices;
        public UInt32[] SignalSemaphoreDeviceIndices
        {
            get
            {
                if (M->SignalSemaphoreCount == 0)
                    return null;
                var values = new UInt32[M->SignalSemaphoreCount];
                unsafe
                {
                    UInt32* ptr = (UInt32*)M->SignalSemaphoreDeviceIndices;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->SignalSemaphoreCount = 0;
                    M->SignalSemaphoreDeviceIndices = IntPtr.Zero;
                    return;
                }
                M->SignalSemaphoreCount = (uint)value.Length;
                refSignalSemaphoreDeviceIndices = new NativeReference((int)(sizeof(UInt32) * value.Length));
                M->SignalSemaphoreDeviceIndices = refSignalSemaphoreDeviceIndices.Handle;
                unsafe
                {
                    UInt32* ptr = (UInt32*)M->SignalSemaphoreDeviceIndices;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        internal new Interop.DeviceGroupSubmitInfo* M
        {
            get { return (Interop.DeviceGroupSubmitInfo*)native.Handle; }
        }

        public DeviceGroupSubmitInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.DeviceGroupSubmitInfo));

            M->SType = StructureType.DeviceGroupSubmitInfo;
        }

        internal DeviceGroupSubmitInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.DeviceGroupSubmitInfo;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refWaitSemaphoreDeviceIndices.Dispose();
            refWaitSemaphoreDeviceIndices = null;
            refCommandBufferDeviceMasks.Dispose();
            refCommandBufferDeviceMasks = null;
            refSignalSemaphoreDeviceIndices.Dispose();
            refSignalSemaphoreDeviceIndices = null;
        }
    }

    unsafe public partial class DeviceGroupBindSparseInfo : BindSparseInfo
    {
        public UInt32 ResourceDeviceIndex
        {
            get { return M->ResourceDeviceIndex; }
            set { M->ResourceDeviceIndex = value; }
        }

        public UInt32 MemoryDeviceIndex
        {
            get { return M->MemoryDeviceIndex; }
            set { M->MemoryDeviceIndex = value; }
        }

        internal new Interop.DeviceGroupBindSparseInfo* M
        {
            get { return (Interop.DeviceGroupBindSparseInfo*)native.Handle; }
        }

        public DeviceGroupBindSparseInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.DeviceGroupBindSparseInfo));

            M->SType = StructureType.DeviceGroupBindSparseInfo;
        }

        internal DeviceGroupBindSparseInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.DeviceGroupBindSparseInfo;
        }
    }

    unsafe public partial class DeviceGroupPresentCapabilitiesKhr : MarshalledObject
    {
        public UInt32[] PresentMask
        {
            get
            {
                var arr = new UInt32[32];
                for (int i = 0; i < 32; i++)
                    arr[i] = M->PresentMask[i];
                return arr;
            }
            set
            {
                if (value.Length > 32)
                    throw new Exception("array too long");
                for (int i = 0; i < value.Length; i++)
                    M->PresentMask[i] = value[i];
                for (int i = value.Length; i < 32; i++)
                    M->PresentMask[i] = 0;
            }
        }

        public DeviceGroupPresentModeFlagsKhr Modes
        {
            get { return M->Modes; }
            set { M->Modes = value; }
        }

        internal Interop.DeviceGroupPresentCapabilitiesKhr* M
        {
            get { return (Interop.DeviceGroupPresentCapabilitiesKhr*)native.Handle; }
        }

        public DeviceGroupPresentCapabilitiesKhr()
        {
            native = Interop.Structure.Allocate(typeof(Interop.DeviceGroupPresentCapabilitiesKhr));

            M->SType = StructureType.DeviceGroupPresentCapabilitiesKhr;
        }

        internal DeviceGroupPresentCapabilitiesKhr(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.DeviceGroupPresentCapabilitiesKhr;
        }
    }

    unsafe public partial class ImageSwapchainCreateInfoKhr : ImageCreateInfo
    {
        SwapchainKhr lSwapchain;
        public SwapchainKhr Swapchain
        {
            get { return lSwapchain; }
            set { lSwapchain = value; M->Swapchain = value != null ? (UInt64)value.M : default(UInt64); }
        }

        internal new Interop.ImageSwapchainCreateInfoKhr* M
        {
            get { return (Interop.ImageSwapchainCreateInfoKhr*)native.Handle; }
        }

        public ImageSwapchainCreateInfoKhr()
        {
            native = Interop.Structure.Allocate(typeof(Interop.ImageSwapchainCreateInfoKhr));

            M->SType = StructureType.ImageSwapchainCreateInfoKhr;
        }

        internal ImageSwapchainCreateInfoKhr(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.ImageSwapchainCreateInfoKhr;
        }
    }

    unsafe public partial class BindImageMemorySwapchainInfoKhr : BindImageMemoryInfo
    {
        SwapchainKhr lSwapchain;
        public SwapchainKhr Swapchain
        {
            get { return lSwapchain; }
            set { lSwapchain = value; M->Swapchain = value != null ? (UInt64)value.M : default(UInt64); }
        }

        public UInt32 ImageIndex
        {
            get { return M->ImageIndex; }
            set { M->ImageIndex = value; }
        }

        internal new Interop.BindImageMemorySwapchainInfoKhr* M
        {
            get { return (Interop.BindImageMemorySwapchainInfoKhr*)native.Handle; }
        }

        public BindImageMemorySwapchainInfoKhr()
        {
            native = Interop.Structure.Allocate(typeof(Interop.BindImageMemorySwapchainInfoKhr));

            M->SType = StructureType.BindImageMemorySwapchainInfoKhr;
        }

        internal BindImageMemorySwapchainInfoKhr(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.BindImageMemorySwapchainInfoKhr;
        }
    }

    unsafe public partial class AcquireNextImageInfoKhr : MarshalledObject
    {
        SwapchainKhr lSwapchain;
        public SwapchainKhr Swapchain
        {
            get { return lSwapchain; }
            set { lSwapchain = value; M->Swapchain = value != null ? (UInt64)value.M : default(UInt64); }
        }

        public UInt64 Timeout
        {
            get { return M->Timeout; }
            set { M->Timeout = value; }
        }

        Semaphore lSemaphore;
        public Semaphore Semaphore
        {
            get { return lSemaphore; }
            set { lSemaphore = value; M->Semaphore = value != null ? (UInt64)value.M : default(UInt64); }
        }

        Fence lFence;
        public Fence Fence
        {
            get { return lFence; }
            set { lFence = value; M->Fence = value != null ? (UInt64)value.M : default(UInt64); }
        }

        public UInt32 DeviceMask
        {
            get { return M->DeviceMask; }
            set { M->DeviceMask = value; }
        }

        internal Interop.AcquireNextImageInfoKhr* M
        {
            get { return (Interop.AcquireNextImageInfoKhr*)native.Handle; }
        }

        public AcquireNextImageInfoKhr()
        {
            native = Interop.Structure.Allocate(typeof(Interop.AcquireNextImageInfoKhr));

            M->SType = StructureType.AcquireNextImageInfoKhr;
        }

        internal AcquireNextImageInfoKhr(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.AcquireNextImageInfoKhr;
        }
    }

    unsafe public partial class DeviceGroupPresentInfoKhr : PresentInfoKhr
    {
        public new UInt32 SwapchainCount
        {
            get { return M->SwapchainCount; }
            set { M->SwapchainCount = value; }
        }

        NativeReference refDeviceMasks;
        public UInt32[] DeviceMasks
        {
            get
            {
                if (M->SwapchainCount == 0)
                    return null;
                var values = new UInt32[M->SwapchainCount];
                unsafe
                {
                    UInt32* ptr = (UInt32*)M->DeviceMasks;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->SwapchainCount = 0;
                    M->DeviceMasks = IntPtr.Zero;
                    return;
                }
                M->SwapchainCount = (uint)value.Length;
                refDeviceMasks = new NativeReference((int)(sizeof(UInt32) * value.Length));
                M->DeviceMasks = refDeviceMasks.Handle;
                unsafe
                {
                    UInt32* ptr = (UInt32*)M->DeviceMasks;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        public DeviceGroupPresentModeFlagsKhr Mode
        {
            get { return M->Mode; }
            set { M->Mode = value; }
        }

        internal new Interop.DeviceGroupPresentInfoKhr* M
        {
            get { return (Interop.DeviceGroupPresentInfoKhr*)native.Handle; }
        }

        public DeviceGroupPresentInfoKhr()
        {
            native = Interop.Structure.Allocate(typeof(Interop.DeviceGroupPresentInfoKhr));

            M->SType = StructureType.DeviceGroupPresentInfoKhr;
        }

        internal DeviceGroupPresentInfoKhr(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.DeviceGroupPresentInfoKhr;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refDeviceMasks.Dispose();
            refDeviceMasks = null;
        }
    }

    unsafe public partial class DeviceGroupDeviceCreateInfo : DeviceCreateInfo
    {
        public UInt32 PhysicalDeviceCount
        {
            get { return M->PhysicalDeviceCount; }
            set { M->PhysicalDeviceCount = value; }
        }

        NativeReference refPhysicalDevices;
        public PhysicalDevice[] PhysicalDevices
        {
            get
            {
                if (M->PhysicalDeviceCount == 0)
                    return null;
                var values = new PhysicalDevice[M->PhysicalDeviceCount];
                unsafe
                {
                    IntPtr* ptr = (IntPtr*)M->PhysicalDevices;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = new PhysicalDevice();
                        values[i].M = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->PhysicalDeviceCount = 0;
                    M->PhysicalDevices = IntPtr.Zero;
                    return;
                }
                M->PhysicalDeviceCount = (uint)value.Length;
                refPhysicalDevices = new NativeReference((int)(sizeof(IntPtr) * value.Length));
                M->PhysicalDevices = refPhysicalDevices.Handle;
                unsafe
                {
                    IntPtr* ptr = (IntPtr*)M->PhysicalDevices;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i].M;
                    }
                }
            }
        }

        internal new Interop.DeviceGroupDeviceCreateInfo* M
        {
            get { return (Interop.DeviceGroupDeviceCreateInfo*)native.Handle; }
        }

        public DeviceGroupDeviceCreateInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.DeviceGroupDeviceCreateInfo));

            M->SType = StructureType.DeviceGroupDeviceCreateInfo;
        }

        internal DeviceGroupDeviceCreateInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.DeviceGroupDeviceCreateInfo;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refPhysicalDevices.Dispose();
            refPhysicalDevices = null;
        }
    }

    unsafe public partial class DeviceGroupSwapchainCreateInfoKhr : SwapchainCreateInfoKhr
    {
        public DeviceGroupPresentModeFlagsKhr Modes
        {
            get { return M->Modes; }
            set { M->Modes = value; }
        }

        internal new Interop.DeviceGroupSwapchainCreateInfoKhr* M
        {
            get { return (Interop.DeviceGroupSwapchainCreateInfoKhr*)native.Handle; }
        }

        public DeviceGroupSwapchainCreateInfoKhr()
        {
            native = Interop.Structure.Allocate(typeof(Interop.DeviceGroupSwapchainCreateInfoKhr));

            M->SType = StructureType.DeviceGroupSwapchainCreateInfoKhr;
        }

        internal DeviceGroupSwapchainCreateInfoKhr(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.DeviceGroupSwapchainCreateInfoKhr;
        }
    }

    unsafe public partial struct DescriptorUpdateTemplateEntry
    {
        /// <summary>
        /// Binding within the destination descriptor set to write
        /// </summary>
        public UInt32 DstBinding;
        /// <summary>
        /// Array element within the destination binding to write
        /// </summary>
        public UInt32 DstArrayElement;
        /// <summary>
        /// Number of descriptors to write
        /// </summary>
        public UInt32 DescriptorCount;
        /// <summary>
        /// Descriptor type to write
        /// </summary>
        public DescriptorType DescriptorType;
        /// <summary>
        /// Offset into pData where the descriptors to update are stored
        /// </summary>
        public UIntPtr Offset;
        /// <summary>
        /// Stride between two descriptors in pData when writing more than one descriptor
        /// </summary>
        public UIntPtr Stride;
    }

    unsafe public partial class DescriptorUpdateTemplateCreateInfo : MarshalledObject
    {
        public DescriptorUpdateTemplateCreateFlags Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        /// <summary>
        /// Number of descriptor update entries to use for the update template
        /// </summary>
        public UInt32 DescriptorUpdateEntryCount
        {
            get { return M->DescriptorUpdateEntryCount; }
            set { M->DescriptorUpdateEntryCount = value; }
        }

        /// <summary>
        /// Descriptor update entries for the template
        /// </summary>
        NativeReference refDescriptorUpdateEntries;
        public DescriptorUpdateTemplateEntry[] DescriptorUpdateEntries
        {
            get
            {
                if (M->DescriptorUpdateEntryCount == 0)
                    return null;
                var values = new DescriptorUpdateTemplateEntry[M->DescriptorUpdateEntryCount];
                unsafe
                {
                    DescriptorUpdateTemplateEntry* ptr = (DescriptorUpdateTemplateEntry*)M->DescriptorUpdateEntries;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->DescriptorUpdateEntryCount = 0;
                    M->DescriptorUpdateEntries = IntPtr.Zero;
                    return;
                }
                M->DescriptorUpdateEntryCount = (uint)value.Length;
                refDescriptorUpdateEntries = new NativeReference((int)(sizeof(DescriptorUpdateTemplateEntry) * value.Length));
                M->DescriptorUpdateEntries = refDescriptorUpdateEntries.Handle;
                unsafe
                {
                    DescriptorUpdateTemplateEntry* ptr = (DescriptorUpdateTemplateEntry*)M->DescriptorUpdateEntries;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        public DescriptorUpdateTemplateType TemplateType
        {
            get { return M->TemplateType; }
            set { M->TemplateType = value; }
        }

        DescriptorSetLayout lDescriptorSetLayout;
        public DescriptorSetLayout DescriptorSetLayout
        {
            get { return lDescriptorSetLayout; }
            set { lDescriptorSetLayout = value; M->DescriptorSetLayout = value != null ? (UInt64)value.M : default(UInt64); }
        }

        public PipelineBindPoint PipelineBindPoint
        {
            get { return M->PipelineBindPoint; }
            set { M->PipelineBindPoint = value; }
        }

        /// <summary>
        /// If used for push descriptors, this is the only allowed layout
        /// </summary>
        PipelineLayout lPipelineLayout;
        public PipelineLayout PipelineLayout
        {
            get { return lPipelineLayout; }
            set { lPipelineLayout = value; M->PipelineLayout = value != null ? (UInt64)value.M : default(UInt64); }
        }

        public UInt32 Set
        {
            get { return M->Set; }
            set { M->Set = value; }
        }

        internal Interop.DescriptorUpdateTemplateCreateInfo* M
        {
            get { return (Interop.DescriptorUpdateTemplateCreateInfo*)native.Handle; }
        }

        public DescriptorUpdateTemplateCreateInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.DescriptorUpdateTemplateCreateInfo));

            M->SType = StructureType.DescriptorUpdateTemplateCreateInfo;
        }

        internal DescriptorUpdateTemplateCreateInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.DescriptorUpdateTemplateCreateInfo;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refDescriptorUpdateEntries.Dispose();
            refDescriptorUpdateEntries = null;
        }
    }

    unsafe public partial struct XYColorExt
    {
        public float X;
        public float Y;
    }

    unsafe public partial class HdrMetadataExt : MarshalledObject
    {
        /// <summary>
        /// Display primary's Red
        /// </summary>
        public XYColorExt DisplayPrimaryRed
        {
            get { return M->DisplayPrimaryRed; }
            set { M->DisplayPrimaryRed = value; }
        }

        /// <summary>
        /// Display primary's Green
        /// </summary>
        public XYColorExt DisplayPrimaryGreen
        {
            get { return M->DisplayPrimaryGreen; }
            set { M->DisplayPrimaryGreen = value; }
        }

        /// <summary>
        /// Display primary's Blue
        /// </summary>
        public XYColorExt DisplayPrimaryBlue
        {
            get { return M->DisplayPrimaryBlue; }
            set { M->DisplayPrimaryBlue = value; }
        }

        /// <summary>
        /// Display primary's Blue
        /// </summary>
        public XYColorExt WhitePoint
        {
            get { return M->WhitePoint; }
            set { M->WhitePoint = value; }
        }

        /// <summary>
        /// Display maximum luminance
        /// </summary>
        public float MaxLuminance
        {
            get { return M->MaxLuminance; }
            set { M->MaxLuminance = value; }
        }

        /// <summary>
        /// Display minimum luminance
        /// </summary>
        public float MinLuminance
        {
            get { return M->MinLuminance; }
            set { M->MinLuminance = value; }
        }

        /// <summary>
        /// Content maximum luminance
        /// </summary>
        public float MaxContentLightLevel
        {
            get { return M->MaxContentLightLevel; }
            set { M->MaxContentLightLevel = value; }
        }

        public float MaxFrameAverageLightLevel
        {
            get { return M->MaxFrameAverageLightLevel; }
            set { M->MaxFrameAverageLightLevel = value; }
        }

        internal Interop.HdrMetadataExt* M
        {
            get { return (Interop.HdrMetadataExt*)native.Handle; }
        }

        public HdrMetadataExt()
        {
            native = Interop.Structure.Allocate(typeof(Interop.HdrMetadataExt));

            M->SType = StructureType.HdrMetadataExt;
        }

        internal HdrMetadataExt(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.HdrMetadataExt;
        }
    }

    unsafe public partial struct RefreshCycleDurationGoogle
    {
        /// <summary>
        /// Number of nanoseconds from the start of one refresh cycle to the next
        /// </summary>
        public UInt64 RefreshDuration;
    }

    unsafe public partial struct PastPresentationTimingGoogle
    {
        /// <summary>
        /// Application-provided identifier, previously given to vkQueuePresentKHR
        /// </summary>
        public UInt32 PresentId;
        /// <summary>
        /// Earliest time an image should have been presented, previously given to vkQueuePresentKHR
        /// </summary>
        public UInt64 DesiredPresentTime;
        /// <summary>
        /// Time the image was actually displayed
        /// </summary>
        public UInt64 ActualPresentTime;
        /// <summary>
        /// Earliest time the image could have been displayed
        /// </summary>
        public UInt64 EarliestPresentTime;
        /// <summary>
        /// How early vkQueuePresentKHR was processed vs. how soon it needed to be and make earliestPresentTime
        /// </summary>
        public UInt64 PresentMargin;
    }

    unsafe public partial class PresentTimesInfoGoogle : PresentInfoKhr
    {
        /// <summary>
        /// Copy of VkPresentInfoKHR::swapchainCount
        /// </summary>
        public new UInt32 SwapchainCount
        {
            get { return M->SwapchainCount; }
            set { M->SwapchainCount = value; }
        }

        /// <summary>
        /// The earliest times to present images
        /// </summary>
        NativeReference refTimes;
        public PresentTimeGoogle[] Times
        {
            get
            {
                if (M->SwapchainCount == 0)
                    return null;
                var values = new PresentTimeGoogle[M->SwapchainCount];
                unsafe
                {
                    PresentTimeGoogle* ptr = (PresentTimeGoogle*)M->Times;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->SwapchainCount = 0;
                    M->Times = IntPtr.Zero;
                    return;
                }
                M->SwapchainCount = (uint)value.Length;
                refTimes = new NativeReference((int)(sizeof(PresentTimeGoogle) * value.Length));
                M->Times = refTimes.Handle;
                unsafe
                {
                    PresentTimeGoogle* ptr = (PresentTimeGoogle*)M->Times;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        internal new Interop.PresentTimesInfoGoogle* M
        {
            get { return (Interop.PresentTimesInfoGoogle*)native.Handle; }
        }

        public PresentTimesInfoGoogle()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PresentTimesInfoGoogle));

            M->SType = StructureType.PresentTimesInfoGoogle;
        }

        internal PresentTimesInfoGoogle(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PresentTimesInfoGoogle;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refTimes.Dispose();
            refTimes = null;
        }
    }

    unsafe public partial struct PresentTimeGoogle
    {
        /// <summary>
        /// Application-provided identifier
        /// </summary>
        public UInt32 PresentId;
        /// <summary>
        /// Earliest time an image should be presented
        /// </summary>
        public UInt64 DesiredPresentTime;
    }

    unsafe public partial class IOSSurfaceCreateInfoMvk : MarshalledObject
    {
        public IOSSurfaceCreateFlagsMvk Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        public IntPtr View
        {
            get { return M->View; }
            set { M->View = value; }
        }

        internal Interop.IOSSurfaceCreateInfoMvk* M
        {
            get { return (Interop.IOSSurfaceCreateInfoMvk*)native.Handle; }
        }

        public IOSSurfaceCreateInfoMvk()
        {
            native = Interop.Structure.Allocate(typeof(Interop.IOSSurfaceCreateInfoMvk));

            M->SType = StructureType.IOSSurfaceCreateInfoMvk;
        }

        internal IOSSurfaceCreateInfoMvk(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.IOSSurfaceCreateInfoMvk;
        }
    }

    unsafe public partial class MacOSSurfaceCreateInfoMvk : MarshalledObject
    {
        public MacOSSurfaceCreateFlagsMvk Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        public IntPtr View
        {
            get { return M->View; }
            set { M->View = value; }
        }

        internal Interop.MacOSSurfaceCreateInfoMvk* M
        {
            get { return (Interop.MacOSSurfaceCreateInfoMvk*)native.Handle; }
        }

        public MacOSSurfaceCreateInfoMvk()
        {
            native = Interop.Structure.Allocate(typeof(Interop.MacOSSurfaceCreateInfoMvk));

            M->SType = StructureType.MacOSSurfaceCreateInfoMvk;
        }

        internal MacOSSurfaceCreateInfoMvk(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.MacOSSurfaceCreateInfoMvk;
        }
    }

    unsafe public partial struct ViewportWScalingNv
    {
        public float Xcoeff;
        public float Ycoeff;
    }

    unsafe public partial class PipelineViewportWScalingStateCreateInfoNv : PipelineViewportStateCreateInfo
    {
        public bool ViewportWscalingEnable
        {
            get { return M->ViewportWscalingEnable; }
            set { M->ViewportWscalingEnable = value; }
        }

        public new UInt32 ViewportCount
        {
            get { return M->ViewportCount; }
            set { M->ViewportCount = value; }
        }

        NativeReference refViewportWscalings;
        public ViewportWScalingNv[] ViewportWscalings
        {
            get
            {
                if (M->ViewportCount == 0)
                    return null;
                var values = new ViewportWScalingNv[M->ViewportCount];
                unsafe
                {
                    ViewportWScalingNv* ptr = (ViewportWScalingNv*)M->ViewportWscalings;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->ViewportCount = 0;
                    M->ViewportWscalings = IntPtr.Zero;
                    return;
                }
                M->ViewportCount = (uint)value.Length;
                refViewportWscalings = new NativeReference((int)(sizeof(ViewportWScalingNv) * value.Length));
                M->ViewportWscalings = refViewportWscalings.Handle;
                unsafe
                {
                    ViewportWScalingNv* ptr = (ViewportWScalingNv*)M->ViewportWscalings;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        internal new Interop.PipelineViewportWScalingStateCreateInfoNv* M
        {
            get { return (Interop.PipelineViewportWScalingStateCreateInfoNv*)native.Handle; }
        }

        public PipelineViewportWScalingStateCreateInfoNv()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PipelineViewportWScalingStateCreateInfoNv));

            M->SType = StructureType.PipelineViewportWScalingStateCreateInfoNv;
        }

        internal PipelineViewportWScalingStateCreateInfoNv(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PipelineViewportWScalingStateCreateInfoNv;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refViewportWscalings.Dispose();
            refViewportWscalings = null;
        }
    }

    unsafe public partial struct ViewportSwizzleNv
    {
        public ViewportCoordinateSwizzleNv X;
        public ViewportCoordinateSwizzleNv Y;
        public ViewportCoordinateSwizzleNv Z;
        public ViewportCoordinateSwizzleNv W;
    }

    unsafe public partial class PipelineViewportSwizzleStateCreateInfoNv : PipelineViewportStateCreateInfo
    {
        public new PipelineViewportSwizzleStateCreateFlagsNv Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        public new UInt32 ViewportCount
        {
            get { return M->ViewportCount; }
            set { M->ViewportCount = value; }
        }

        NativeReference refViewportSwizzles;
        public ViewportSwizzleNv[] ViewportSwizzles
        {
            get
            {
                if (M->ViewportCount == 0)
                    return null;
                var values = new ViewportSwizzleNv[M->ViewportCount];
                unsafe
                {
                    ViewportSwizzleNv* ptr = (ViewportSwizzleNv*)M->ViewportSwizzles;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->ViewportCount = 0;
                    M->ViewportSwizzles = IntPtr.Zero;
                    return;
                }
                M->ViewportCount = (uint)value.Length;
                refViewportSwizzles = new NativeReference((int)(sizeof(ViewportSwizzleNv) * value.Length));
                M->ViewportSwizzles = refViewportSwizzles.Handle;
                unsafe
                {
                    ViewportSwizzleNv* ptr = (ViewportSwizzleNv*)M->ViewportSwizzles;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        internal new Interop.PipelineViewportSwizzleStateCreateInfoNv* M
        {
            get { return (Interop.PipelineViewportSwizzleStateCreateInfoNv*)native.Handle; }
        }

        public PipelineViewportSwizzleStateCreateInfoNv()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PipelineViewportSwizzleStateCreateInfoNv));

            M->SType = StructureType.PipelineViewportSwizzleStateCreateInfoNv;
        }

        internal PipelineViewportSwizzleStateCreateInfoNv(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PipelineViewportSwizzleStateCreateInfoNv;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refViewportSwizzles.Dispose();
            refViewportSwizzles = null;
        }
    }

    unsafe public partial class PhysicalDeviceDiscardRectanglePropertiesExt : PhysicalDeviceProperties2
    {
        /// <summary>
        /// max number of active discard rectangles
        /// </summary>
        public UInt32 MaxDiscardRectangles
        {
            get { return M->MaxDiscardRectangles; }
            set { M->MaxDiscardRectangles = value; }
        }

        internal new Interop.PhysicalDeviceDiscardRectanglePropertiesExt* M
        {
            get { return (Interop.PhysicalDeviceDiscardRectanglePropertiesExt*)native.Handle; }
        }

        public PhysicalDeviceDiscardRectanglePropertiesExt()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PhysicalDeviceDiscardRectanglePropertiesExt));

            M->SType = StructureType.PhysicalDeviceDiscardRectanglePropertiesExt;
        }

        internal PhysicalDeviceDiscardRectanglePropertiesExt(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PhysicalDeviceDiscardRectanglePropertiesExt;
        }
    }

    unsafe public partial class PipelineDiscardRectangleStateCreateInfoExt : GraphicsPipelineCreateInfo
    {
        public new PipelineDiscardRectangleStateCreateFlagsExt Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        public DiscardRectangleModeExt DiscardRectangleMode
        {
            get { return M->DiscardRectangleMode; }
            set { M->DiscardRectangleMode = value; }
        }

        public UInt32 DiscardRectangleCount
        {
            get { return M->DiscardRectangleCount; }
            set { M->DiscardRectangleCount = value; }
        }

        NativeReference refDiscardRectangles;
        public Rect2D[] DiscardRectangles
        {
            get
            {
                if (M->DiscardRectangleCount == 0)
                    return null;
                var values = new Rect2D[M->DiscardRectangleCount];
                unsafe
                {
                    Rect2D* ptr = (Rect2D*)M->DiscardRectangles;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->DiscardRectangleCount = 0;
                    M->DiscardRectangles = IntPtr.Zero;
                    return;
                }
                M->DiscardRectangleCount = (uint)value.Length;
                refDiscardRectangles = new NativeReference((int)(sizeof(Rect2D) * value.Length));
                M->DiscardRectangles = refDiscardRectangles.Handle;
                unsafe
                {
                    Rect2D* ptr = (Rect2D*)M->DiscardRectangles;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        internal new Interop.PipelineDiscardRectangleStateCreateInfoExt* M
        {
            get { return (Interop.PipelineDiscardRectangleStateCreateInfoExt*)native.Handle; }
        }

        public PipelineDiscardRectangleStateCreateInfoExt()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PipelineDiscardRectangleStateCreateInfoExt));

            M->SType = StructureType.PipelineDiscardRectangleStateCreateInfoExt;
        }

        internal PipelineDiscardRectangleStateCreateInfoExt(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PipelineDiscardRectangleStateCreateInfoExt;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refDiscardRectangles.Dispose();
            refDiscardRectangles = null;
        }
    }

    unsafe public partial class PhysicalDeviceMultiviewPerViewAttributesPropertiesNvx : PhysicalDeviceProperties2
    {
        public bool PerViewPositionAllComponents
        {
            get { return M->PerViewPositionAllComponents; }
            set { M->PerViewPositionAllComponents = value; }
        }

        internal new Interop.PhysicalDeviceMultiviewPerViewAttributesPropertiesNvx* M
        {
            get { return (Interop.PhysicalDeviceMultiviewPerViewAttributesPropertiesNvx*)native.Handle; }
        }

        public PhysicalDeviceMultiviewPerViewAttributesPropertiesNvx()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PhysicalDeviceMultiviewPerViewAttributesPropertiesNvx));

            M->SType = StructureType.PhysicalDeviceMultiviewPerViewAttributesPropertiesNvx;
        }

        internal PhysicalDeviceMultiviewPerViewAttributesPropertiesNvx(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PhysicalDeviceMultiviewPerViewAttributesPropertiesNvx;
        }
    }

    unsafe public partial struct InputAttachmentAspectReference
    {
        public UInt32 Subpass;
        public UInt32 InputAttachmentIndex;
        public ImageAspectFlags AspectMask;
    }

    unsafe public partial class RenderPassInputAttachmentAspectCreateInfo : RenderPassCreateInfo
    {
        public UInt32 AspectReferenceCount
        {
            get { return M->AspectReferenceCount; }
            set { M->AspectReferenceCount = value; }
        }

        NativeReference refAspectReferences;
        public InputAttachmentAspectReference[] AspectReferences
        {
            get
            {
                if (M->AspectReferenceCount == 0)
                    return null;
                var values = new InputAttachmentAspectReference[M->AspectReferenceCount];
                unsafe
                {
                    InputAttachmentAspectReference* ptr = (InputAttachmentAspectReference*)M->AspectReferences;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->AspectReferenceCount = 0;
                    M->AspectReferences = IntPtr.Zero;
                    return;
                }
                M->AspectReferenceCount = (uint)value.Length;
                refAspectReferences = new NativeReference((int)(sizeof(InputAttachmentAspectReference) * value.Length));
                M->AspectReferences = refAspectReferences.Handle;
                unsafe
                {
                    InputAttachmentAspectReference* ptr = (InputAttachmentAspectReference*)M->AspectReferences;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        internal new Interop.RenderPassInputAttachmentAspectCreateInfo* M
        {
            get { return (Interop.RenderPassInputAttachmentAspectCreateInfo*)native.Handle; }
        }

        public RenderPassInputAttachmentAspectCreateInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.RenderPassInputAttachmentAspectCreateInfo));

            M->SType = StructureType.RenderPassInputAttachmentAspectCreateInfo;
        }

        internal RenderPassInputAttachmentAspectCreateInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.RenderPassInputAttachmentAspectCreateInfo;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refAspectReferences.Dispose();
            refAspectReferences = null;
        }
    }

    unsafe public partial class PhysicalDeviceSurfaceInfo2Khr : MarshalledObject
    {
        SurfaceKhr lSurface;
        public SurfaceKhr Surface
        {
            get { return lSurface; }
            set { lSurface = value; M->Surface = value != null ? (UInt64)value.M : default(UInt64); }
        }

        internal Interop.PhysicalDeviceSurfaceInfo2Khr* M
        {
            get { return (Interop.PhysicalDeviceSurfaceInfo2Khr*)native.Handle; }
        }

        public PhysicalDeviceSurfaceInfo2Khr()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PhysicalDeviceSurfaceInfo2Khr));

            M->SType = StructureType.PhysicalDeviceSurfaceInfo2Khr;
        }

        internal PhysicalDeviceSurfaceInfo2Khr(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PhysicalDeviceSurfaceInfo2Khr;
        }
    }

    unsafe public partial class SurfaceCapabilities2Khr : MarshalledObject
    {
        public SurfaceCapabilitiesKhr SurfaceCapabilities
        {
            get { return M->SurfaceCapabilities; }
            set { M->SurfaceCapabilities = value; }
        }

        internal Interop.SurfaceCapabilities2Khr* M
        {
            get { return (Interop.SurfaceCapabilities2Khr*)native.Handle; }
        }

        public SurfaceCapabilities2Khr()
        {
            native = Interop.Structure.Allocate(typeof(Interop.SurfaceCapabilities2Khr));

            M->SType = StructureType.SurfaceCapabilities2Khr;
        }

        internal SurfaceCapabilities2Khr(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.SurfaceCapabilities2Khr;
        }
    }

    unsafe public partial class SurfaceFormat2Khr : MarshalledObject
    {
        public SurfaceFormatKhr SurfaceFormat
        {
            get { return M->SurfaceFormat; }
            set { M->SurfaceFormat = value; }
        }

        internal Interop.SurfaceFormat2Khr* M
        {
            get { return (Interop.SurfaceFormat2Khr*)native.Handle; }
        }

        public SurfaceFormat2Khr()
        {
            native = Interop.Structure.Allocate(typeof(Interop.SurfaceFormat2Khr));

            M->SType = StructureType.SurfaceFormat2Khr;
        }

        internal SurfaceFormat2Khr(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.SurfaceFormat2Khr;
        }
    }

    unsafe public partial class DisplayProperties2Khr : MarshalledObject
    {
        DisplayPropertiesKhr lDisplayProperties;
        public DisplayPropertiesKhr DisplayProperties
        {
            get { return lDisplayProperties; }
            set { lDisplayProperties = value; M->DisplayProperties = value != null ? *value.M : default(Interop.DisplayPropertiesKhr); }
        }

        internal Interop.DisplayProperties2Khr* M
        {
            get { return (Interop.DisplayProperties2Khr*)native.Handle; }
        }

        public DisplayProperties2Khr()
        {
            native = Interop.Structure.Allocate(typeof(Interop.DisplayProperties2Khr));

            M->SType = StructureType.DisplayProperties2Khr;
            lDisplayProperties = new DisplayPropertiesKhr(new NativePointer(native.Reference, (IntPtr)(&M->DisplayProperties)));
        }

        internal DisplayProperties2Khr(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.DisplayProperties2Khr;
            lDisplayProperties = new DisplayPropertiesKhr(new NativePointer(native.Reference, (IntPtr)(&M->DisplayProperties)));
        }
    }

    unsafe public partial class DisplayPlaneProperties2Khr : MarshalledObject
    {
        DisplayPlanePropertiesKhr lDisplayPlaneProperties;
        public DisplayPlanePropertiesKhr DisplayPlaneProperties
        {
            get { return lDisplayPlaneProperties; }
            set { lDisplayPlaneProperties = value; M->DisplayPlaneProperties = value != null ? *value.M : default(Interop.DisplayPlanePropertiesKhr); }
        }

        internal Interop.DisplayPlaneProperties2Khr* M
        {
            get { return (Interop.DisplayPlaneProperties2Khr*)native.Handle; }
        }

        public DisplayPlaneProperties2Khr()
        {
            native = Interop.Structure.Allocate(typeof(Interop.DisplayPlaneProperties2Khr));

            M->SType = StructureType.DisplayPlaneProperties2Khr;
            lDisplayPlaneProperties = new DisplayPlanePropertiesKhr(new NativePointer(native.Reference, (IntPtr)(&M->DisplayPlaneProperties)));
        }

        internal DisplayPlaneProperties2Khr(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.DisplayPlaneProperties2Khr;
            lDisplayPlaneProperties = new DisplayPlanePropertiesKhr(new NativePointer(native.Reference, (IntPtr)(&M->DisplayPlaneProperties)));
        }
    }

    unsafe public partial class DisplayModeProperties2Khr : MarshalledObject
    {
        DisplayModePropertiesKhr lDisplayModeProperties;
        public DisplayModePropertiesKhr DisplayModeProperties
        {
            get { return lDisplayModeProperties; }
            set { lDisplayModeProperties = value; M->DisplayModeProperties = value != null ? *value.M : default(Interop.DisplayModePropertiesKhr); }
        }

        internal Interop.DisplayModeProperties2Khr* M
        {
            get { return (Interop.DisplayModeProperties2Khr*)native.Handle; }
        }

        public DisplayModeProperties2Khr()
        {
            native = Interop.Structure.Allocate(typeof(Interop.DisplayModeProperties2Khr));

            M->SType = StructureType.DisplayModeProperties2Khr;
            lDisplayModeProperties = new DisplayModePropertiesKhr(new NativePointer(native.Reference, (IntPtr)(&M->DisplayModeProperties)));
        }

        internal DisplayModeProperties2Khr(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.DisplayModeProperties2Khr;
            lDisplayModeProperties = new DisplayModePropertiesKhr(new NativePointer(native.Reference, (IntPtr)(&M->DisplayModeProperties)));
        }
    }

    unsafe public partial class DisplayPlaneInfo2Khr : MarshalledObject
    {
        DisplayModeKhr lMode;
        public DisplayModeKhr Mode
        {
            get { return lMode; }
            set { lMode = value; M->Mode = value != null ? (UInt64)value.M : default(UInt64); }
        }

        public UInt32 PlaneIndex
        {
            get { return M->PlaneIndex; }
            set { M->PlaneIndex = value; }
        }

        internal Interop.DisplayPlaneInfo2Khr* M
        {
            get { return (Interop.DisplayPlaneInfo2Khr*)native.Handle; }
        }

        public DisplayPlaneInfo2Khr()
        {
            native = Interop.Structure.Allocate(typeof(Interop.DisplayPlaneInfo2Khr));

            M->SType = StructureType.DisplayPlaneInfo2Khr;
        }

        internal DisplayPlaneInfo2Khr(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.DisplayPlaneInfo2Khr;
        }
    }

    unsafe public partial class DisplayPlaneCapabilities2Khr : MarshalledObject
    {
        public DisplayPlaneCapabilitiesKhr Capabilities
        {
            get { return M->Capabilities; }
            set { M->Capabilities = value; }
        }

        internal Interop.DisplayPlaneCapabilities2Khr* M
        {
            get { return (Interop.DisplayPlaneCapabilities2Khr*)native.Handle; }
        }

        public DisplayPlaneCapabilities2Khr()
        {
            native = Interop.Structure.Allocate(typeof(Interop.DisplayPlaneCapabilities2Khr));

            M->SType = StructureType.DisplayPlaneCapabilities2Khr;
        }

        internal DisplayPlaneCapabilities2Khr(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.DisplayPlaneCapabilities2Khr;
        }
    }

    unsafe public partial class SharedPresentSurfaceCapabilitiesKhr : SurfaceCapabilities2Khr
    {
        /// <summary>
        /// Supported image usage flags if swapchain created using a shared present mode
        /// </summary>
        public ImageUsageFlags SharedPresentSupportedUsageFlags
        {
            get { return M->SharedPresentSupportedUsageFlags; }
            set { M->SharedPresentSupportedUsageFlags = value; }
        }

        internal new Interop.SharedPresentSurfaceCapabilitiesKhr* M
        {
            get { return (Interop.SharedPresentSurfaceCapabilitiesKhr*)native.Handle; }
        }

        public SharedPresentSurfaceCapabilitiesKhr()
        {
            native = Interop.Structure.Allocate(typeof(Interop.SharedPresentSurfaceCapabilitiesKhr));

            M->SType = StructureType.SharedPresentSurfaceCapabilitiesKhr;
        }

        internal SharedPresentSurfaceCapabilitiesKhr(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.SharedPresentSurfaceCapabilitiesKhr;
        }
    }

    unsafe public partial class PhysicalDevice16BitStorageFeatures : PhysicalDeviceFeatures2
    {
        /// <summary>
        /// 16-bit integer/floating-point variables supported in BufferBlock
        /// </summary>
        public bool StorageBuffer16BitAccess
        {
            get { return M->StorageBuffer16BitAccess; }
            set { M->StorageBuffer16BitAccess = value; }
        }

        /// <summary>
        /// 16-bit integer/floating-point variables supported in BufferBlock and Block
        /// </summary>
        public bool UniformAndStorageBuffer16BitAccess
        {
            get { return M->UniformAndStorageBuffer16BitAccess; }
            set { M->UniformAndStorageBuffer16BitAccess = value; }
        }

        /// <summary>
        /// 16-bit integer/floating-point variables supported in PushConstant
        /// </summary>
        public bool StoragePushConstant16
        {
            get { return M->StoragePushConstant16; }
            set { M->StoragePushConstant16 = value; }
        }

        /// <summary>
        /// 16-bit integer/floating-point variables supported in shader inputs and outputs
        /// </summary>
        public bool StorageInputOutput16
        {
            get { return M->StorageInputOutput16; }
            set { M->StorageInputOutput16 = value; }
        }

        internal new Interop.PhysicalDevice16BitStorageFeatures* M
        {
            get { return (Interop.PhysicalDevice16BitStorageFeatures*)native.Handle; }
        }

        public PhysicalDevice16BitStorageFeatures()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PhysicalDevice16BitStorageFeatures));

            M->SType = StructureType.PhysicalDevice16BitStorageFeatures;
        }

        internal PhysicalDevice16BitStorageFeatures(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PhysicalDevice16BitStorageFeatures;
        }
    }

    unsafe public partial class PhysicalDeviceSubgroupProperties : PhysicalDeviceProperties2
    {
        /// <summary>
        /// The size of a subgroup for this queue.
        /// </summary>
        public UInt32 SubgroupSize
        {
            get { return M->SubgroupSize; }
            set { M->SubgroupSize = value; }
        }

        /// <summary>
        /// Bitfield of what shader stages support subgroup operations
        /// </summary>
        public ShaderStageFlags SupportedStages
        {
            get { return M->SupportedStages; }
            set { M->SupportedStages = value; }
        }

        /// <summary>
        /// Bitfield of what subgroup operations are supported.
        /// </summary>
        public SubgroupFeatureFlags SupportedOperations
        {
            get { return M->SupportedOperations; }
            set { M->SupportedOperations = value; }
        }

        /// <summary>
        /// Flag to specify whether quad operations are available in all stages.
        /// </summary>
        public bool QuadOperationsInAllStages
        {
            get { return M->QuadOperationsInAllStages; }
            set { M->QuadOperationsInAllStages = value; }
        }

        internal new Interop.PhysicalDeviceSubgroupProperties* M
        {
            get { return (Interop.PhysicalDeviceSubgroupProperties*)native.Handle; }
        }

        public PhysicalDeviceSubgroupProperties()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PhysicalDeviceSubgroupProperties));

            M->SType = StructureType.PhysicalDeviceSubgroupProperties;
        }

        internal PhysicalDeviceSubgroupProperties(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PhysicalDeviceSubgroupProperties;
        }
    }

    unsafe public partial class BufferMemoryRequirementsInfo2 : MarshalledObject
    {
        Buffer lBuffer;
        public Buffer Buffer
        {
            get { return lBuffer; }
            set { lBuffer = value; M->Buffer = value != null ? (UInt64)value.M : default(UInt64); }
        }

        internal Interop.BufferMemoryRequirementsInfo2* M
        {
            get { return (Interop.BufferMemoryRequirementsInfo2*)native.Handle; }
        }

        public BufferMemoryRequirementsInfo2()
        {
            native = Interop.Structure.Allocate(typeof(Interop.BufferMemoryRequirementsInfo2));

            M->SType = StructureType.BufferMemoryRequirementsInfo2;
        }

        internal BufferMemoryRequirementsInfo2(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.BufferMemoryRequirementsInfo2;
        }
    }

    unsafe public partial class ImageMemoryRequirementsInfo2 : MarshalledObject
    {
        Image lImage;
        public Image Image
        {
            get { return lImage; }
            set { lImage = value; M->Image = value != null ? (UInt64)value.M : default(UInt64); }
        }

        internal Interop.ImageMemoryRequirementsInfo2* M
        {
            get { return (Interop.ImageMemoryRequirementsInfo2*)native.Handle; }
        }

        public ImageMemoryRequirementsInfo2()
        {
            native = Interop.Structure.Allocate(typeof(Interop.ImageMemoryRequirementsInfo2));

            M->SType = StructureType.ImageMemoryRequirementsInfo2;
        }

        internal ImageMemoryRequirementsInfo2(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.ImageMemoryRequirementsInfo2;
        }
    }

    unsafe public partial class ImageSparseMemoryRequirementsInfo2 : MarshalledObject
    {
        Image lImage;
        public Image Image
        {
            get { return lImage; }
            set { lImage = value; M->Image = value != null ? (UInt64)value.M : default(UInt64); }
        }

        internal Interop.ImageSparseMemoryRequirementsInfo2* M
        {
            get { return (Interop.ImageSparseMemoryRequirementsInfo2*)native.Handle; }
        }

        public ImageSparseMemoryRequirementsInfo2()
        {
            native = Interop.Structure.Allocate(typeof(Interop.ImageSparseMemoryRequirementsInfo2));

            M->SType = StructureType.ImageSparseMemoryRequirementsInfo2;
        }

        internal ImageSparseMemoryRequirementsInfo2(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.ImageSparseMemoryRequirementsInfo2;
        }
    }

    unsafe public partial class MemoryRequirements2 : MarshalledObject
    {
        public MemoryRequirements MemoryRequirements
        {
            get { return M->MemoryRequirements; }
            set { M->MemoryRequirements = value; }
        }

        internal Interop.MemoryRequirements2* M
        {
            get { return (Interop.MemoryRequirements2*)native.Handle; }
        }

        public MemoryRequirements2()
        {
            native = Interop.Structure.Allocate(typeof(Interop.MemoryRequirements2));

            M->SType = StructureType.MemoryRequirements2;
        }

        internal MemoryRequirements2(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.MemoryRequirements2;
        }
    }

    unsafe public partial class SparseImageMemoryRequirements2 : MarshalledObject
    {
        public SparseImageMemoryRequirements MemoryRequirements
        {
            get { return M->MemoryRequirements; }
            set { M->MemoryRequirements = value; }
        }

        internal Interop.SparseImageMemoryRequirements2* M
        {
            get { return (Interop.SparseImageMemoryRequirements2*)native.Handle; }
        }

        public SparseImageMemoryRequirements2()
        {
            native = Interop.Structure.Allocate(typeof(Interop.SparseImageMemoryRequirements2));

            M->SType = StructureType.SparseImageMemoryRequirements2;
        }

        internal SparseImageMemoryRequirements2(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.SparseImageMemoryRequirements2;
        }
    }

    unsafe public partial class PhysicalDevicePointClippingProperties : PhysicalDeviceProperties2
    {
        public PointClippingBehavior PointClippingBehavior
        {
            get { return M->PointClippingBehavior; }
            set { M->PointClippingBehavior = value; }
        }

        internal new Interop.PhysicalDevicePointClippingProperties* M
        {
            get { return (Interop.PhysicalDevicePointClippingProperties*)native.Handle; }
        }

        public PhysicalDevicePointClippingProperties()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PhysicalDevicePointClippingProperties));

            M->SType = StructureType.PhysicalDevicePointClippingProperties;
        }

        internal PhysicalDevicePointClippingProperties(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PhysicalDevicePointClippingProperties;
        }
    }

    unsafe public partial class MemoryDedicatedRequirements : MemoryRequirements2
    {
        public bool PrefersDedicatedAllocation
        {
            get { return M->PrefersDedicatedAllocation; }
            set { M->PrefersDedicatedAllocation = value; }
        }

        public bool RequiresDedicatedAllocation
        {
            get { return M->RequiresDedicatedAllocation; }
            set { M->RequiresDedicatedAllocation = value; }
        }

        internal new Interop.MemoryDedicatedRequirements* M
        {
            get { return (Interop.MemoryDedicatedRequirements*)native.Handle; }
        }

        public MemoryDedicatedRequirements()
        {
            native = Interop.Structure.Allocate(typeof(Interop.MemoryDedicatedRequirements));

            M->SType = StructureType.MemoryDedicatedRequirements;
        }

        internal MemoryDedicatedRequirements(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.MemoryDedicatedRequirements;
        }
    }

    unsafe public partial class MemoryDedicatedAllocateInfo : MemoryAllocateInfo
    {
        /// <summary>
        /// Image that this allocation will be bound to
        /// </summary>
        Image lImage;
        public Image Image
        {
            get { return lImage; }
            set { lImage = value; M->Image = value != null ? (UInt64)value.M : default(UInt64); }
        }

        /// <summary>
        /// Buffer that this allocation will be bound to
        /// </summary>
        Buffer lBuffer;
        public Buffer Buffer
        {
            get { return lBuffer; }
            set { lBuffer = value; M->Buffer = value != null ? (UInt64)value.M : default(UInt64); }
        }

        internal new Interop.MemoryDedicatedAllocateInfo* M
        {
            get { return (Interop.MemoryDedicatedAllocateInfo*)native.Handle; }
        }

        public MemoryDedicatedAllocateInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.MemoryDedicatedAllocateInfo));

            M->SType = StructureType.MemoryDedicatedAllocateInfo;
        }

        internal MemoryDedicatedAllocateInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.MemoryDedicatedAllocateInfo;
        }
    }

    unsafe public partial class ImageViewUsageCreateInfo : ImageViewCreateInfo
    {
        public ImageUsageFlags Usage
        {
            get { return M->Usage; }
            set { M->Usage = value; }
        }

        internal new Interop.ImageViewUsageCreateInfo* M
        {
            get { return (Interop.ImageViewUsageCreateInfo*)native.Handle; }
        }

        public ImageViewUsageCreateInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.ImageViewUsageCreateInfo));

            M->SType = StructureType.ImageViewUsageCreateInfo;
        }

        internal ImageViewUsageCreateInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.ImageViewUsageCreateInfo;
        }
    }

    unsafe public partial class PipelineTessellationDomainOriginStateCreateInfo : PipelineTessellationStateCreateInfo
    {
        public TessellationDomainOrigin DomainOrigin
        {
            get { return M->DomainOrigin; }
            set { M->DomainOrigin = value; }
        }

        internal new Interop.PipelineTessellationDomainOriginStateCreateInfo* M
        {
            get { return (Interop.PipelineTessellationDomainOriginStateCreateInfo*)native.Handle; }
        }

        public PipelineTessellationDomainOriginStateCreateInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PipelineTessellationDomainOriginStateCreateInfo));

            M->SType = StructureType.PipelineTessellationDomainOriginStateCreateInfo;
        }

        internal PipelineTessellationDomainOriginStateCreateInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PipelineTessellationDomainOriginStateCreateInfo;
        }
    }

    unsafe public partial class SamplerYcbcrConversionInfo : SamplerCreateInfo
    {
        SamplerYcbcrConversion lConversion;
        public SamplerYcbcrConversion Conversion
        {
            get { return lConversion; }
            set { lConversion = value; M->Conversion = value != null ? (UInt64)value.M : default(UInt64); }
        }

        internal new Interop.SamplerYcbcrConversionInfo* M
        {
            get { return (Interop.SamplerYcbcrConversionInfo*)native.Handle; }
        }

        public SamplerYcbcrConversionInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.SamplerYcbcrConversionInfo));

            M->SType = StructureType.SamplerYcbcrConversionInfo;
        }

        internal SamplerYcbcrConversionInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.SamplerYcbcrConversionInfo;
        }
    }

    unsafe public partial class SamplerYcbcrConversionCreateInfo : MarshalledObject
    {
        public Format Format
        {
            get { return M->Format; }
            set { M->Format = value; }
        }

        public SamplerYcbcrModelConversion YcbcrModel
        {
            get { return M->YcbcrModel; }
            set { M->YcbcrModel = value; }
        }

        public SamplerYcbcrRange YcbcrRange
        {
            get { return M->YcbcrRange; }
            set { M->YcbcrRange = value; }
        }

        public ComponentMapping Components
        {
            get { return M->Components; }
            set { M->Components = value; }
        }

        public ChromaLocation XChromaOffset
        {
            get { return M->XChromaOffset; }
            set { M->XChromaOffset = value; }
        }

        public ChromaLocation YChromaOffset
        {
            get { return M->YChromaOffset; }
            set { M->YChromaOffset = value; }
        }

        public Filter ChromaFilter
        {
            get { return M->ChromaFilter; }
            set { M->ChromaFilter = value; }
        }

        public bool ForceExplicitReconstruction
        {
            get { return M->ForceExplicitReconstruction; }
            set { M->ForceExplicitReconstruction = value; }
        }

        internal Interop.SamplerYcbcrConversionCreateInfo* M
        {
            get { return (Interop.SamplerYcbcrConversionCreateInfo*)native.Handle; }
        }

        public SamplerYcbcrConversionCreateInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.SamplerYcbcrConversionCreateInfo));

            M->SType = StructureType.SamplerYcbcrConversionCreateInfo;
        }

        internal SamplerYcbcrConversionCreateInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.SamplerYcbcrConversionCreateInfo;
        }
    }

    unsafe public partial class BindImagePlaneMemoryInfo : BindImageMemoryInfo
    {
        public ImageAspectFlags PlaneAspect
        {
            get { return M->PlaneAspect; }
            set { M->PlaneAspect = value; }
        }

        internal new Interop.BindImagePlaneMemoryInfo* M
        {
            get { return (Interop.BindImagePlaneMemoryInfo*)native.Handle; }
        }

        public BindImagePlaneMemoryInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.BindImagePlaneMemoryInfo));

            M->SType = StructureType.BindImagePlaneMemoryInfo;
        }

        internal BindImagePlaneMemoryInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.BindImagePlaneMemoryInfo;
        }
    }

    unsafe public partial class ImagePlaneMemoryRequirementsInfo : ImageMemoryRequirementsInfo2
    {
        public ImageAspectFlags PlaneAspect
        {
            get { return M->PlaneAspect; }
            set { M->PlaneAspect = value; }
        }

        internal new Interop.ImagePlaneMemoryRequirementsInfo* M
        {
            get { return (Interop.ImagePlaneMemoryRequirementsInfo*)native.Handle; }
        }

        public ImagePlaneMemoryRequirementsInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.ImagePlaneMemoryRequirementsInfo));

            M->SType = StructureType.ImagePlaneMemoryRequirementsInfo;
        }

        internal ImagePlaneMemoryRequirementsInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.ImagePlaneMemoryRequirementsInfo;
        }
    }

    unsafe public partial class PhysicalDeviceSamplerYcbcrConversionFeatures : PhysicalDeviceFeatures2
    {
        /// <summary>
        /// Sampler color conversion supported
        /// </summary>
        public bool SamplerYcbcrConversion
        {
            get { return M->SamplerYcbcrConversion; }
            set { M->SamplerYcbcrConversion = value; }
        }

        internal new Interop.PhysicalDeviceSamplerYcbcrConversionFeatures* M
        {
            get { return (Interop.PhysicalDeviceSamplerYcbcrConversionFeatures*)native.Handle; }
        }

        public PhysicalDeviceSamplerYcbcrConversionFeatures()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PhysicalDeviceSamplerYcbcrConversionFeatures));

            M->SType = StructureType.PhysicalDeviceSamplerYcbcrConversionFeatures;
        }

        internal PhysicalDeviceSamplerYcbcrConversionFeatures(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PhysicalDeviceSamplerYcbcrConversionFeatures;
        }
    }

    unsafe public partial class SamplerYcbcrConversionImageFormatProperties : ImageFormatProperties2
    {
        public UInt32 CombinedImageSamplerDescriptorCount
        {
            get { return M->CombinedImageSamplerDescriptorCount; }
            set { M->CombinedImageSamplerDescriptorCount = value; }
        }

        internal new Interop.SamplerYcbcrConversionImageFormatProperties* M
        {
            get { return (Interop.SamplerYcbcrConversionImageFormatProperties*)native.Handle; }
        }

        public SamplerYcbcrConversionImageFormatProperties()
        {
            native = Interop.Structure.Allocate(typeof(Interop.SamplerYcbcrConversionImageFormatProperties));

            M->SType = StructureType.SamplerYcbcrConversionImageFormatProperties;
        }

        internal SamplerYcbcrConversionImageFormatProperties(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.SamplerYcbcrConversionImageFormatProperties;
        }
    }

    unsafe public partial class TextureLODGatherFormatPropertiesAmd : ImageFormatProperties2
    {
        public bool SupportsTextureGatherLodbiasAmd
        {
            get { return M->SupportsTextureGatherLodbiasAmd; }
            set { M->SupportsTextureGatherLodbiasAmd = value; }
        }

        internal new Interop.TextureLODGatherFormatPropertiesAmd* M
        {
            get { return (Interop.TextureLODGatherFormatPropertiesAmd*)native.Handle; }
        }

        public TextureLODGatherFormatPropertiesAmd()
        {
            native = Interop.Structure.Allocate(typeof(Interop.TextureLODGatherFormatPropertiesAmd));

            M->SType = StructureType.TextureLODGatherFormatPropertiesAmd;
        }

        internal TextureLODGatherFormatPropertiesAmd(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.TextureLODGatherFormatPropertiesAmd;
        }
    }

    unsafe public partial class ConditionalRenderingBeginInfoExt : MarshalledObject
    {
        Buffer lBuffer;
        public Buffer Buffer
        {
            get { return lBuffer; }
            set { lBuffer = value; M->Buffer = value != null ? (UInt64)value.M : default(UInt64); }
        }

        public DeviceSize Offset
        {
            get { return M->Offset; }
            set { M->Offset = value; }
        }

        public ConditionalRenderingFlagsExt Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        internal Interop.ConditionalRenderingBeginInfoExt* M
        {
            get { return (Interop.ConditionalRenderingBeginInfoExt*)native.Handle; }
        }

        public ConditionalRenderingBeginInfoExt()
        {
            native = Interop.Structure.Allocate(typeof(Interop.ConditionalRenderingBeginInfoExt));

            M->SType = StructureType.ConditionalRenderingBeginInfoExt;
        }

        internal ConditionalRenderingBeginInfoExt(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.ConditionalRenderingBeginInfoExt;
        }
    }

    unsafe public partial class ProtectedSubmitInfo : SubmitInfo
    {
        /// <summary>
        /// Submit protected command buffers
        /// </summary>
        public bool ProtectedSubmit
        {
            get { return M->ProtectedSubmit; }
            set { M->ProtectedSubmit = value; }
        }

        internal new Interop.ProtectedSubmitInfo* M
        {
            get { return (Interop.ProtectedSubmitInfo*)native.Handle; }
        }

        public ProtectedSubmitInfo()
        {
            native = Interop.Structure.Allocate(typeof(Interop.ProtectedSubmitInfo));

            M->SType = StructureType.ProtectedSubmitInfo;
        }

        internal ProtectedSubmitInfo(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.ProtectedSubmitInfo;
        }
    }

    unsafe public partial class PhysicalDeviceProtectedMemoryFeatures : PhysicalDeviceFeatures2
    {
        public bool ProtectedMemory
        {
            get { return M->ProtectedMemory; }
            set { M->ProtectedMemory = value; }
        }

        internal new Interop.PhysicalDeviceProtectedMemoryFeatures* M
        {
            get { return (Interop.PhysicalDeviceProtectedMemoryFeatures*)native.Handle; }
        }

        public PhysicalDeviceProtectedMemoryFeatures()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PhysicalDeviceProtectedMemoryFeatures));

            M->SType = StructureType.PhysicalDeviceProtectedMemoryFeatures;
        }

        internal PhysicalDeviceProtectedMemoryFeatures(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PhysicalDeviceProtectedMemoryFeatures;
        }
    }

    unsafe public partial class PhysicalDeviceProtectedMemoryProperties : PhysicalDeviceProperties2
    {
        public bool ProtectedNoFault
        {
            get { return M->ProtectedNoFault; }
            set { M->ProtectedNoFault = value; }
        }

        internal new Interop.PhysicalDeviceProtectedMemoryProperties* M
        {
            get { return (Interop.PhysicalDeviceProtectedMemoryProperties*)native.Handle; }
        }

        public PhysicalDeviceProtectedMemoryProperties()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PhysicalDeviceProtectedMemoryProperties));

            M->SType = StructureType.PhysicalDeviceProtectedMemoryProperties;
        }

        internal PhysicalDeviceProtectedMemoryProperties(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PhysicalDeviceProtectedMemoryProperties;
        }
    }

    unsafe public partial class DeviceQueueInfo2 : MarshalledObject
    {
        public DeviceQueueCreateFlags Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        public UInt32 QueueFamilyIndex
        {
            get { return M->QueueFamilyIndex; }
            set { M->QueueFamilyIndex = value; }
        }

        public UInt32 QueueIndex
        {
            get { return M->QueueIndex; }
            set { M->QueueIndex = value; }
        }

        internal Interop.DeviceQueueInfo2* M
        {
            get { return (Interop.DeviceQueueInfo2*)native.Handle; }
        }

        public DeviceQueueInfo2()
        {
            native = Interop.Structure.Allocate(typeof(Interop.DeviceQueueInfo2));

            M->SType = StructureType.DeviceQueueInfo2;
        }

        internal DeviceQueueInfo2(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.DeviceQueueInfo2;
        }
    }

    unsafe public partial class PipelineCoverageToColorStateCreateInfoNv : PipelineMultisampleStateCreateInfo
    {
        public new PipelineCoverageToColorStateCreateFlagsNv Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        public bool CoverageToColorEnable
        {
            get { return M->CoverageToColorEnable; }
            set { M->CoverageToColorEnable = value; }
        }

        public UInt32 CoverageToColorLocation
        {
            get { return M->CoverageToColorLocation; }
            set { M->CoverageToColorLocation = value; }
        }

        internal new Interop.PipelineCoverageToColorStateCreateInfoNv* M
        {
            get { return (Interop.PipelineCoverageToColorStateCreateInfoNv*)native.Handle; }
        }

        public PipelineCoverageToColorStateCreateInfoNv()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PipelineCoverageToColorStateCreateInfoNv));

            M->SType = StructureType.PipelineCoverageToColorStateCreateInfoNv;
        }

        internal PipelineCoverageToColorStateCreateInfoNv(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PipelineCoverageToColorStateCreateInfoNv;
        }
    }

    unsafe public partial class PhysicalDeviceSamplerFilterMinmaxPropertiesExt : PhysicalDeviceProperties2
    {
        public bool FilterMinmaxSingleComponentFormats
        {
            get { return M->FilterMinmaxSingleComponentFormats; }
            set { M->FilterMinmaxSingleComponentFormats = value; }
        }

        public bool FilterMinmaxImageComponentMapping
        {
            get { return M->FilterMinmaxImageComponentMapping; }
            set { M->FilterMinmaxImageComponentMapping = value; }
        }

        internal new Interop.PhysicalDeviceSamplerFilterMinmaxPropertiesExt* M
        {
            get { return (Interop.PhysicalDeviceSamplerFilterMinmaxPropertiesExt*)native.Handle; }
        }

        public PhysicalDeviceSamplerFilterMinmaxPropertiesExt()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PhysicalDeviceSamplerFilterMinmaxPropertiesExt));

            M->SType = StructureType.PhysicalDeviceSamplerFilterMinmaxPropertiesExt;
        }

        internal PhysicalDeviceSamplerFilterMinmaxPropertiesExt(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PhysicalDeviceSamplerFilterMinmaxPropertiesExt;
        }
    }

    unsafe public partial struct SampleLocationExt
    {
        public float X;
        public float Y;
    }

    unsafe public partial class SampleLocationsInfoExt : ImageMemoryBarrier
    {
        public SampleCountFlags SampleLocationsPerPixel
        {
            get { return M->SampleLocationsPerPixel; }
            set { M->SampleLocationsPerPixel = value; }
        }

        public Extent2D SampleLocationGridSize
        {
            get { return M->SampleLocationGridSize; }
            set { M->SampleLocationGridSize = value; }
        }

        public UInt32 SampleLocationsCount
        {
            get { return M->SampleLocationsCount; }
            set { M->SampleLocationsCount = value; }
        }

        NativeReference refSampleLocations;
        public SampleLocationExt[] SampleLocations
        {
            get
            {
                if (M->SampleLocationsCount == 0)
                    return null;
                var values = new SampleLocationExt[M->SampleLocationsCount];
                unsafe
                {
                    SampleLocationExt* ptr = (SampleLocationExt*)M->SampleLocations;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->SampleLocationsCount = 0;
                    M->SampleLocations = IntPtr.Zero;
                    return;
                }
                M->SampleLocationsCount = (uint)value.Length;
                refSampleLocations = new NativeReference((int)(sizeof(SampleLocationExt) * value.Length));
                M->SampleLocations = refSampleLocations.Handle;
                unsafe
                {
                    SampleLocationExt* ptr = (SampleLocationExt*)M->SampleLocations;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        internal new Interop.SampleLocationsInfoExt* M
        {
            get { return (Interop.SampleLocationsInfoExt*)native.Handle; }
        }

        public SampleLocationsInfoExt()
        {
            native = Interop.Structure.Allocate(typeof(Interop.SampleLocationsInfoExt));

            M->SType = StructureType.SampleLocationsInfoExt;
        }

        internal SampleLocationsInfoExt(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.SampleLocationsInfoExt;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refSampleLocations.Dispose();
            refSampleLocations = null;
        }
    }

    unsafe public partial class AttachmentSampleLocationsExt : MarshalledObject
    {
        public UInt32 AttachmentIndex
        {
            get { return M->AttachmentIndex; }
            set { M->AttachmentIndex = value; }
        }

        SampleLocationsInfoExt lSampleLocationsInfo;
        public SampleLocationsInfoExt SampleLocationsInfo
        {
            get { return lSampleLocationsInfo; }
            set { lSampleLocationsInfo = value; M->SampleLocationsInfo = value != null ? *value.M : default(Interop.SampleLocationsInfoExt); }
        }

        internal Interop.AttachmentSampleLocationsExt* M
        {
            get { return (Interop.AttachmentSampleLocationsExt*)native.Handle; }
        }

        public AttachmentSampleLocationsExt()
        {
            native = Interop.Structure.Allocate(typeof(Interop.AttachmentSampleLocationsExt));

            lSampleLocationsInfo = new SampleLocationsInfoExt(new NativePointer(native.Reference, (IntPtr)(&M->SampleLocationsInfo)));
        }

        internal AttachmentSampleLocationsExt(NativePointer pointer)
        {
            native = pointer;

            lSampleLocationsInfo = new SampleLocationsInfoExt(new NativePointer(native.Reference, (IntPtr)(&M->SampleLocationsInfo)));
        }
    }

    unsafe public partial class SubpassSampleLocationsExt : MarshalledObject
    {
        public UInt32 SubpassIndex
        {
            get { return M->SubpassIndex; }
            set { M->SubpassIndex = value; }
        }

        SampleLocationsInfoExt lSampleLocationsInfo;
        public SampleLocationsInfoExt SampleLocationsInfo
        {
            get { return lSampleLocationsInfo; }
            set { lSampleLocationsInfo = value; M->SampleLocationsInfo = value != null ? *value.M : default(Interop.SampleLocationsInfoExt); }
        }

        internal Interop.SubpassSampleLocationsExt* M
        {
            get { return (Interop.SubpassSampleLocationsExt*)native.Handle; }
        }

        public SubpassSampleLocationsExt()
        {
            native = Interop.Structure.Allocate(typeof(Interop.SubpassSampleLocationsExt));

            lSampleLocationsInfo = new SampleLocationsInfoExt(new NativePointer(native.Reference, (IntPtr)(&M->SampleLocationsInfo)));
        }

        internal SubpassSampleLocationsExt(NativePointer pointer)
        {
            native = pointer;

            lSampleLocationsInfo = new SampleLocationsInfoExt(new NativePointer(native.Reference, (IntPtr)(&M->SampleLocationsInfo)));
        }
    }

    unsafe public partial class RenderPassSampleLocationsBeginInfoExt : RenderPassBeginInfo
    {
        public UInt32 AttachmentInitialSampleLocationsCount
        {
            get { return M->AttachmentInitialSampleLocationsCount; }
            set { M->AttachmentInitialSampleLocationsCount = value; }
        }

        NativeReference refAttachmentInitialSampleLocations;
        public AttachmentSampleLocationsExt[] AttachmentInitialSampleLocations
        {
            get
            {
                if (M->AttachmentInitialSampleLocationsCount == 0)
                    return null;
                var values = new AttachmentSampleLocationsExt[M->AttachmentInitialSampleLocationsCount];
                unsafe
                {
                    Interop.AttachmentSampleLocationsExt* ptr = (Interop.AttachmentSampleLocationsExt*)M->AttachmentInitialSampleLocations;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = new AttachmentSampleLocationsExt();
                        *values[i].M = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->AttachmentInitialSampleLocationsCount = 0;
                    M->AttachmentInitialSampleLocations = IntPtr.Zero;
                    return;
                }
                M->AttachmentInitialSampleLocationsCount = (uint)value.Length;
                refAttachmentInitialSampleLocations = new NativeReference((int)(sizeof(Interop.AttachmentSampleLocationsExt) * value.Length));
                M->AttachmentInitialSampleLocations = refAttachmentInitialSampleLocations.Handle;
                unsafe
                {
                    Interop.AttachmentSampleLocationsExt* ptr = (Interop.AttachmentSampleLocationsExt*)M->AttachmentInitialSampleLocations;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = *value[i].M;
                    }
                }
            }
        }

        public UInt32 PostSubpassSampleLocationsCount
        {
            get { return M->PostSubpassSampleLocationsCount; }
            set { M->PostSubpassSampleLocationsCount = value; }
        }

        NativeReference refPostSubpassSampleLocations;
        public SubpassSampleLocationsExt[] PostSubpassSampleLocations
        {
            get
            {
                if (M->PostSubpassSampleLocationsCount == 0)
                    return null;
                var values = new SubpassSampleLocationsExt[M->PostSubpassSampleLocationsCount];
                unsafe
                {
                    Interop.SubpassSampleLocationsExt* ptr = (Interop.SubpassSampleLocationsExt*)M->PostSubpassSampleLocations;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = new SubpassSampleLocationsExt();
                        *values[i].M = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->PostSubpassSampleLocationsCount = 0;
                    M->PostSubpassSampleLocations = IntPtr.Zero;
                    return;
                }
                M->PostSubpassSampleLocationsCount = (uint)value.Length;
                refPostSubpassSampleLocations = new NativeReference((int)(sizeof(Interop.SubpassSampleLocationsExt) * value.Length));
                M->PostSubpassSampleLocations = refPostSubpassSampleLocations.Handle;
                unsafe
                {
                    Interop.SubpassSampleLocationsExt* ptr = (Interop.SubpassSampleLocationsExt*)M->PostSubpassSampleLocations;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = *value[i].M;
                    }
                }
            }
        }

        internal new Interop.RenderPassSampleLocationsBeginInfoExt* M
        {
            get { return (Interop.RenderPassSampleLocationsBeginInfoExt*)native.Handle; }
        }

        public RenderPassSampleLocationsBeginInfoExt()
        {
            native = Interop.Structure.Allocate(typeof(Interop.RenderPassSampleLocationsBeginInfoExt));

            M->SType = StructureType.RenderPassSampleLocationsBeginInfoExt;
        }

        internal RenderPassSampleLocationsBeginInfoExt(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.RenderPassSampleLocationsBeginInfoExt;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refAttachmentInitialSampleLocations.Dispose();
            refAttachmentInitialSampleLocations = null;
            refPostSubpassSampleLocations.Dispose();
            refPostSubpassSampleLocations = null;
        }
    }

    unsafe public partial class PipelineSampleLocationsStateCreateInfoExt : PipelineMultisampleStateCreateInfo
    {
        public bool SampleLocationsEnable
        {
            get { return M->SampleLocationsEnable; }
            set { M->SampleLocationsEnable = value; }
        }

        SampleLocationsInfoExt lSampleLocationsInfo;
        public SampleLocationsInfoExt SampleLocationsInfo
        {
            get { return lSampleLocationsInfo; }
            set { lSampleLocationsInfo = value; M->SampleLocationsInfo = value != null ? *value.M : default(Interop.SampleLocationsInfoExt); }
        }

        internal new Interop.PipelineSampleLocationsStateCreateInfoExt* M
        {
            get { return (Interop.PipelineSampleLocationsStateCreateInfoExt*)native.Handle; }
        }

        public PipelineSampleLocationsStateCreateInfoExt()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PipelineSampleLocationsStateCreateInfoExt));

            M->SType = StructureType.PipelineSampleLocationsStateCreateInfoExt;
            lSampleLocationsInfo = new SampleLocationsInfoExt(new NativePointer(native.Reference, (IntPtr)(&M->SampleLocationsInfo)));
        }

        internal PipelineSampleLocationsStateCreateInfoExt(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PipelineSampleLocationsStateCreateInfoExt;
            lSampleLocationsInfo = new SampleLocationsInfoExt(new NativePointer(native.Reference, (IntPtr)(&M->SampleLocationsInfo)));
        }
    }

    unsafe public partial class PhysicalDeviceSampleLocationsPropertiesExt : PhysicalDeviceProperties2
    {
        public SampleCountFlags SampleLocationSampleCounts
        {
            get { return M->SampleLocationSampleCounts; }
            set { M->SampleLocationSampleCounts = value; }
        }

        public Extent2D MaxSampleLocationGridSize
        {
            get { return M->MaxSampleLocationGridSize; }
            set { M->MaxSampleLocationGridSize = value; }
        }

        public float[] SampleLocationCoordinateRange
        {
            get
            {
                var arr = new float[2];
                for (int i = 0; i < 2; i++)
                    arr[i] = M->SampleLocationCoordinateRange[i];
                return arr;
            }
            set
            {
                if (value.Length > 2)
                    throw new Exception("array too long");
                for (int i = 0; i < value.Length; i++)
                    M->SampleLocationCoordinateRange[i] = value[i];
                for (int i = value.Length; i < 2; i++)
                    M->SampleLocationCoordinateRange[i] = 0;
            }
        }

        public UInt32 SampleLocationSubPixelBits
        {
            get { return M->SampleLocationSubPixelBits; }
            set { M->SampleLocationSubPixelBits = value; }
        }

        public bool VariableSampleLocations
        {
            get { return M->VariableSampleLocations; }
            set { M->VariableSampleLocations = value; }
        }

        internal new Interop.PhysicalDeviceSampleLocationsPropertiesExt* M
        {
            get { return (Interop.PhysicalDeviceSampleLocationsPropertiesExt*)native.Handle; }
        }

        public PhysicalDeviceSampleLocationsPropertiesExt()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PhysicalDeviceSampleLocationsPropertiesExt));

            M->SType = StructureType.PhysicalDeviceSampleLocationsPropertiesExt;
        }

        internal PhysicalDeviceSampleLocationsPropertiesExt(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PhysicalDeviceSampleLocationsPropertiesExt;
        }
    }

    unsafe public partial class MultisamplePropertiesExt : MarshalledObject
    {
        public Extent2D MaxSampleLocationGridSize
        {
            get { return M->MaxSampleLocationGridSize; }
            set { M->MaxSampleLocationGridSize = value; }
        }

        internal Interop.MultisamplePropertiesExt* M
        {
            get { return (Interop.MultisamplePropertiesExt*)native.Handle; }
        }

        public MultisamplePropertiesExt()
        {
            native = Interop.Structure.Allocate(typeof(Interop.MultisamplePropertiesExt));

            M->SType = StructureType.MultisamplePropertiesExt;
        }

        internal MultisamplePropertiesExt(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.MultisamplePropertiesExt;
        }
    }

    unsafe public partial class SamplerReductionModeCreateInfoExt : SamplerCreateInfo
    {
        public SamplerReductionModeExt ReductionMode
        {
            get { return M->ReductionMode; }
            set { M->ReductionMode = value; }
        }

        internal new Interop.SamplerReductionModeCreateInfoExt* M
        {
            get { return (Interop.SamplerReductionModeCreateInfoExt*)native.Handle; }
        }

        public SamplerReductionModeCreateInfoExt()
        {
            native = Interop.Structure.Allocate(typeof(Interop.SamplerReductionModeCreateInfoExt));

            M->SType = StructureType.SamplerReductionModeCreateInfoExt;
        }

        internal SamplerReductionModeCreateInfoExt(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.SamplerReductionModeCreateInfoExt;
        }
    }

    unsafe public partial class PhysicalDeviceBlendOperationAdvancedFeaturesExt : PhysicalDeviceFeatures2
    {
        public bool AdvancedBlendCoherentOperations
        {
            get { return M->AdvancedBlendCoherentOperations; }
            set { M->AdvancedBlendCoherentOperations = value; }
        }

        internal new Interop.PhysicalDeviceBlendOperationAdvancedFeaturesExt* M
        {
            get { return (Interop.PhysicalDeviceBlendOperationAdvancedFeaturesExt*)native.Handle; }
        }

        public PhysicalDeviceBlendOperationAdvancedFeaturesExt()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PhysicalDeviceBlendOperationAdvancedFeaturesExt));

            M->SType = StructureType.PhysicalDeviceBlendOperationAdvancedFeaturesExt;
        }

        internal PhysicalDeviceBlendOperationAdvancedFeaturesExt(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PhysicalDeviceBlendOperationAdvancedFeaturesExt;
        }
    }

    unsafe public partial class PhysicalDeviceBlendOperationAdvancedPropertiesExt : PhysicalDeviceProperties2
    {
        public UInt32 AdvancedBlendMaxColorAttachments
        {
            get { return M->AdvancedBlendMaxColorAttachments; }
            set { M->AdvancedBlendMaxColorAttachments = value; }
        }

        public bool AdvancedBlendIndependentBlend
        {
            get { return M->AdvancedBlendIndependentBlend; }
            set { M->AdvancedBlendIndependentBlend = value; }
        }

        public bool AdvancedBlendNonPremultipliedSrcColor
        {
            get { return M->AdvancedBlendNonPremultipliedSrcColor; }
            set { M->AdvancedBlendNonPremultipliedSrcColor = value; }
        }

        public bool AdvancedBlendNonPremultipliedDstColor
        {
            get { return M->AdvancedBlendNonPremultipliedDstColor; }
            set { M->AdvancedBlendNonPremultipliedDstColor = value; }
        }

        public bool AdvancedBlendCorrelatedOverlap
        {
            get { return M->AdvancedBlendCorrelatedOverlap; }
            set { M->AdvancedBlendCorrelatedOverlap = value; }
        }

        public bool AdvancedBlendAllOperations
        {
            get { return M->AdvancedBlendAllOperations; }
            set { M->AdvancedBlendAllOperations = value; }
        }

        internal new Interop.PhysicalDeviceBlendOperationAdvancedPropertiesExt* M
        {
            get { return (Interop.PhysicalDeviceBlendOperationAdvancedPropertiesExt*)native.Handle; }
        }

        public PhysicalDeviceBlendOperationAdvancedPropertiesExt()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PhysicalDeviceBlendOperationAdvancedPropertiesExt));

            M->SType = StructureType.PhysicalDeviceBlendOperationAdvancedPropertiesExt;
        }

        internal PhysicalDeviceBlendOperationAdvancedPropertiesExt(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PhysicalDeviceBlendOperationAdvancedPropertiesExt;
        }
    }

    unsafe public partial class PipelineColorBlendAdvancedStateCreateInfoExt : PipelineColorBlendStateCreateInfo
    {
        public bool SrcPremultiplied
        {
            get { return M->SrcPremultiplied; }
            set { M->SrcPremultiplied = value; }
        }

        public bool DstPremultiplied
        {
            get { return M->DstPremultiplied; }
            set { M->DstPremultiplied = value; }
        }

        public BlendOverlapExt BlendOverlap
        {
            get { return M->BlendOverlap; }
            set { M->BlendOverlap = value; }
        }

        internal new Interop.PipelineColorBlendAdvancedStateCreateInfoExt* M
        {
            get { return (Interop.PipelineColorBlendAdvancedStateCreateInfoExt*)native.Handle; }
        }

        public PipelineColorBlendAdvancedStateCreateInfoExt()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PipelineColorBlendAdvancedStateCreateInfoExt));

            M->SType = StructureType.PipelineColorBlendAdvancedStateCreateInfoExt;
        }

        internal PipelineColorBlendAdvancedStateCreateInfoExt(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PipelineColorBlendAdvancedStateCreateInfoExt;
        }
    }

    unsafe public partial class PhysicalDeviceInlineUniformBlockFeaturesExt : PhysicalDeviceFeatures2
    {
        public bool InlineUniformBlock
        {
            get { return M->InlineUniformBlock; }
            set { M->InlineUniformBlock = value; }
        }

        public bool DescriptorBindingInlineUniformBlockUpdateAfterBind
        {
            get { return M->DescriptorBindingInlineUniformBlockUpdateAfterBind; }
            set { M->DescriptorBindingInlineUniformBlockUpdateAfterBind = value; }
        }

        internal new Interop.PhysicalDeviceInlineUniformBlockFeaturesExt* M
        {
            get { return (Interop.PhysicalDeviceInlineUniformBlockFeaturesExt*)native.Handle; }
        }

        public PhysicalDeviceInlineUniformBlockFeaturesExt()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PhysicalDeviceInlineUniformBlockFeaturesExt));

            M->SType = StructureType.PhysicalDeviceInlineUniformBlockFeaturesExt;
        }

        internal PhysicalDeviceInlineUniformBlockFeaturesExt(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PhysicalDeviceInlineUniformBlockFeaturesExt;
        }
    }

    unsafe public partial class PhysicalDeviceInlineUniformBlockPropertiesExt : PhysicalDeviceProperties2
    {
        public UInt32 MaxInlineUniformBlockSize
        {
            get { return M->MaxInlineUniformBlockSize; }
            set { M->MaxInlineUniformBlockSize = value; }
        }

        public UInt32 MaxPerStageDescriptorInlineUniformBlocks
        {
            get { return M->MaxPerStageDescriptorInlineUniformBlocks; }
            set { M->MaxPerStageDescriptorInlineUniformBlocks = value; }
        }

        public UInt32 MaxPerStageDescriptorUpdateAfterBindInlineUniformBlocks
        {
            get { return M->MaxPerStageDescriptorUpdateAfterBindInlineUniformBlocks; }
            set { M->MaxPerStageDescriptorUpdateAfterBindInlineUniformBlocks = value; }
        }

        public UInt32 MaxDescriptorSetInlineUniformBlocks
        {
            get { return M->MaxDescriptorSetInlineUniformBlocks; }
            set { M->MaxDescriptorSetInlineUniformBlocks = value; }
        }

        public UInt32 MaxDescriptorSetUpdateAfterBindInlineUniformBlocks
        {
            get { return M->MaxDescriptorSetUpdateAfterBindInlineUniformBlocks; }
            set { M->MaxDescriptorSetUpdateAfterBindInlineUniformBlocks = value; }
        }

        internal new Interop.PhysicalDeviceInlineUniformBlockPropertiesExt* M
        {
            get { return (Interop.PhysicalDeviceInlineUniformBlockPropertiesExt*)native.Handle; }
        }

        public PhysicalDeviceInlineUniformBlockPropertiesExt()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PhysicalDeviceInlineUniformBlockPropertiesExt));

            M->SType = StructureType.PhysicalDeviceInlineUniformBlockPropertiesExt;
        }

        internal PhysicalDeviceInlineUniformBlockPropertiesExt(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PhysicalDeviceInlineUniformBlockPropertiesExt;
        }
    }

    unsafe public partial class WriteDescriptorSetInlineUniformBlockExt : WriteDescriptorSet
    {
        public UInt32 DataSize
        {
            get { return M->DataSize; }
            set { M->DataSize = value; }
        }

        public IntPtr Data
        {
            get { return M->Data; }
            set { M->Data = value; }
        }

        internal new Interop.WriteDescriptorSetInlineUniformBlockExt* M
        {
            get { return (Interop.WriteDescriptorSetInlineUniformBlockExt*)native.Handle; }
        }

        public WriteDescriptorSetInlineUniformBlockExt()
        {
            native = Interop.Structure.Allocate(typeof(Interop.WriteDescriptorSetInlineUniformBlockExt));

            M->SType = StructureType.WriteDescriptorSetInlineUniformBlockExt;
        }

        internal WriteDescriptorSetInlineUniformBlockExt(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.WriteDescriptorSetInlineUniformBlockExt;
        }
    }

    unsafe public partial class DescriptorPoolInlineUniformBlockCreateInfoExt : DescriptorPoolCreateInfo
    {
        public UInt32 MaxInlineUniformBlockBindings
        {
            get { return M->MaxInlineUniformBlockBindings; }
            set { M->MaxInlineUniformBlockBindings = value; }
        }

        internal new Interop.DescriptorPoolInlineUniformBlockCreateInfoExt* M
        {
            get { return (Interop.DescriptorPoolInlineUniformBlockCreateInfoExt*)native.Handle; }
        }

        public DescriptorPoolInlineUniformBlockCreateInfoExt()
        {
            native = Interop.Structure.Allocate(typeof(Interop.DescriptorPoolInlineUniformBlockCreateInfoExt));

            M->SType = StructureType.DescriptorPoolInlineUniformBlockCreateInfoExt;
        }

        internal DescriptorPoolInlineUniformBlockCreateInfoExt(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.DescriptorPoolInlineUniformBlockCreateInfoExt;
        }
    }

    unsafe public partial class PipelineCoverageModulationStateCreateInfoNv : PipelineMultisampleStateCreateInfo
    {
        public new PipelineCoverageModulationStateCreateFlagsNv Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        public CoverageModulationModeNv CoverageModulationMode
        {
            get { return M->CoverageModulationMode; }
            set { M->CoverageModulationMode = value; }
        }

        public bool CoverageModulationTableEnable
        {
            get { return M->CoverageModulationTableEnable; }
            set { M->CoverageModulationTableEnable = value; }
        }

        public UInt32 CoverageModulationTableCount
        {
            get { return M->CoverageModulationTableCount; }
            set { M->CoverageModulationTableCount = value; }
        }

        NativeReference refCoverageModulationTable;
        public float[] CoverageModulationTable
        {
            get
            {
                if (M->CoverageModulationTableCount == 0)
                    return null;
                var values = new float[M->CoverageModulationTableCount];
                unsafe
                {
                    float* ptr = (float*)M->CoverageModulationTable;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->CoverageModulationTableCount = 0;
                    M->CoverageModulationTable = IntPtr.Zero;
                    return;
                }
                M->CoverageModulationTableCount = (uint)value.Length;
                refCoverageModulationTable = new NativeReference((int)(sizeof(float) * value.Length));
                M->CoverageModulationTable = refCoverageModulationTable.Handle;
                unsafe
                {
                    float* ptr = (float*)M->CoverageModulationTable;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        internal new Interop.PipelineCoverageModulationStateCreateInfoNv* M
        {
            get { return (Interop.PipelineCoverageModulationStateCreateInfoNv*)native.Handle; }
        }

        public PipelineCoverageModulationStateCreateInfoNv()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PipelineCoverageModulationStateCreateInfoNv));

            M->SType = StructureType.PipelineCoverageModulationStateCreateInfoNv;
        }

        internal PipelineCoverageModulationStateCreateInfoNv(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PipelineCoverageModulationStateCreateInfoNv;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refCoverageModulationTable.Dispose();
            refCoverageModulationTable = null;
        }
    }

    unsafe public partial class ImageFormatListCreateInfoKhr : ImageCreateInfo
    {
        public UInt32 ViewFormatCount
        {
            get { return M->ViewFormatCount; }
            set { M->ViewFormatCount = value; }
        }

        NativeReference refViewFormats;
        public Format[] ViewFormats
        {
            get
            {
                if (M->ViewFormatCount == 0)
                    return null;
                var values = new Format[M->ViewFormatCount];
                unsafe
                {
                    Format* ptr = (Format*)M->ViewFormats;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->ViewFormatCount = 0;
                    M->ViewFormats = IntPtr.Zero;
                    return;
                }
                M->ViewFormatCount = (uint)value.Length;
                refViewFormats = new NativeReference((int)(sizeof(Format) * value.Length));
                M->ViewFormats = refViewFormats.Handle;
                unsafe
                {
                    Format* ptr = (Format*)M->ViewFormats;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        internal new Interop.ImageFormatListCreateInfoKhr* M
        {
            get { return (Interop.ImageFormatListCreateInfoKhr*)native.Handle; }
        }

        public ImageFormatListCreateInfoKhr()
        {
            native = Interop.Structure.Allocate(typeof(Interop.ImageFormatListCreateInfoKhr));

            M->SType = StructureType.ImageFormatListCreateInfoKhr;
        }

        internal ImageFormatListCreateInfoKhr(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.ImageFormatListCreateInfoKhr;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refViewFormats.Dispose();
            refViewFormats = null;
        }
    }

    unsafe public partial class ValidationCacheCreateInfoExt : MarshalledObject
    {
        public ValidationCacheCreateFlagsExt Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        public UIntPtr InitialDataSize
        {
            get { return M->InitialDataSize; }
            set { M->InitialDataSize = value; }
        }

        public IntPtr InitialData
        {
            get { return M->InitialData; }
            set { M->InitialData = value; }
        }

        internal Interop.ValidationCacheCreateInfoExt* M
        {
            get { return (Interop.ValidationCacheCreateInfoExt*)native.Handle; }
        }

        public ValidationCacheCreateInfoExt()
        {
            native = Interop.Structure.Allocate(typeof(Interop.ValidationCacheCreateInfoExt));

            M->SType = StructureType.ValidationCacheCreateInfoExt;
        }

        internal ValidationCacheCreateInfoExt(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.ValidationCacheCreateInfoExt;
        }
    }

    unsafe public partial class ShaderModuleValidationCacheCreateInfoExt : ShaderModuleCreateInfo
    {
        ValidationCacheExt lValidationCache;
        public ValidationCacheExt ValidationCache
        {
            get { return lValidationCache; }
            set { lValidationCache = value; M->ValidationCache = value != null ? (UInt64)value.M : default(UInt64); }
        }

        internal new Interop.ShaderModuleValidationCacheCreateInfoExt* M
        {
            get { return (Interop.ShaderModuleValidationCacheCreateInfoExt*)native.Handle; }
        }

        public ShaderModuleValidationCacheCreateInfoExt()
        {
            native = Interop.Structure.Allocate(typeof(Interop.ShaderModuleValidationCacheCreateInfoExt));

            M->SType = StructureType.ShaderModuleValidationCacheCreateInfoExt;
        }

        internal ShaderModuleValidationCacheCreateInfoExt(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.ShaderModuleValidationCacheCreateInfoExt;
        }
    }

    unsafe public partial class PhysicalDeviceMaintenance3Properties : PhysicalDeviceProperties2
    {
        public UInt32 MaxPerSetDescriptors
        {
            get { return M->MaxPerSetDescriptors; }
            set { M->MaxPerSetDescriptors = value; }
        }

        public DeviceSize MaxMemoryAllocationSize
        {
            get { return M->MaxMemoryAllocationSize; }
            set { M->MaxMemoryAllocationSize = value; }
        }

        internal new Interop.PhysicalDeviceMaintenance3Properties* M
        {
            get { return (Interop.PhysicalDeviceMaintenance3Properties*)native.Handle; }
        }

        public PhysicalDeviceMaintenance3Properties()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PhysicalDeviceMaintenance3Properties));

            M->SType = StructureType.PhysicalDeviceMaintenance3Properties;
        }

        internal PhysicalDeviceMaintenance3Properties(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PhysicalDeviceMaintenance3Properties;
        }
    }

    unsafe public partial class DescriptorSetLayoutSupport : MarshalledObject
    {
        public bool Supported
        {
            get { return M->Supported; }
            set { M->Supported = value; }
        }

        internal Interop.DescriptorSetLayoutSupport* M
        {
            get { return (Interop.DescriptorSetLayoutSupport*)native.Handle; }
        }

        public DescriptorSetLayoutSupport()
        {
            native = Interop.Structure.Allocate(typeof(Interop.DescriptorSetLayoutSupport));

            M->SType = StructureType.DescriptorSetLayoutSupport;
        }

        internal DescriptorSetLayoutSupport(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.DescriptorSetLayoutSupport;
        }
    }

    unsafe public partial class PhysicalDeviceShaderDrawParameterFeatures : PhysicalDeviceFeatures2
    {
        public bool ShaderDrawParameters
        {
            get { return M->ShaderDrawParameters; }
            set { M->ShaderDrawParameters = value; }
        }

        internal new Interop.PhysicalDeviceShaderDrawParameterFeatures* M
        {
            get { return (Interop.PhysicalDeviceShaderDrawParameterFeatures*)native.Handle; }
        }

        public PhysicalDeviceShaderDrawParameterFeatures()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PhysicalDeviceShaderDrawParameterFeatures));

            M->SType = StructureType.PhysicalDeviceShaderDrawParameterFeatures;
        }

        internal PhysicalDeviceShaderDrawParameterFeatures(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PhysicalDeviceShaderDrawParameterFeatures;
        }
    }

    unsafe public partial struct ShaderResourceUsageAmd
    {
        public UInt32 NumUsedVgprs;
        public UInt32 NumUsedSgprs;
        public UInt32 LdsSizePerLocalWorkGroup;
        public UIntPtr LdsUsageSizeInBytes;
        public UIntPtr ScratchMemUsageInBytes;
    }

    unsafe public partial class ShaderStatisticsInfoAmd : MarshalledObject
    {
        public ShaderStageFlags ShaderStageMask
        {
            get { return M->ShaderStageMask; }
            set { M->ShaderStageMask = value; }
        }

        public ShaderResourceUsageAmd ResourceUsage
        {
            get { return M->ResourceUsage; }
            set { M->ResourceUsage = value; }
        }

        public UInt32 NumPhysicalVgprs
        {
            get { return M->NumPhysicalVgprs; }
            set { M->NumPhysicalVgprs = value; }
        }

        public UInt32 NumPhysicalSgprs
        {
            get { return M->NumPhysicalSgprs; }
            set { M->NumPhysicalSgprs = value; }
        }

        public UInt32 NumAvailableVgprs
        {
            get { return M->NumAvailableVgprs; }
            set { M->NumAvailableVgprs = value; }
        }

        public UInt32 NumAvailableSgprs
        {
            get { return M->NumAvailableSgprs; }
            set { M->NumAvailableSgprs = value; }
        }

        public UInt32[] ComputeWorkGroupSize
        {
            get
            {
                var arr = new UInt32[3];
                for (int i = 0; i < 3; i++)
                    arr[i] = M->ComputeWorkGroupSize[i];
                return arr;
            }
            set
            {
                if (value.Length > 3)
                    throw new Exception("array too long");
                for (int i = 0; i < value.Length; i++)
                    M->ComputeWorkGroupSize[i] = value[i];
                for (int i = value.Length; i < 3; i++)
                    M->ComputeWorkGroupSize[i] = 0;
            }
        }

        internal Interop.ShaderStatisticsInfoAmd* M
        {
            get { return (Interop.ShaderStatisticsInfoAmd*)native.Handle; }
        }

        public ShaderStatisticsInfoAmd()
        {
            native = Interop.Structure.Allocate(typeof(Interop.ShaderStatisticsInfoAmd));
        }

        internal ShaderStatisticsInfoAmd(NativePointer pointer)
        {
            native = pointer;
        }
    }

    unsafe public partial class DeviceQueueGlobalPriorityCreateInfoExt : DeviceQueueCreateInfo
    {
        public QueueGlobalPriorityExt GlobalPriority
        {
            get { return M->GlobalPriority; }
            set { M->GlobalPriority = value; }
        }

        internal new Interop.DeviceQueueGlobalPriorityCreateInfoExt* M
        {
            get { return (Interop.DeviceQueueGlobalPriorityCreateInfoExt*)native.Handle; }
        }

        public DeviceQueueGlobalPriorityCreateInfoExt()
        {
            native = Interop.Structure.Allocate(typeof(Interop.DeviceQueueGlobalPriorityCreateInfoExt));

            M->SType = StructureType.DeviceQueueGlobalPriorityCreateInfoExt;
        }

        internal DeviceQueueGlobalPriorityCreateInfoExt(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.DeviceQueueGlobalPriorityCreateInfoExt;
        }
    }

    unsafe public partial class DebugUtilsObjectNameInfoExt : MarshalledObject
    {
        public ObjectType ObjectType
        {
            get { return M->ObjectType; }
            set { M->ObjectType = value; }
        }

        public UInt64 ObjectHandle
        {
            get { return M->ObjectHandle; }
            set { M->ObjectHandle = value; }
        }

        public string ObjectName
        {
            get { return Marshal.PtrToStringAnsi(M->ObjectName); }
            set { M->ObjectName = Marshal.StringToHGlobalAnsi(value); }
        }

        internal Interop.DebugUtilsObjectNameInfoExt* M
        {
            get { return (Interop.DebugUtilsObjectNameInfoExt*)native.Handle; }
        }

        public DebugUtilsObjectNameInfoExt()
        {
            native = Interop.Structure.Allocate(typeof(Interop.DebugUtilsObjectNameInfoExt));

            M->SType = StructureType.DebugUtilsObjectNameInfoExt;
        }

        internal DebugUtilsObjectNameInfoExt(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.DebugUtilsObjectNameInfoExt;
        }
    }

    unsafe public partial class DebugUtilsObjectTagInfoExt : MarshalledObject
    {
        public ObjectType ObjectType
        {
            get { return M->ObjectType; }
            set { M->ObjectType = value; }
        }

        public UInt64 ObjectHandle
        {
            get { return M->ObjectHandle; }
            set { M->ObjectHandle = value; }
        }

        public UInt64 TagName
        {
            get { return M->TagName; }
            set { M->TagName = value; }
        }

        public UIntPtr TagSize
        {
            get { return M->TagSize; }
            set { M->TagSize = value; }
        }

        public IntPtr Tag
        {
            get { return M->Tag; }
            set { M->Tag = value; }
        }

        internal Interop.DebugUtilsObjectTagInfoExt* M
        {
            get { return (Interop.DebugUtilsObjectTagInfoExt*)native.Handle; }
        }

        public DebugUtilsObjectTagInfoExt()
        {
            native = Interop.Structure.Allocate(typeof(Interop.DebugUtilsObjectTagInfoExt));

            M->SType = StructureType.DebugUtilsObjectTagInfoExt;
        }

        internal DebugUtilsObjectTagInfoExt(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.DebugUtilsObjectTagInfoExt;
        }
    }

    unsafe public partial class DebugUtilsLabelExt : MarshalledObject
    {
        public string LabelName
        {
            get { return Marshal.PtrToStringAnsi(M->LabelName); }
            set { M->LabelName = Marshal.StringToHGlobalAnsi(value); }
        }

        public float[] Color
        {
            get
            {
                var arr = new float[4];
                for (int i = 0; i < 4; i++)
                    arr[i] = M->Color[i];
                return arr;
            }
            set
            {
                if (value.Length > 4)
                    throw new Exception("array too long");
                for (int i = 0; i < value.Length; i++)
                    M->Color[i] = value[i];
                for (int i = value.Length; i < 4; i++)
                    M->Color[i] = 0;
            }
        }

        internal Interop.DebugUtilsLabelExt* M
        {
            get { return (Interop.DebugUtilsLabelExt*)native.Handle; }
        }

        public DebugUtilsLabelExt()
        {
            native = Interop.Structure.Allocate(typeof(Interop.DebugUtilsLabelExt));

            M->SType = StructureType.DebugUtilsLabelExt;
        }

        internal DebugUtilsLabelExt(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.DebugUtilsLabelExt;
        }
    }

    unsafe public partial class DebugUtilsMessengerCreateInfoExt : InstanceCreateInfo
    {
        public new DebugUtilsMessengerCreateFlagsExt Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        public DebugUtilsMessageSeverityFlagsExt MessageSeverity
        {
            get { return M->MessageSeverity; }
            set { M->MessageSeverity = value; }
        }

        public DebugUtilsMessageTypeFlagsExt MessageType
        {
            get { return M->MessageType; }
            set { M->MessageType = value; }
        }

        public IntPtr PfnUserCallback
        {
            get { return M->PfnUserCallback; }
            set { M->PfnUserCallback = value; }
        }

        public IntPtr UserData
        {
            get { return M->UserData; }
            set { M->UserData = value; }
        }

        internal new Interop.DebugUtilsMessengerCreateInfoExt* M
        {
            get { return (Interop.DebugUtilsMessengerCreateInfoExt*)native.Handle; }
        }

        public DebugUtilsMessengerCreateInfoExt()
        {
            native = Interop.Structure.Allocate(typeof(Interop.DebugUtilsMessengerCreateInfoExt));

            M->SType = StructureType.DebugUtilsMessengerCreateInfoExt;
        }

        internal DebugUtilsMessengerCreateInfoExt(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.DebugUtilsMessengerCreateInfoExt;
        }
    }

    unsafe public partial class DebugUtilsMessengerCallbackDataExt : MarshalledObject
    {
        public DebugUtilsMessengerCallbackDataFlagsExt Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        public string MessageIdName
        {
            get { return Marshal.PtrToStringAnsi(M->MessageIdName); }
            set { M->MessageIdName = Marshal.StringToHGlobalAnsi(value); }
        }

        public Int32 MessageIdNumber
        {
            get { return M->MessageIdNumber; }
            set { M->MessageIdNumber = value; }
        }

        public string Message
        {
            get { return Marshal.PtrToStringAnsi(M->Message); }
            set { M->Message = Marshal.StringToHGlobalAnsi(value); }
        }

        public UInt32 QueueLabelCount
        {
            get { return M->QueueLabelCount; }
            set { M->QueueLabelCount = value; }
        }

        NativeReference refQueueLabels;
        public DebugUtilsLabelExt[] QueueLabels
        {
            get
            {
                if (M->QueueLabelCount == 0)
                    return null;
                var values = new DebugUtilsLabelExt[M->QueueLabelCount];
                unsafe
                {
                    Interop.DebugUtilsLabelExt* ptr = (Interop.DebugUtilsLabelExt*)M->QueueLabels;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = new DebugUtilsLabelExt();
                        *values[i].M = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->QueueLabelCount = 0;
                    M->QueueLabels = IntPtr.Zero;
                    return;
                }
                M->QueueLabelCount = (uint)value.Length;
                refQueueLabels = new NativeReference((int)(sizeof(Interop.DebugUtilsLabelExt) * value.Length));
                M->QueueLabels = refQueueLabels.Handle;
                unsafe
                {
                    Interop.DebugUtilsLabelExt* ptr = (Interop.DebugUtilsLabelExt*)M->QueueLabels;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = *value[i].M;
                    }
                }
            }
        }

        public UInt32 CmdBufLabelCount
        {
            get { return M->CmdBufLabelCount; }
            set { M->CmdBufLabelCount = value; }
        }

        NativeReference refCmdBufLabels;
        public DebugUtilsLabelExt[] CmdBufLabels
        {
            get
            {
                if (M->CmdBufLabelCount == 0)
                    return null;
                var values = new DebugUtilsLabelExt[M->CmdBufLabelCount];
                unsafe
                {
                    Interop.DebugUtilsLabelExt* ptr = (Interop.DebugUtilsLabelExt*)M->CmdBufLabels;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = new DebugUtilsLabelExt();
                        *values[i].M = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->CmdBufLabelCount = 0;
                    M->CmdBufLabels = IntPtr.Zero;
                    return;
                }
                M->CmdBufLabelCount = (uint)value.Length;
                refCmdBufLabels = new NativeReference((int)(sizeof(Interop.DebugUtilsLabelExt) * value.Length));
                M->CmdBufLabels = refCmdBufLabels.Handle;
                unsafe
                {
                    Interop.DebugUtilsLabelExt* ptr = (Interop.DebugUtilsLabelExt*)M->CmdBufLabels;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = *value[i].M;
                    }
                }
            }
        }

        public UInt32 ObjectCount
        {
            get { return M->ObjectCount; }
            set { M->ObjectCount = value; }
        }

        NativeReference refObjects;
        public DebugUtilsObjectNameInfoExt[] Objects
        {
            get
            {
                if (M->ObjectCount == 0)
                    return null;
                var values = new DebugUtilsObjectNameInfoExt[M->ObjectCount];
                unsafe
                {
                    Interop.DebugUtilsObjectNameInfoExt* ptr = (Interop.DebugUtilsObjectNameInfoExt*)M->Objects;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = new DebugUtilsObjectNameInfoExt();
                        *values[i].M = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->ObjectCount = 0;
                    M->Objects = IntPtr.Zero;
                    return;
                }
                M->ObjectCount = (uint)value.Length;
                refObjects = new NativeReference((int)(sizeof(Interop.DebugUtilsObjectNameInfoExt) * value.Length));
                M->Objects = refObjects.Handle;
                unsafe
                {
                    Interop.DebugUtilsObjectNameInfoExt* ptr = (Interop.DebugUtilsObjectNameInfoExt*)M->Objects;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = *value[i].M;
                    }
                }
            }
        }

        internal Interop.DebugUtilsMessengerCallbackDataExt* M
        {
            get { return (Interop.DebugUtilsMessengerCallbackDataExt*)native.Handle; }
        }

        public DebugUtilsMessengerCallbackDataExt()
        {
            native = Interop.Structure.Allocate(typeof(Interop.DebugUtilsMessengerCallbackDataExt));

            M->SType = StructureType.DebugUtilsMessengerCallbackDataExt;
        }

        internal DebugUtilsMessengerCallbackDataExt(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.DebugUtilsMessengerCallbackDataExt;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refQueueLabels.Dispose();
            refQueueLabels = null;
            refCmdBufLabels.Dispose();
            refCmdBufLabels = null;
            refObjects.Dispose();
            refObjects = null;
        }
    }

    unsafe public partial class ImportMemoryHostPointerInfoExt : MemoryAllocateInfo
    {
        public ExternalMemoryHandleTypeFlags HandleType
        {
            get { return M->HandleType; }
            set { M->HandleType = value; }
        }

        public IntPtr HostPointer
        {
            get { return M->HostPointer; }
            set { M->HostPointer = value; }
        }

        internal new Interop.ImportMemoryHostPointerInfoExt* M
        {
            get { return (Interop.ImportMemoryHostPointerInfoExt*)native.Handle; }
        }

        public ImportMemoryHostPointerInfoExt()
        {
            native = Interop.Structure.Allocate(typeof(Interop.ImportMemoryHostPointerInfoExt));

            M->SType = StructureType.ImportMemoryHostPointerInfoExt;
        }

        internal ImportMemoryHostPointerInfoExt(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.ImportMemoryHostPointerInfoExt;
        }
    }

    unsafe public partial class MemoryHostPointerPropertiesExt : MarshalledObject
    {
        public UInt32 MemoryTypeBits
        {
            get { return M->MemoryTypeBits; }
            set { M->MemoryTypeBits = value; }
        }

        internal Interop.MemoryHostPointerPropertiesExt* M
        {
            get { return (Interop.MemoryHostPointerPropertiesExt*)native.Handle; }
        }

        public MemoryHostPointerPropertiesExt()
        {
            native = Interop.Structure.Allocate(typeof(Interop.MemoryHostPointerPropertiesExt));

            M->SType = StructureType.MemoryHostPointerPropertiesExt;
        }

        internal MemoryHostPointerPropertiesExt(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.MemoryHostPointerPropertiesExt;
        }
    }

    unsafe public partial class PhysicalDeviceExternalMemoryHostPropertiesExt : PhysicalDeviceProperties2
    {
        public DeviceSize MinImportedHostPointerAlignment
        {
            get { return M->MinImportedHostPointerAlignment; }
            set { M->MinImportedHostPointerAlignment = value; }
        }

        internal new Interop.PhysicalDeviceExternalMemoryHostPropertiesExt* M
        {
            get { return (Interop.PhysicalDeviceExternalMemoryHostPropertiesExt*)native.Handle; }
        }

        public PhysicalDeviceExternalMemoryHostPropertiesExt()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PhysicalDeviceExternalMemoryHostPropertiesExt));

            M->SType = StructureType.PhysicalDeviceExternalMemoryHostPropertiesExt;
        }

        internal PhysicalDeviceExternalMemoryHostPropertiesExt(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PhysicalDeviceExternalMemoryHostPropertiesExt;
        }
    }

    unsafe public partial class PhysicalDeviceConservativeRasterizationPropertiesExt : PhysicalDeviceProperties2
    {
        /// <summary>
        /// The size in pixels the primitive is enlarged at each edge during conservative rasterization
        /// </summary>
        public float PrimitiveOverestimationSize
        {
            get { return M->PrimitiveOverestimationSize; }
            set { M->PrimitiveOverestimationSize = value; }
        }

        /// <summary>
        /// The maximum additional overestimation the client can specify in the pipeline state
        /// </summary>
        public float MaxExtraPrimitiveOverestimationSize
        {
            get { return M->MaxExtraPrimitiveOverestimationSize; }
            set { M->MaxExtraPrimitiveOverestimationSize = value; }
        }

        /// <summary>
        /// The granularity of extra overestimation sizes the implementations supports between 0 and maxExtraOverestimationSize
        /// </summary>
        public float ExtraPrimitiveOverestimationSizeGranularity
        {
            get { return M->ExtraPrimitiveOverestimationSizeGranularity; }
            set { M->ExtraPrimitiveOverestimationSizeGranularity = value; }
        }

        /// <summary>
        /// true if the implementation supports conservative rasterization underestimation mode
        /// </summary>
        public bool PrimitiveUnderestimation
        {
            get { return M->PrimitiveUnderestimation; }
            set { M->PrimitiveUnderestimation = value; }
        }

        /// <summary>
        /// true if conservative rasterization also applies to points and lines
        /// </summary>
        public bool ConservativePointAndLineRasterization
        {
            get { return M->ConservativePointAndLineRasterization; }
            set { M->ConservativePointAndLineRasterization = value; }
        }

        /// <summary>
        /// true if degenerate triangles(those with zero area after snap) are rasterized
        /// </summary>
        public bool DegenerateTrianglesRasterized
        {
            get { return M->DegenerateTrianglesRasterized; }
            set { M->DegenerateTrianglesRasterized = value; }
        }

        /// <summary>
        /// true if degenerate lines(those with zero length after snap) are rasterized
        /// </summary>
        public bool DegenerateLinesRasterized
        {
            get { return M->DegenerateLinesRasterized; }
            set { M->DegenerateLinesRasterized = value; }
        }

        /// <summary>
        /// true if the implementation supports the FullyCoveredEXT SPIR-V builtin fragment shader input variable
        /// </summary>
        public bool FullyCoveredFragmentShaderInputVariable
        {
            get { return M->FullyCoveredFragmentShaderInputVariable; }
            set { M->FullyCoveredFragmentShaderInputVariable = value; }
        }

        /// <summary>
        /// true if the implementation supports both conservative rasterization and post depth coverage sample coverage mask
        /// </summary>
        public bool ConservativeRasterizationPostDepthCoverage
        {
            get { return M->ConservativeRasterizationPostDepthCoverage; }
            set { M->ConservativeRasterizationPostDepthCoverage = value; }
        }

        internal new Interop.PhysicalDeviceConservativeRasterizationPropertiesExt* M
        {
            get { return (Interop.PhysicalDeviceConservativeRasterizationPropertiesExt*)native.Handle; }
        }

        public PhysicalDeviceConservativeRasterizationPropertiesExt()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PhysicalDeviceConservativeRasterizationPropertiesExt));

            M->SType = StructureType.PhysicalDeviceConservativeRasterizationPropertiesExt;
        }

        internal PhysicalDeviceConservativeRasterizationPropertiesExt(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PhysicalDeviceConservativeRasterizationPropertiesExt;
        }
    }

    unsafe public partial class PhysicalDeviceShaderCorePropertiesAmd : PhysicalDeviceProperties2
    {
        /// <summary>
        /// number of shader engines
        /// </summary>
        public UInt32 ShaderEngineCount
        {
            get { return M->ShaderEngineCount; }
            set { M->ShaderEngineCount = value; }
        }

        /// <summary>
        /// number of shader arrays
        /// </summary>
        public UInt32 ShaderArraysPerEngineCount
        {
            get { return M->ShaderArraysPerEngineCount; }
            set { M->ShaderArraysPerEngineCount = value; }
        }

        /// <summary>
        /// number of CUs per shader array
        /// </summary>
        public UInt32 ComputeUnitsPerShaderArray
        {
            get { return M->ComputeUnitsPerShaderArray; }
            set { M->ComputeUnitsPerShaderArray = value; }
        }

        /// <summary>
        /// number of SIMDs per compute unit
        /// </summary>
        public UInt32 SimdPerComputeUnit
        {
            get { return M->SimdPerComputeUnit; }
            set { M->SimdPerComputeUnit = value; }
        }

        /// <summary>
        /// number of wavefront slots in each SIMD
        /// </summary>
        public UInt32 WavefrontsPerSimd
        {
            get { return M->WavefrontsPerSimd; }
            set { M->WavefrontsPerSimd = value; }
        }

        /// <summary>
        /// number of threads per wavefront
        /// </summary>
        public UInt32 WavefrontSize
        {
            get { return M->WavefrontSize; }
            set { M->WavefrontSize = value; }
        }

        /// <summary>
        /// number of physical SGPRs per SIMD
        /// </summary>
        public UInt32 SgprsPerSimd
        {
            get { return M->SgprsPerSimd; }
            set { M->SgprsPerSimd = value; }
        }

        /// <summary>
        /// minimum number of SGPRs that can be allocated by a wave
        /// </summary>
        public UInt32 MinSgprAllocation
        {
            get { return M->MinSgprAllocation; }
            set { M->MinSgprAllocation = value; }
        }

        /// <summary>
        /// number of available SGPRs
        /// </summary>
        public UInt32 MaxSgprAllocation
        {
            get { return M->MaxSgprAllocation; }
            set { M->MaxSgprAllocation = value; }
        }

        /// <summary>
        /// SGPRs are allocated in groups of this size
        /// </summary>
        public UInt32 SgprAllocationGranularity
        {
            get { return M->SgprAllocationGranularity; }
            set { M->SgprAllocationGranularity = value; }
        }

        /// <summary>
        /// number of physical VGPRs per SIMD
        /// </summary>
        public UInt32 VgprsPerSimd
        {
            get { return M->VgprsPerSimd; }
            set { M->VgprsPerSimd = value; }
        }

        /// <summary>
        /// minimum number of VGPRs that can be allocated by a wave
        /// </summary>
        public UInt32 MinVgprAllocation
        {
            get { return M->MinVgprAllocation; }
            set { M->MinVgprAllocation = value; }
        }

        /// <summary>
        /// number of available VGPRs
        /// </summary>
        public UInt32 MaxVgprAllocation
        {
            get { return M->MaxVgprAllocation; }
            set { M->MaxVgprAllocation = value; }
        }

        /// <summary>
        /// VGPRs are allocated in groups of this size
        /// </summary>
        public UInt32 VgprAllocationGranularity
        {
            get { return M->VgprAllocationGranularity; }
            set { M->VgprAllocationGranularity = value; }
        }

        internal new Interop.PhysicalDeviceShaderCorePropertiesAmd* M
        {
            get { return (Interop.PhysicalDeviceShaderCorePropertiesAmd*)native.Handle; }
        }

        public PhysicalDeviceShaderCorePropertiesAmd()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PhysicalDeviceShaderCorePropertiesAmd));

            M->SType = StructureType.PhysicalDeviceShaderCorePropertiesAmd;
        }

        internal PhysicalDeviceShaderCorePropertiesAmd(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PhysicalDeviceShaderCorePropertiesAmd;
        }
    }

    unsafe public partial class PipelineRasterizationConservativeStateCreateInfoExt : PipelineRasterizationStateCreateInfo
    {
        public new PipelineRasterizationConservativeStateCreateFlagsExt Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        public ConservativeRasterizationModeExt ConservativeRasterizationMode
        {
            get { return M->ConservativeRasterizationMode; }
            set { M->ConservativeRasterizationMode = value; }
        }

        public float ExtraPrimitiveOverestimationSize
        {
            get { return M->ExtraPrimitiveOverestimationSize; }
            set { M->ExtraPrimitiveOverestimationSize = value; }
        }

        internal new Interop.PipelineRasterizationConservativeStateCreateInfoExt* M
        {
            get { return (Interop.PipelineRasterizationConservativeStateCreateInfoExt*)native.Handle; }
        }

        public PipelineRasterizationConservativeStateCreateInfoExt()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PipelineRasterizationConservativeStateCreateInfoExt));

            M->SType = StructureType.PipelineRasterizationConservativeStateCreateInfoExt;
        }

        internal PipelineRasterizationConservativeStateCreateInfoExt(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PipelineRasterizationConservativeStateCreateInfoExt;
        }
    }

    unsafe public partial class PhysicalDeviceDescriptorIndexingFeaturesExt : PhysicalDeviceFeatures2
    {
        public bool ShaderInputAttachmentArrayDynamicIndexing
        {
            get { return M->ShaderInputAttachmentArrayDynamicIndexing; }
            set { M->ShaderInputAttachmentArrayDynamicIndexing = value; }
        }

        public bool ShaderUniformTexelBufferArrayDynamicIndexing
        {
            get { return M->ShaderUniformTexelBufferArrayDynamicIndexing; }
            set { M->ShaderUniformTexelBufferArrayDynamicIndexing = value; }
        }

        public bool ShaderStorageTexelBufferArrayDynamicIndexing
        {
            get { return M->ShaderStorageTexelBufferArrayDynamicIndexing; }
            set { M->ShaderStorageTexelBufferArrayDynamicIndexing = value; }
        }

        public bool ShaderUniformBufferArrayNonUniformIndexing
        {
            get { return M->ShaderUniformBufferArrayNonUniformIndexing; }
            set { M->ShaderUniformBufferArrayNonUniformIndexing = value; }
        }

        public bool ShaderSampledImageArrayNonUniformIndexing
        {
            get { return M->ShaderSampledImageArrayNonUniformIndexing; }
            set { M->ShaderSampledImageArrayNonUniformIndexing = value; }
        }

        public bool ShaderStorageBufferArrayNonUniformIndexing
        {
            get { return M->ShaderStorageBufferArrayNonUniformIndexing; }
            set { M->ShaderStorageBufferArrayNonUniformIndexing = value; }
        }

        public bool ShaderStorageImageArrayNonUniformIndexing
        {
            get { return M->ShaderStorageImageArrayNonUniformIndexing; }
            set { M->ShaderStorageImageArrayNonUniformIndexing = value; }
        }

        public bool ShaderInputAttachmentArrayNonUniformIndexing
        {
            get { return M->ShaderInputAttachmentArrayNonUniformIndexing; }
            set { M->ShaderInputAttachmentArrayNonUniformIndexing = value; }
        }

        public bool ShaderUniformTexelBufferArrayNonUniformIndexing
        {
            get { return M->ShaderUniformTexelBufferArrayNonUniformIndexing; }
            set { M->ShaderUniformTexelBufferArrayNonUniformIndexing = value; }
        }

        public bool ShaderStorageTexelBufferArrayNonUniformIndexing
        {
            get { return M->ShaderStorageTexelBufferArrayNonUniformIndexing; }
            set { M->ShaderStorageTexelBufferArrayNonUniformIndexing = value; }
        }

        public bool DescriptorBindingUniformBufferUpdateAfterBind
        {
            get { return M->DescriptorBindingUniformBufferUpdateAfterBind; }
            set { M->DescriptorBindingUniformBufferUpdateAfterBind = value; }
        }

        public bool DescriptorBindingSampledImageUpdateAfterBind
        {
            get { return M->DescriptorBindingSampledImageUpdateAfterBind; }
            set { M->DescriptorBindingSampledImageUpdateAfterBind = value; }
        }

        public bool DescriptorBindingStorageImageUpdateAfterBind
        {
            get { return M->DescriptorBindingStorageImageUpdateAfterBind; }
            set { M->DescriptorBindingStorageImageUpdateAfterBind = value; }
        }

        public bool DescriptorBindingStorageBufferUpdateAfterBind
        {
            get { return M->DescriptorBindingStorageBufferUpdateAfterBind; }
            set { M->DescriptorBindingStorageBufferUpdateAfterBind = value; }
        }

        public bool DescriptorBindingUniformTexelBufferUpdateAfterBind
        {
            get { return M->DescriptorBindingUniformTexelBufferUpdateAfterBind; }
            set { M->DescriptorBindingUniformTexelBufferUpdateAfterBind = value; }
        }

        public bool DescriptorBindingStorageTexelBufferUpdateAfterBind
        {
            get { return M->DescriptorBindingStorageTexelBufferUpdateAfterBind; }
            set { M->DescriptorBindingStorageTexelBufferUpdateAfterBind = value; }
        }

        public bool DescriptorBindingUpdateUnusedWhilePending
        {
            get { return M->DescriptorBindingUpdateUnusedWhilePending; }
            set { M->DescriptorBindingUpdateUnusedWhilePending = value; }
        }

        public bool DescriptorBindingPartiallyBound
        {
            get { return M->DescriptorBindingPartiallyBound; }
            set { M->DescriptorBindingPartiallyBound = value; }
        }

        public bool DescriptorBindingVariableDescriptorCount
        {
            get { return M->DescriptorBindingVariableDescriptorCount; }
            set { M->DescriptorBindingVariableDescriptorCount = value; }
        }

        public bool RuntimeDescriptorArray
        {
            get { return M->RuntimeDescriptorArray; }
            set { M->RuntimeDescriptorArray = value; }
        }

        internal new Interop.PhysicalDeviceDescriptorIndexingFeaturesExt* M
        {
            get { return (Interop.PhysicalDeviceDescriptorIndexingFeaturesExt*)native.Handle; }
        }

        public PhysicalDeviceDescriptorIndexingFeaturesExt()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PhysicalDeviceDescriptorIndexingFeaturesExt));

            M->SType = StructureType.PhysicalDeviceDescriptorIndexingFeaturesExt;
        }

        internal PhysicalDeviceDescriptorIndexingFeaturesExt(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PhysicalDeviceDescriptorIndexingFeaturesExt;
        }
    }

    unsafe public partial class PhysicalDeviceDescriptorIndexingPropertiesExt : PhysicalDeviceProperties2
    {
        public UInt32 MaxUpdateAfterBindDescriptorsInAllPools
        {
            get { return M->MaxUpdateAfterBindDescriptorsInAllPools; }
            set { M->MaxUpdateAfterBindDescriptorsInAllPools = value; }
        }

        public bool ShaderUniformBufferArrayNonUniformIndexingNative
        {
            get { return M->ShaderUniformBufferArrayNonUniformIndexingNative; }
            set { M->ShaderUniformBufferArrayNonUniformIndexingNative = value; }
        }

        public bool ShaderSampledImageArrayNonUniformIndexingNative
        {
            get { return M->ShaderSampledImageArrayNonUniformIndexingNative; }
            set { M->ShaderSampledImageArrayNonUniformIndexingNative = value; }
        }

        public bool ShaderStorageBufferArrayNonUniformIndexingNative
        {
            get { return M->ShaderStorageBufferArrayNonUniformIndexingNative; }
            set { M->ShaderStorageBufferArrayNonUniformIndexingNative = value; }
        }

        public bool ShaderStorageImageArrayNonUniformIndexingNative
        {
            get { return M->ShaderStorageImageArrayNonUniformIndexingNative; }
            set { M->ShaderStorageImageArrayNonUniformIndexingNative = value; }
        }

        public bool ShaderInputAttachmentArrayNonUniformIndexingNative
        {
            get { return M->ShaderInputAttachmentArrayNonUniformIndexingNative; }
            set { M->ShaderInputAttachmentArrayNonUniformIndexingNative = value; }
        }

        public bool RobustBufferAccessUpdateAfterBind
        {
            get { return M->RobustBufferAccessUpdateAfterBind; }
            set { M->RobustBufferAccessUpdateAfterBind = value; }
        }

        public bool QuadDivergentImplicitLod
        {
            get { return M->QuadDivergentImplicitLod; }
            set { M->QuadDivergentImplicitLod = value; }
        }

        public UInt32 MaxPerStageDescriptorUpdateAfterBindSamplers
        {
            get { return M->MaxPerStageDescriptorUpdateAfterBindSamplers; }
            set { M->MaxPerStageDescriptorUpdateAfterBindSamplers = value; }
        }

        public UInt32 MaxPerStageDescriptorUpdateAfterBindUniformBuffers
        {
            get { return M->MaxPerStageDescriptorUpdateAfterBindUniformBuffers; }
            set { M->MaxPerStageDescriptorUpdateAfterBindUniformBuffers = value; }
        }

        public UInt32 MaxPerStageDescriptorUpdateAfterBindStorageBuffers
        {
            get { return M->MaxPerStageDescriptorUpdateAfterBindStorageBuffers; }
            set { M->MaxPerStageDescriptorUpdateAfterBindStorageBuffers = value; }
        }

        public UInt32 MaxPerStageDescriptorUpdateAfterBindSampledImages
        {
            get { return M->MaxPerStageDescriptorUpdateAfterBindSampledImages; }
            set { M->MaxPerStageDescriptorUpdateAfterBindSampledImages = value; }
        }

        public UInt32 MaxPerStageDescriptorUpdateAfterBindStorageImages
        {
            get { return M->MaxPerStageDescriptorUpdateAfterBindStorageImages; }
            set { M->MaxPerStageDescriptorUpdateAfterBindStorageImages = value; }
        }

        public UInt32 MaxPerStageDescriptorUpdateAfterBindInputAttachments
        {
            get { return M->MaxPerStageDescriptorUpdateAfterBindInputAttachments; }
            set { M->MaxPerStageDescriptorUpdateAfterBindInputAttachments = value; }
        }

        public UInt32 MaxPerStageUpdateAfterBindResources
        {
            get { return M->MaxPerStageUpdateAfterBindResources; }
            set { M->MaxPerStageUpdateAfterBindResources = value; }
        }

        public UInt32 MaxDescriptorSetUpdateAfterBindSamplers
        {
            get { return M->MaxDescriptorSetUpdateAfterBindSamplers; }
            set { M->MaxDescriptorSetUpdateAfterBindSamplers = value; }
        }

        public UInt32 MaxDescriptorSetUpdateAfterBindUniformBuffers
        {
            get { return M->MaxDescriptorSetUpdateAfterBindUniformBuffers; }
            set { M->MaxDescriptorSetUpdateAfterBindUniformBuffers = value; }
        }

        public UInt32 MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic
        {
            get { return M->MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic; }
            set { M->MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic = value; }
        }

        public UInt32 MaxDescriptorSetUpdateAfterBindStorageBuffers
        {
            get { return M->MaxDescriptorSetUpdateAfterBindStorageBuffers; }
            set { M->MaxDescriptorSetUpdateAfterBindStorageBuffers = value; }
        }

        public UInt32 MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic
        {
            get { return M->MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic; }
            set { M->MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic = value; }
        }

        public UInt32 MaxDescriptorSetUpdateAfterBindSampledImages
        {
            get { return M->MaxDescriptorSetUpdateAfterBindSampledImages; }
            set { M->MaxDescriptorSetUpdateAfterBindSampledImages = value; }
        }

        public UInt32 MaxDescriptorSetUpdateAfterBindStorageImages
        {
            get { return M->MaxDescriptorSetUpdateAfterBindStorageImages; }
            set { M->MaxDescriptorSetUpdateAfterBindStorageImages = value; }
        }

        public UInt32 MaxDescriptorSetUpdateAfterBindInputAttachments
        {
            get { return M->MaxDescriptorSetUpdateAfterBindInputAttachments; }
            set { M->MaxDescriptorSetUpdateAfterBindInputAttachments = value; }
        }

        internal new Interop.PhysicalDeviceDescriptorIndexingPropertiesExt* M
        {
            get { return (Interop.PhysicalDeviceDescriptorIndexingPropertiesExt*)native.Handle; }
        }

        public PhysicalDeviceDescriptorIndexingPropertiesExt()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PhysicalDeviceDescriptorIndexingPropertiesExt));

            M->SType = StructureType.PhysicalDeviceDescriptorIndexingPropertiesExt;
        }

        internal PhysicalDeviceDescriptorIndexingPropertiesExt(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PhysicalDeviceDescriptorIndexingPropertiesExt;
        }
    }

    unsafe public partial class DescriptorSetLayoutBindingFlagsCreateInfoExt : DescriptorSetLayoutCreateInfo
    {
        public new UInt32 BindingCount
        {
            get { return M->BindingCount; }
            set { M->BindingCount = value; }
        }

        NativeReference refBindingFlags;
        public DescriptorBindingFlagsExt[] BindingFlags
        {
            get
            {
                if (M->BindingCount == 0)
                    return null;
                var values = new DescriptorBindingFlagsExt[M->BindingCount];
                unsafe
                {
                    DescriptorBindingFlagsExt* ptr = (DescriptorBindingFlagsExt*)M->BindingFlags;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->BindingCount = 0;
                    M->BindingFlags = IntPtr.Zero;
                    return;
                }
                M->BindingCount = (uint)value.Length;
                refBindingFlags = new NativeReference((int)(sizeof(DescriptorBindingFlagsExt) * value.Length));
                M->BindingFlags = refBindingFlags.Handle;
                unsafe
                {
                    DescriptorBindingFlagsExt* ptr = (DescriptorBindingFlagsExt*)M->BindingFlags;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        internal new Interop.DescriptorSetLayoutBindingFlagsCreateInfoExt* M
        {
            get { return (Interop.DescriptorSetLayoutBindingFlagsCreateInfoExt*)native.Handle; }
        }

        public DescriptorSetLayoutBindingFlagsCreateInfoExt()
        {
            native = Interop.Structure.Allocate(typeof(Interop.DescriptorSetLayoutBindingFlagsCreateInfoExt));

            M->SType = StructureType.DescriptorSetLayoutBindingFlagsCreateInfoExt;
        }

        internal DescriptorSetLayoutBindingFlagsCreateInfoExt(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.DescriptorSetLayoutBindingFlagsCreateInfoExt;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refBindingFlags.Dispose();
            refBindingFlags = null;
        }
    }

    unsafe public partial class DescriptorSetVariableDescriptorCountAllocateInfoExt : DescriptorSetAllocateInfo
    {
        public new UInt32 DescriptorSetCount
        {
            get { return M->DescriptorSetCount; }
            set { M->DescriptorSetCount = value; }
        }

        NativeReference refDescriptorCounts;
        public UInt32[] DescriptorCounts
        {
            get
            {
                if (M->DescriptorSetCount == 0)
                    return null;
                var values = new UInt32[M->DescriptorSetCount];
                unsafe
                {
                    UInt32* ptr = (UInt32*)M->DescriptorCounts;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->DescriptorSetCount = 0;
                    M->DescriptorCounts = IntPtr.Zero;
                    return;
                }
                M->DescriptorSetCount = (uint)value.Length;
                refDescriptorCounts = new NativeReference((int)(sizeof(UInt32) * value.Length));
                M->DescriptorCounts = refDescriptorCounts.Handle;
                unsafe
                {
                    UInt32* ptr = (UInt32*)M->DescriptorCounts;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        internal new Interop.DescriptorSetVariableDescriptorCountAllocateInfoExt* M
        {
            get { return (Interop.DescriptorSetVariableDescriptorCountAllocateInfoExt*)native.Handle; }
        }

        public DescriptorSetVariableDescriptorCountAllocateInfoExt()
        {
            native = Interop.Structure.Allocate(typeof(Interop.DescriptorSetVariableDescriptorCountAllocateInfoExt));

            M->SType = StructureType.DescriptorSetVariableDescriptorCountAllocateInfoExt;
        }

        internal DescriptorSetVariableDescriptorCountAllocateInfoExt(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.DescriptorSetVariableDescriptorCountAllocateInfoExt;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refDescriptorCounts.Dispose();
            refDescriptorCounts = null;
        }
    }

    unsafe public partial class DescriptorSetVariableDescriptorCountLayoutSupportExt : DescriptorSetLayoutSupport
    {
        public UInt32 MaxVariableDescriptorCount
        {
            get { return M->MaxVariableDescriptorCount; }
            set { M->MaxVariableDescriptorCount = value; }
        }

        internal new Interop.DescriptorSetVariableDescriptorCountLayoutSupportExt* M
        {
            get { return (Interop.DescriptorSetVariableDescriptorCountLayoutSupportExt*)native.Handle; }
        }

        public DescriptorSetVariableDescriptorCountLayoutSupportExt()
        {
            native = Interop.Structure.Allocate(typeof(Interop.DescriptorSetVariableDescriptorCountLayoutSupportExt));

            M->SType = StructureType.DescriptorSetVariableDescriptorCountLayoutSupportExt;
        }

        internal DescriptorSetVariableDescriptorCountLayoutSupportExt(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.DescriptorSetVariableDescriptorCountLayoutSupportExt;
        }
    }

    unsafe public partial class AttachmentDescription2Khr : MarshalledObject
    {
        public AttachmentDescriptionFlags Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        public Format Format
        {
            get { return M->Format; }
            set { M->Format = value; }
        }

        public SampleCountFlags Samples
        {
            get { return M->Samples; }
            set { M->Samples = value; }
        }

        /// <summary>
        /// Load operation for color or depth data
        /// </summary>
        public AttachmentLoadOp LoadOp
        {
            get { return M->LoadOp; }
            set { M->LoadOp = value; }
        }

        /// <summary>
        /// Store operation for color or depth data
        /// </summary>
        public AttachmentStoreOp StoreOp
        {
            get { return M->StoreOp; }
            set { M->StoreOp = value; }
        }

        /// <summary>
        /// Load operation for stencil data
        /// </summary>
        public AttachmentLoadOp StencilLoadOp
        {
            get { return M->StencilLoadOp; }
            set { M->StencilLoadOp = value; }
        }

        /// <summary>
        /// Store operation for stencil data
        /// </summary>
        public AttachmentStoreOp StencilStoreOp
        {
            get { return M->StencilStoreOp; }
            set { M->StencilStoreOp = value; }
        }

        public ImageLayout InitialLayout
        {
            get { return M->InitialLayout; }
            set { M->InitialLayout = value; }
        }

        public ImageLayout FinalLayout
        {
            get { return M->FinalLayout; }
            set { M->FinalLayout = value; }
        }

        internal Interop.AttachmentDescription2Khr* M
        {
            get { return (Interop.AttachmentDescription2Khr*)native.Handle; }
        }

        public AttachmentDescription2Khr()
        {
            native = Interop.Structure.Allocate(typeof(Interop.AttachmentDescription2Khr));

            M->SType = StructureType.AttachmentDescription2Khr;
        }

        internal AttachmentDescription2Khr(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.AttachmentDescription2Khr;
        }
    }

    unsafe public partial class AttachmentReference2Khr : MarshalledObject
    {
        public UInt32 Attachment
        {
            get { return M->Attachment; }
            set { M->Attachment = value; }
        }

        public ImageLayout Layout
        {
            get { return M->Layout; }
            set { M->Layout = value; }
        }

        public ImageAspectFlags AspectMask
        {
            get { return M->AspectMask; }
            set { M->AspectMask = value; }
        }

        internal Interop.AttachmentReference2Khr* M
        {
            get { return (Interop.AttachmentReference2Khr*)native.Handle; }
        }

        public AttachmentReference2Khr()
        {
            native = Interop.Structure.Allocate(typeof(Interop.AttachmentReference2Khr));

            M->SType = StructureType.AttachmentReference2Khr;
        }

        internal AttachmentReference2Khr(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.AttachmentReference2Khr;
        }
    }

    unsafe public partial class SubpassDescription2Khr : MarshalledObject
    {
        public SubpassDescriptionFlags Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        public PipelineBindPoint PipelineBindPoint
        {
            get { return M->PipelineBindPoint; }
            set { M->PipelineBindPoint = value; }
        }

        public UInt32 ViewMask
        {
            get { return M->ViewMask; }
            set { M->ViewMask = value; }
        }

        public UInt32 InputAttachmentCount
        {
            get { return M->InputAttachmentCount; }
            set { M->InputAttachmentCount = value; }
        }

        NativeReference refInputAttachments;
        public AttachmentReference2Khr[] InputAttachments
        {
            get
            {
                if (M->InputAttachmentCount == 0)
                    return null;
                var values = new AttachmentReference2Khr[M->InputAttachmentCount];
                unsafe
                {
                    Interop.AttachmentReference2Khr* ptr = (Interop.AttachmentReference2Khr*)M->InputAttachments;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = new AttachmentReference2Khr();
                        *values[i].M = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->InputAttachmentCount = 0;
                    M->InputAttachments = IntPtr.Zero;
                    return;
                }
                M->InputAttachmentCount = (uint)value.Length;
                refInputAttachments = new NativeReference((int)(sizeof(Interop.AttachmentReference2Khr) * value.Length));
                M->InputAttachments = refInputAttachments.Handle;
                unsafe
                {
                    Interop.AttachmentReference2Khr* ptr = (Interop.AttachmentReference2Khr*)M->InputAttachments;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = *value[i].M;
                    }
                }
            }
        }

        public UInt32 ColorAttachmentCount
        {
            get { return M->ColorAttachmentCount; }
            set { M->ColorAttachmentCount = value; }
        }

        NativeReference refColorAttachments;
        public AttachmentReference2Khr[] ColorAttachments
        {
            get
            {
                if (M->ColorAttachmentCount == 0)
                    return null;
                var values = new AttachmentReference2Khr[M->ColorAttachmentCount];
                unsafe
                {
                    Interop.AttachmentReference2Khr* ptr = (Interop.AttachmentReference2Khr*)M->ColorAttachments;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = new AttachmentReference2Khr();
                        *values[i].M = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->ColorAttachmentCount = 0;
                    M->ColorAttachments = IntPtr.Zero;
                    return;
                }
                M->ColorAttachmentCount = (uint)value.Length;
                refColorAttachments = new NativeReference((int)(sizeof(Interop.AttachmentReference2Khr) * value.Length));
                M->ColorAttachments = refColorAttachments.Handle;
                unsafe
                {
                    Interop.AttachmentReference2Khr* ptr = (Interop.AttachmentReference2Khr*)M->ColorAttachments;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = *value[i].M;
                    }
                }
            }
        }

        NativeReference refResolveAttachments;
        public AttachmentReference2Khr[] ResolveAttachments
        {
            get
            {
                if (M->ColorAttachmentCount == 0)
                    return null;
                var values = new AttachmentReference2Khr[M->ColorAttachmentCount];
                unsafe
                {
                    Interop.AttachmentReference2Khr* ptr = (Interop.AttachmentReference2Khr*)M->ResolveAttachments;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = new AttachmentReference2Khr();
                        *values[i].M = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->ColorAttachmentCount = 0;
                    M->ResolveAttachments = IntPtr.Zero;
                    return;
                }
                M->ColorAttachmentCount = (uint)value.Length;
                refResolveAttachments = new NativeReference((int)(sizeof(Interop.AttachmentReference2Khr) * value.Length));
                M->ResolveAttachments = refResolveAttachments.Handle;
                unsafe
                {
                    Interop.AttachmentReference2Khr* ptr = (Interop.AttachmentReference2Khr*)M->ResolveAttachments;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = *value[i].M;
                    }
                }
            }
        }

        AttachmentReference2Khr lDepthStencilAttachment;
        public AttachmentReference2Khr DepthStencilAttachment
        {
            get { return lDepthStencilAttachment; }
            set { lDepthStencilAttachment = value; M->DepthStencilAttachment = value != null ? (IntPtr)value.M : default(IntPtr); }
        }

        public UInt32 PreserveAttachmentCount
        {
            get { return M->PreserveAttachmentCount; }
            set { M->PreserveAttachmentCount = value; }
        }

        NativeReference refPreserveAttachments;
        public UInt32[] PreserveAttachments
        {
            get
            {
                if (M->PreserveAttachmentCount == 0)
                    return null;
                var values = new UInt32[M->PreserveAttachmentCount];
                unsafe
                {
                    UInt32* ptr = (UInt32*)M->PreserveAttachments;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->PreserveAttachmentCount = 0;
                    M->PreserveAttachments = IntPtr.Zero;
                    return;
                }
                M->PreserveAttachmentCount = (uint)value.Length;
                refPreserveAttachments = new NativeReference((int)(sizeof(UInt32) * value.Length));
                M->PreserveAttachments = refPreserveAttachments.Handle;
                unsafe
                {
                    UInt32* ptr = (UInt32*)M->PreserveAttachments;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        internal Interop.SubpassDescription2Khr* M
        {
            get { return (Interop.SubpassDescription2Khr*)native.Handle; }
        }

        public SubpassDescription2Khr()
        {
            native = Interop.Structure.Allocate(typeof(Interop.SubpassDescription2Khr));

            M->SType = StructureType.SubpassDescription2Khr;
        }

        internal SubpassDescription2Khr(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.SubpassDescription2Khr;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refInputAttachments.Dispose();
            refInputAttachments = null;
            refColorAttachments.Dispose();
            refColorAttachments = null;
            refResolveAttachments.Dispose();
            refResolveAttachments = null;
            refPreserveAttachments.Dispose();
            refPreserveAttachments = null;
        }
    }

    unsafe public partial class SubpassDependency2Khr : MarshalledObject
    {
        public UInt32 SrcSubpass
        {
            get { return M->SrcSubpass; }
            set { M->SrcSubpass = value; }
        }

        public UInt32 DstSubpass
        {
            get { return M->DstSubpass; }
            set { M->DstSubpass = value; }
        }

        public PipelineStageFlags SrcStageMask
        {
            get { return M->SrcStageMask; }
            set { M->SrcStageMask = value; }
        }

        public PipelineStageFlags DstStageMask
        {
            get { return M->DstStageMask; }
            set { M->DstStageMask = value; }
        }

        public AccessFlags SrcAccessMask
        {
            get { return M->SrcAccessMask; }
            set { M->SrcAccessMask = value; }
        }

        public AccessFlags DstAccessMask
        {
            get { return M->DstAccessMask; }
            set { M->DstAccessMask = value; }
        }

        public DependencyFlags DependencyFlags
        {
            get { return M->DependencyFlags; }
            set { M->DependencyFlags = value; }
        }

        public Int32 ViewOffset
        {
            get { return M->ViewOffset; }
            set { M->ViewOffset = value; }
        }

        internal Interop.SubpassDependency2Khr* M
        {
            get { return (Interop.SubpassDependency2Khr*)native.Handle; }
        }

        public SubpassDependency2Khr()
        {
            native = Interop.Structure.Allocate(typeof(Interop.SubpassDependency2Khr));

            M->SType = StructureType.SubpassDependency2Khr;
        }

        internal SubpassDependency2Khr(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.SubpassDependency2Khr;
        }
    }

    unsafe public partial class RenderPassCreateInfo2Khr : MarshalledObject
    {
        public RenderPassCreateFlags Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        public UInt32 AttachmentCount
        {
            get { return M->AttachmentCount; }
            set { M->AttachmentCount = value; }
        }

        NativeReference refAttachments;
        public AttachmentDescription2Khr[] Attachments
        {
            get
            {
                if (M->AttachmentCount == 0)
                    return null;
                var values = new AttachmentDescription2Khr[M->AttachmentCount];
                unsafe
                {
                    Interop.AttachmentDescription2Khr* ptr = (Interop.AttachmentDescription2Khr*)M->Attachments;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = new AttachmentDescription2Khr();
                        *values[i].M = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->AttachmentCount = 0;
                    M->Attachments = IntPtr.Zero;
                    return;
                }
                M->AttachmentCount = (uint)value.Length;
                refAttachments = new NativeReference((int)(sizeof(Interop.AttachmentDescription2Khr) * value.Length));
                M->Attachments = refAttachments.Handle;
                unsafe
                {
                    Interop.AttachmentDescription2Khr* ptr = (Interop.AttachmentDescription2Khr*)M->Attachments;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = *value[i].M;
                    }
                }
            }
        }

        public UInt32 SubpassCount
        {
            get { return M->SubpassCount; }
            set { M->SubpassCount = value; }
        }

        NativeReference refSubpasses;
        public SubpassDescription2Khr[] Subpasses
        {
            get
            {
                if (M->SubpassCount == 0)
                    return null;
                var values = new SubpassDescription2Khr[M->SubpassCount];
                unsafe
                {
                    Interop.SubpassDescription2Khr* ptr = (Interop.SubpassDescription2Khr*)M->Subpasses;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = new SubpassDescription2Khr();
                        *values[i].M = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->SubpassCount = 0;
                    M->Subpasses = IntPtr.Zero;
                    return;
                }
                M->SubpassCount = (uint)value.Length;
                refSubpasses = new NativeReference((int)(sizeof(Interop.SubpassDescription2Khr) * value.Length));
                M->Subpasses = refSubpasses.Handle;
                unsafe
                {
                    Interop.SubpassDescription2Khr* ptr = (Interop.SubpassDescription2Khr*)M->Subpasses;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = *value[i].M;
                    }
                }
            }
        }

        public UInt32 DependencyCount
        {
            get { return M->DependencyCount; }
            set { M->DependencyCount = value; }
        }

        NativeReference refDependencies;
        public SubpassDependency2Khr[] Dependencies
        {
            get
            {
                if (M->DependencyCount == 0)
                    return null;
                var values = new SubpassDependency2Khr[M->DependencyCount];
                unsafe
                {
                    Interop.SubpassDependency2Khr* ptr = (Interop.SubpassDependency2Khr*)M->Dependencies;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = new SubpassDependency2Khr();
                        *values[i].M = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->DependencyCount = 0;
                    M->Dependencies = IntPtr.Zero;
                    return;
                }
                M->DependencyCount = (uint)value.Length;
                refDependencies = new NativeReference((int)(sizeof(Interop.SubpassDependency2Khr) * value.Length));
                M->Dependencies = refDependencies.Handle;
                unsafe
                {
                    Interop.SubpassDependency2Khr* ptr = (Interop.SubpassDependency2Khr*)M->Dependencies;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = *value[i].M;
                    }
                }
            }
        }

        public UInt32 CorrelatedViewMaskCount
        {
            get { return M->CorrelatedViewMaskCount; }
            set { M->CorrelatedViewMaskCount = value; }
        }

        NativeReference refCorrelatedViewMasks;
        public UInt32[] CorrelatedViewMasks
        {
            get
            {
                if (M->CorrelatedViewMaskCount == 0)
                    return null;
                var values = new UInt32[M->CorrelatedViewMaskCount];
                unsafe
                {
                    UInt32* ptr = (UInt32*)M->CorrelatedViewMasks;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->CorrelatedViewMaskCount = 0;
                    M->CorrelatedViewMasks = IntPtr.Zero;
                    return;
                }
                M->CorrelatedViewMaskCount = (uint)value.Length;
                refCorrelatedViewMasks = new NativeReference((int)(sizeof(UInt32) * value.Length));
                M->CorrelatedViewMasks = refCorrelatedViewMasks.Handle;
                unsafe
                {
                    UInt32* ptr = (UInt32*)M->CorrelatedViewMasks;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        internal Interop.RenderPassCreateInfo2Khr* M
        {
            get { return (Interop.RenderPassCreateInfo2Khr*)native.Handle; }
        }

        public RenderPassCreateInfo2Khr()
        {
            native = Interop.Structure.Allocate(typeof(Interop.RenderPassCreateInfo2Khr));

            M->SType = StructureType.RenderPassCreateInfo2Khr;
        }

        internal RenderPassCreateInfo2Khr(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.RenderPassCreateInfo2Khr;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refAttachments.Dispose();
            refAttachments = null;
            refSubpasses.Dispose();
            refSubpasses = null;
            refDependencies.Dispose();
            refDependencies = null;
            refCorrelatedViewMasks.Dispose();
            refCorrelatedViewMasks = null;
        }
    }

    unsafe public partial class SubpassBeginInfoKhr : MarshalledObject
    {
        public SubpassContents Contents
        {
            get { return M->Contents; }
            set { M->Contents = value; }
        }

        internal Interop.SubpassBeginInfoKhr* M
        {
            get { return (Interop.SubpassBeginInfoKhr*)native.Handle; }
        }

        public SubpassBeginInfoKhr()
        {
            native = Interop.Structure.Allocate(typeof(Interop.SubpassBeginInfoKhr));

            M->SType = StructureType.SubpassBeginInfoKhr;
        }

        internal SubpassBeginInfoKhr(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.SubpassBeginInfoKhr;
        }
    }

    unsafe public partial class SubpassEndInfoKhr : MarshalledObject
    {

        internal Interop.SubpassEndInfoKhr* M
        {
            get { return (Interop.SubpassEndInfoKhr*)native.Handle; }
        }

        public SubpassEndInfoKhr()
        {
            native = Interop.Structure.Allocate(typeof(Interop.SubpassEndInfoKhr));

            M->SType = StructureType.SubpassEndInfoKhr;
        }

        internal SubpassEndInfoKhr(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.SubpassEndInfoKhr;
        }
    }

    unsafe public partial struct VertexInputBindingDivisorDescriptionExt
    {
        public UInt32 Binding;
        public UInt32 Divisor;
    }

    unsafe public partial class PipelineVertexInputDivisorStateCreateInfoExt : PipelineVertexInputStateCreateInfo
    {
        public UInt32 VertexBindingDivisorCount
        {
            get { return M->VertexBindingDivisorCount; }
            set { M->VertexBindingDivisorCount = value; }
        }

        NativeReference refVertexBindingDivisors;
        public VertexInputBindingDivisorDescriptionExt[] VertexBindingDivisors
        {
            get
            {
                if (M->VertexBindingDivisorCount == 0)
                    return null;
                var values = new VertexInputBindingDivisorDescriptionExt[M->VertexBindingDivisorCount];
                unsafe
                {
                    VertexInputBindingDivisorDescriptionExt* ptr = (VertexInputBindingDivisorDescriptionExt*)M->VertexBindingDivisors;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->VertexBindingDivisorCount = 0;
                    M->VertexBindingDivisors = IntPtr.Zero;
                    return;
                }
                M->VertexBindingDivisorCount = (uint)value.Length;
                refVertexBindingDivisors = new NativeReference((int)(sizeof(VertexInputBindingDivisorDescriptionExt) * value.Length));
                M->VertexBindingDivisors = refVertexBindingDivisors.Handle;
                unsafe
                {
                    VertexInputBindingDivisorDescriptionExt* ptr = (VertexInputBindingDivisorDescriptionExt*)M->VertexBindingDivisors;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        internal new Interop.PipelineVertexInputDivisorStateCreateInfoExt* M
        {
            get { return (Interop.PipelineVertexInputDivisorStateCreateInfoExt*)native.Handle; }
        }

        public PipelineVertexInputDivisorStateCreateInfoExt()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PipelineVertexInputDivisorStateCreateInfoExt));

            M->SType = StructureType.PipelineVertexInputDivisorStateCreateInfoExt;
        }

        internal PipelineVertexInputDivisorStateCreateInfoExt(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PipelineVertexInputDivisorStateCreateInfoExt;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refVertexBindingDivisors.Dispose();
            refVertexBindingDivisors = null;
        }
    }

    unsafe public partial class PhysicalDeviceVertexAttributeDivisorPropertiesExt : PhysicalDeviceProperties2
    {
        /// <summary>
        /// max value of vertex attribute divisor
        /// </summary>
        public UInt32 MaxVertexAttribDivisor
        {
            get { return M->MaxVertexAttribDivisor; }
            set { M->MaxVertexAttribDivisor = value; }
        }

        internal new Interop.PhysicalDeviceVertexAttributeDivisorPropertiesExt* M
        {
            get { return (Interop.PhysicalDeviceVertexAttributeDivisorPropertiesExt*)native.Handle; }
        }

        public PhysicalDeviceVertexAttributeDivisorPropertiesExt()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PhysicalDeviceVertexAttributeDivisorPropertiesExt));

            M->SType = StructureType.PhysicalDeviceVertexAttributeDivisorPropertiesExt;
        }

        internal PhysicalDeviceVertexAttributeDivisorPropertiesExt(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PhysicalDeviceVertexAttributeDivisorPropertiesExt;
        }
    }

    unsafe public partial class ImportAndroidHardwareBufferInfoAndroid : MemoryAllocateInfo
    {
        public IntPtr Buffer
        {
            get { return M->Buffer; }
            set { M->Buffer = value; }
        }

        internal new Interop.ImportAndroidHardwareBufferInfoAndroid* M
        {
            get { return (Interop.ImportAndroidHardwareBufferInfoAndroid*)native.Handle; }
        }

        public ImportAndroidHardwareBufferInfoAndroid()
        {
            native = Interop.Structure.Allocate(typeof(Interop.ImportAndroidHardwareBufferInfoAndroid));

            M->SType = StructureType.ImportAndroidHardwareBufferInfoAndroid;
        }

        internal ImportAndroidHardwareBufferInfoAndroid(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.ImportAndroidHardwareBufferInfoAndroid;
        }
    }

    unsafe public partial class AndroidHardwareBufferUsageAndroid : ImageFormatProperties2
    {
        public UInt64 AndroidHardwareBufferUsage
        {
            get { return M->AndroidHardwareBufferUsage; }
            set { M->AndroidHardwareBufferUsage = value; }
        }

        internal new Interop.AndroidHardwareBufferUsageAndroid* M
        {
            get { return (Interop.AndroidHardwareBufferUsageAndroid*)native.Handle; }
        }

        public AndroidHardwareBufferUsageAndroid()
        {
            native = Interop.Structure.Allocate(typeof(Interop.AndroidHardwareBufferUsageAndroid));

            M->SType = StructureType.AndroidHardwareBufferUsageAndroid;
        }

        internal AndroidHardwareBufferUsageAndroid(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.AndroidHardwareBufferUsageAndroid;
        }
    }

    unsafe public partial class AndroidHardwareBufferPropertiesAndroid : MarshalledObject
    {
        public DeviceSize AllocationSize
        {
            get { return M->AllocationSize; }
            set { M->AllocationSize = value; }
        }

        public UInt32 MemoryTypeBits
        {
            get { return M->MemoryTypeBits; }
            set { M->MemoryTypeBits = value; }
        }

        internal Interop.AndroidHardwareBufferPropertiesAndroid* M
        {
            get { return (Interop.AndroidHardwareBufferPropertiesAndroid*)native.Handle; }
        }

        public AndroidHardwareBufferPropertiesAndroid()
        {
            native = Interop.Structure.Allocate(typeof(Interop.AndroidHardwareBufferPropertiesAndroid));

            M->SType = StructureType.AndroidHardwareBufferPropertiesAndroid;
        }

        internal AndroidHardwareBufferPropertiesAndroid(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.AndroidHardwareBufferPropertiesAndroid;
        }
    }

    unsafe public partial class MemoryGetAndroidHardwareBufferInfoAndroid : MarshalledObject
    {
        DeviceMemory lMemory;
        public DeviceMemory Memory
        {
            get { return lMemory; }
            set { lMemory = value; M->Memory = value != null ? (UInt64)value.M : default(UInt64); }
        }

        internal Interop.MemoryGetAndroidHardwareBufferInfoAndroid* M
        {
            get { return (Interop.MemoryGetAndroidHardwareBufferInfoAndroid*)native.Handle; }
        }

        public MemoryGetAndroidHardwareBufferInfoAndroid()
        {
            native = Interop.Structure.Allocate(typeof(Interop.MemoryGetAndroidHardwareBufferInfoAndroid));

            M->SType = StructureType.MemoryGetAndroidHardwareBufferInfoAndroid;
        }

        internal MemoryGetAndroidHardwareBufferInfoAndroid(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.MemoryGetAndroidHardwareBufferInfoAndroid;
        }
    }

    unsafe public partial class AndroidHardwareBufferFormatPropertiesAndroid : AndroidHardwareBufferPropertiesAndroid
    {
        public Format Format
        {
            get { return M->Format; }
            set { M->Format = value; }
        }

        public UInt64 ExternalFormat
        {
            get { return M->ExternalFormat; }
            set { M->ExternalFormat = value; }
        }

        public FormatFeatureFlags FormatFeatures
        {
            get { return M->FormatFeatures; }
            set { M->FormatFeatures = value; }
        }

        public ComponentMapping SamplerYcbcrConversionComponents
        {
            get { return M->SamplerYcbcrConversionComponents; }
            set { M->SamplerYcbcrConversionComponents = value; }
        }

        public SamplerYcbcrModelConversion SuggestedYcbcrModel
        {
            get { return M->SuggestedYcbcrModel; }
            set { M->SuggestedYcbcrModel = value; }
        }

        public SamplerYcbcrRange SuggestedYcbcrRange
        {
            get { return M->SuggestedYcbcrRange; }
            set { M->SuggestedYcbcrRange = value; }
        }

        public ChromaLocation SuggestedXchromaOffset
        {
            get { return M->SuggestedXchromaOffset; }
            set { M->SuggestedXchromaOffset = value; }
        }

        public ChromaLocation SuggestedYchromaOffset
        {
            get { return M->SuggestedYchromaOffset; }
            set { M->SuggestedYchromaOffset = value; }
        }

        internal new Interop.AndroidHardwareBufferFormatPropertiesAndroid* M
        {
            get { return (Interop.AndroidHardwareBufferFormatPropertiesAndroid*)native.Handle; }
        }

        public AndroidHardwareBufferFormatPropertiesAndroid()
        {
            native = Interop.Structure.Allocate(typeof(Interop.AndroidHardwareBufferFormatPropertiesAndroid));

            M->SType = StructureType.AndroidHardwareBufferFormatPropertiesAndroid;
        }

        internal AndroidHardwareBufferFormatPropertiesAndroid(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.AndroidHardwareBufferFormatPropertiesAndroid;
        }
    }

    unsafe public partial class CommandBufferInheritanceConditionalRenderingInfoExt : CommandBufferInheritanceInfo
    {
        /// <summary>
        /// Whether this secondary command buffer may be executed during an active conditional rendering
        /// </summary>
        public bool ConditionalRenderingEnable
        {
            get { return M->ConditionalRenderingEnable; }
            set { M->ConditionalRenderingEnable = value; }
        }

        internal new Interop.CommandBufferInheritanceConditionalRenderingInfoExt* M
        {
            get { return (Interop.CommandBufferInheritanceConditionalRenderingInfoExt*)native.Handle; }
        }

        public CommandBufferInheritanceConditionalRenderingInfoExt()
        {
            native = Interop.Structure.Allocate(typeof(Interop.CommandBufferInheritanceConditionalRenderingInfoExt));

            M->SType = StructureType.CommandBufferInheritanceConditionalRenderingInfoExt;
        }

        internal CommandBufferInheritanceConditionalRenderingInfoExt(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.CommandBufferInheritanceConditionalRenderingInfoExt;
        }
    }

    unsafe public partial class ExternalFormatAndroid : ImageCreateInfo
    {
        public UInt64 ExternalFormat
        {
            get { return M->ExternalFormat; }
            set { M->ExternalFormat = value; }
        }

        internal new Interop.ExternalFormatAndroid* M
        {
            get { return (Interop.ExternalFormatAndroid*)native.Handle; }
        }

        public ExternalFormatAndroid()
        {
            native = Interop.Structure.Allocate(typeof(Interop.ExternalFormatAndroid));

            M->SType = StructureType.ExternalFormatAndroid;
        }

        internal ExternalFormatAndroid(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.ExternalFormatAndroid;
        }
    }

    unsafe public partial class PhysicalDevice8BitStorageFeaturesKhr : PhysicalDeviceFeatures2
    {
        /// <summary>
        /// 8-bit integer variables supported in StorageBuffer
        /// </summary>
        public bool StorageBuffer8BitAccess
        {
            get { return M->StorageBuffer8BitAccess; }
            set { M->StorageBuffer8BitAccess = value; }
        }

        /// <summary>
        /// 8-bit integer variables supported in StorageBuffer and Uniform
        /// </summary>
        public bool UniformAndStorageBuffer8BitAccess
        {
            get { return M->UniformAndStorageBuffer8BitAccess; }
            set { M->UniformAndStorageBuffer8BitAccess = value; }
        }

        /// <summary>
        /// 8-bit integer variables supported in PushConstant
        /// </summary>
        public bool StoragePushConstant8
        {
            get { return M->StoragePushConstant8; }
            set { M->StoragePushConstant8 = value; }
        }

        internal new Interop.PhysicalDevice8BitStorageFeaturesKhr* M
        {
            get { return (Interop.PhysicalDevice8BitStorageFeaturesKhr*)native.Handle; }
        }

        public PhysicalDevice8BitStorageFeaturesKhr()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PhysicalDevice8BitStorageFeaturesKhr));

            M->SType = StructureType.PhysicalDevice8BitStorageFeaturesKhr;
        }

        internal PhysicalDevice8BitStorageFeaturesKhr(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PhysicalDevice8BitStorageFeaturesKhr;
        }
    }

    unsafe public partial class PhysicalDeviceConditionalRenderingFeaturesExt : PhysicalDeviceFeatures2
    {
        public bool ConditionalRendering
        {
            get { return M->ConditionalRendering; }
            set { M->ConditionalRendering = value; }
        }

        public bool InheritedConditionalRendering
        {
            get { return M->InheritedConditionalRendering; }
            set { M->InheritedConditionalRendering = value; }
        }

        internal new Interop.PhysicalDeviceConditionalRenderingFeaturesExt* M
        {
            get { return (Interop.PhysicalDeviceConditionalRenderingFeaturesExt*)native.Handle; }
        }

        public PhysicalDeviceConditionalRenderingFeaturesExt()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PhysicalDeviceConditionalRenderingFeaturesExt));

            M->SType = StructureType.PhysicalDeviceConditionalRenderingFeaturesExt;
        }

        internal PhysicalDeviceConditionalRenderingFeaturesExt(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PhysicalDeviceConditionalRenderingFeaturesExt;
        }
    }

    unsafe public partial class PhysicalDeviceVulkanMemoryModelFeaturesKhr : PhysicalDeviceFeatures2
    {
        public bool VulkanMemoryModel
        {
            get { return M->VulkanMemoryModel; }
            set { M->VulkanMemoryModel = value; }
        }

        public bool VulkanMemoryModelDeviceScope
        {
            get { return M->VulkanMemoryModelDeviceScope; }
            set { M->VulkanMemoryModelDeviceScope = value; }
        }

        internal new Interop.PhysicalDeviceVulkanMemoryModelFeaturesKhr* M
        {
            get { return (Interop.PhysicalDeviceVulkanMemoryModelFeaturesKhr*)native.Handle; }
        }

        public PhysicalDeviceVulkanMemoryModelFeaturesKhr()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PhysicalDeviceVulkanMemoryModelFeaturesKhr));

            M->SType = StructureType.PhysicalDeviceVulkanMemoryModelFeaturesKhr;
        }

        internal PhysicalDeviceVulkanMemoryModelFeaturesKhr(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PhysicalDeviceVulkanMemoryModelFeaturesKhr;
        }
    }

    unsafe public partial class PhysicalDeviceShaderAtomicInt64FeaturesKhr : PhysicalDeviceFeatures2
    {
        public bool ShaderBufferInt64Atomics
        {
            get { return M->ShaderBufferInt64Atomics; }
            set { M->ShaderBufferInt64Atomics = value; }
        }

        public bool ShaderSharedInt64Atomics
        {
            get { return M->ShaderSharedInt64Atomics; }
            set { M->ShaderSharedInt64Atomics = value; }
        }

        internal new Interop.PhysicalDeviceShaderAtomicInt64FeaturesKhr* M
        {
            get { return (Interop.PhysicalDeviceShaderAtomicInt64FeaturesKhr*)native.Handle; }
        }

        public PhysicalDeviceShaderAtomicInt64FeaturesKhr()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PhysicalDeviceShaderAtomicInt64FeaturesKhr));

            M->SType = StructureType.PhysicalDeviceShaderAtomicInt64FeaturesKhr;
        }

        internal PhysicalDeviceShaderAtomicInt64FeaturesKhr(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PhysicalDeviceShaderAtomicInt64FeaturesKhr;
        }
    }

    unsafe public partial class PhysicalDeviceVertexAttributeDivisorFeaturesExt : PhysicalDeviceFeatures2
    {
        public bool VertexAttributeInstanceRateDivisor
        {
            get { return M->VertexAttributeInstanceRateDivisor; }
            set { M->VertexAttributeInstanceRateDivisor = value; }
        }

        public bool VertexAttributeInstanceRateZeroDivisor
        {
            get { return M->VertexAttributeInstanceRateZeroDivisor; }
            set { M->VertexAttributeInstanceRateZeroDivisor = value; }
        }

        internal new Interop.PhysicalDeviceVertexAttributeDivisorFeaturesExt* M
        {
            get { return (Interop.PhysicalDeviceVertexAttributeDivisorFeaturesExt*)native.Handle; }
        }

        public PhysicalDeviceVertexAttributeDivisorFeaturesExt()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PhysicalDeviceVertexAttributeDivisorFeaturesExt));

            M->SType = StructureType.PhysicalDeviceVertexAttributeDivisorFeaturesExt;
        }

        internal PhysicalDeviceVertexAttributeDivisorFeaturesExt(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PhysicalDeviceVertexAttributeDivisorFeaturesExt;
        }
    }

    unsafe public partial class QueueFamilyCheckpointPropertiesNv : QueueFamilyProperties2
    {
        public PipelineStageFlags CheckpointExecutionStageMask
        {
            get { return M->CheckpointExecutionStageMask; }
            set { M->CheckpointExecutionStageMask = value; }
        }

        internal new Interop.QueueFamilyCheckpointPropertiesNv* M
        {
            get { return (Interop.QueueFamilyCheckpointPropertiesNv*)native.Handle; }
        }

        public QueueFamilyCheckpointPropertiesNv()
        {
            native = Interop.Structure.Allocate(typeof(Interop.QueueFamilyCheckpointPropertiesNv));

            M->SType = StructureType.QueueFamilyCheckpointPropertiesNv;
        }

        internal QueueFamilyCheckpointPropertiesNv(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.QueueFamilyCheckpointPropertiesNv;
        }
    }

    unsafe public partial class CheckpointDataNv : MarshalledObject
    {
        public PipelineStageFlags Stage
        {
            get { return M->Stage; }
            set { M->Stage = value; }
        }

        public IntPtr CheckpointMarker
        {
            get { return M->CheckpointMarker; }
            set { M->CheckpointMarker = value; }
        }

        internal Interop.CheckpointDataNv* M
        {
            get { return (Interop.CheckpointDataNv*)native.Handle; }
        }

        public CheckpointDataNv()
        {
            native = Interop.Structure.Allocate(typeof(Interop.CheckpointDataNv));

            M->SType = StructureType.CheckpointDataNv;
        }

        internal CheckpointDataNv(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.CheckpointDataNv;
        }
    }

    unsafe public partial class ImageViewASTCDecodeModeExt : ImageViewCreateInfo
    {
        public Format DecodeMode
        {
            get { return M->DecodeMode; }
            set { M->DecodeMode = value; }
        }

        internal new Interop.ImageViewASTCDecodeModeExt* M
        {
            get { return (Interop.ImageViewASTCDecodeModeExt*)native.Handle; }
        }

        public ImageViewASTCDecodeModeExt()
        {
            native = Interop.Structure.Allocate(typeof(Interop.ImageViewASTCDecodeModeExt));

            M->SType = StructureType.ImageViewASTCDecodeModeExt;
        }

        internal ImageViewASTCDecodeModeExt(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.ImageViewASTCDecodeModeExt;
        }
    }

    unsafe public partial class PhysicalDeviceASTCDecodeFeaturesExt : PhysicalDeviceFeatures2
    {
        public bool DecodeModeSharedExponent
        {
            get { return M->DecodeModeSharedExponent; }
            set { M->DecodeModeSharedExponent = value; }
        }

        internal new Interop.PhysicalDeviceASTCDecodeFeaturesExt* M
        {
            get { return (Interop.PhysicalDeviceASTCDecodeFeaturesExt*)native.Handle; }
        }

        public PhysicalDeviceASTCDecodeFeaturesExt()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PhysicalDeviceASTCDecodeFeaturesExt));

            M->SType = StructureType.PhysicalDeviceASTCDecodeFeaturesExt;
        }

        internal PhysicalDeviceASTCDecodeFeaturesExt(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PhysicalDeviceASTCDecodeFeaturesExt;
        }
    }

    unsafe public partial class PhysicalDeviceRepresentativeFragmentTestFeaturesNv : PhysicalDeviceFeatures2
    {
        public bool RepresentativeFragmentTest
        {
            get { return M->RepresentativeFragmentTest; }
            set { M->RepresentativeFragmentTest = value; }
        }

        internal new Interop.PhysicalDeviceRepresentativeFragmentTestFeaturesNv* M
        {
            get { return (Interop.PhysicalDeviceRepresentativeFragmentTestFeaturesNv*)native.Handle; }
        }

        public PhysicalDeviceRepresentativeFragmentTestFeaturesNv()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PhysicalDeviceRepresentativeFragmentTestFeaturesNv));

            M->SType = StructureType.PhysicalDeviceRepresentativeFragmentTestFeaturesNv;
        }

        internal PhysicalDeviceRepresentativeFragmentTestFeaturesNv(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PhysicalDeviceRepresentativeFragmentTestFeaturesNv;
        }
    }

    unsafe public partial class PipelineRepresentativeFragmentTestStateCreateInfoNv : GraphicsPipelineCreateInfo
    {
        public bool RepresentativeFragmentTestEnable
        {
            get { return M->RepresentativeFragmentTestEnable; }
            set { M->RepresentativeFragmentTestEnable = value; }
        }

        internal new Interop.PipelineRepresentativeFragmentTestStateCreateInfoNv* M
        {
            get { return (Interop.PipelineRepresentativeFragmentTestStateCreateInfoNv*)native.Handle; }
        }

        public PipelineRepresentativeFragmentTestStateCreateInfoNv()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PipelineRepresentativeFragmentTestStateCreateInfoNv));

            M->SType = StructureType.PipelineRepresentativeFragmentTestStateCreateInfoNv;
        }

        internal PipelineRepresentativeFragmentTestStateCreateInfoNv(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PipelineRepresentativeFragmentTestStateCreateInfoNv;
        }
    }

    unsafe public partial class PhysicalDeviceExclusiveScissorFeaturesNv : PhysicalDeviceFeatures2
    {
        public bool ExclusiveScissor
        {
            get { return M->ExclusiveScissor; }
            set { M->ExclusiveScissor = value; }
        }

        internal new Interop.PhysicalDeviceExclusiveScissorFeaturesNv* M
        {
            get { return (Interop.PhysicalDeviceExclusiveScissorFeaturesNv*)native.Handle; }
        }

        public PhysicalDeviceExclusiveScissorFeaturesNv()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PhysicalDeviceExclusiveScissorFeaturesNv));

            M->SType = StructureType.PhysicalDeviceExclusiveScissorFeaturesNv;
        }

        internal PhysicalDeviceExclusiveScissorFeaturesNv(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PhysicalDeviceExclusiveScissorFeaturesNv;
        }
    }

    unsafe public partial class PipelineViewportExclusiveScissorStateCreateInfoNv : PipelineViewportStateCreateInfo
    {
        public UInt32 ExclusiveScissorCount
        {
            get { return M->ExclusiveScissorCount; }
            set { M->ExclusiveScissorCount = value; }
        }

        NativeReference refExclusiveScissors;
        public Rect2D[] ExclusiveScissors
        {
            get
            {
                if (M->ExclusiveScissorCount == 0)
                    return null;
                var values = new Rect2D[M->ExclusiveScissorCount];
                unsafe
                {
                    Rect2D* ptr = (Rect2D*)M->ExclusiveScissors;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->ExclusiveScissorCount = 0;
                    M->ExclusiveScissors = IntPtr.Zero;
                    return;
                }
                M->ExclusiveScissorCount = (uint)value.Length;
                refExclusiveScissors = new NativeReference((int)(sizeof(Rect2D) * value.Length));
                M->ExclusiveScissors = refExclusiveScissors.Handle;
                unsafe
                {
                    Rect2D* ptr = (Rect2D*)M->ExclusiveScissors;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        internal new Interop.PipelineViewportExclusiveScissorStateCreateInfoNv* M
        {
            get { return (Interop.PipelineViewportExclusiveScissorStateCreateInfoNv*)native.Handle; }
        }

        public PipelineViewportExclusiveScissorStateCreateInfoNv()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PipelineViewportExclusiveScissorStateCreateInfoNv));

            M->SType = StructureType.PipelineViewportExclusiveScissorStateCreateInfoNv;
        }

        internal PipelineViewportExclusiveScissorStateCreateInfoNv(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PipelineViewportExclusiveScissorStateCreateInfoNv;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refExclusiveScissors.Dispose();
            refExclusiveScissors = null;
        }
    }

    unsafe public partial class PhysicalDeviceCornerSampledImageFeaturesNv : PhysicalDeviceFeatures2
    {
        public bool CornerSampledImage
        {
            get { return M->CornerSampledImage; }
            set { M->CornerSampledImage = value; }
        }

        internal new Interop.PhysicalDeviceCornerSampledImageFeaturesNv* M
        {
            get { return (Interop.PhysicalDeviceCornerSampledImageFeaturesNv*)native.Handle; }
        }

        public PhysicalDeviceCornerSampledImageFeaturesNv()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PhysicalDeviceCornerSampledImageFeaturesNv));

            M->SType = StructureType.PhysicalDeviceCornerSampledImageFeaturesNv;
        }

        internal PhysicalDeviceCornerSampledImageFeaturesNv(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PhysicalDeviceCornerSampledImageFeaturesNv;
        }
    }

    unsafe public partial class PhysicalDeviceComputeShaderDerivativesFeaturesNv : PhysicalDeviceFeatures2
    {
        public bool ComputeDerivativeGroupQuads
        {
            get { return M->ComputeDerivativeGroupQuads; }
            set { M->ComputeDerivativeGroupQuads = value; }
        }

        public bool ComputeDerivativeGroupLinear
        {
            get { return M->ComputeDerivativeGroupLinear; }
            set { M->ComputeDerivativeGroupLinear = value; }
        }

        internal new Interop.PhysicalDeviceComputeShaderDerivativesFeaturesNv* M
        {
            get { return (Interop.PhysicalDeviceComputeShaderDerivativesFeaturesNv*)native.Handle; }
        }

        public PhysicalDeviceComputeShaderDerivativesFeaturesNv()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PhysicalDeviceComputeShaderDerivativesFeaturesNv));

            M->SType = StructureType.PhysicalDeviceComputeShaderDerivativesFeaturesNv;
        }

        internal PhysicalDeviceComputeShaderDerivativesFeaturesNv(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PhysicalDeviceComputeShaderDerivativesFeaturesNv;
        }
    }

    unsafe public partial class PhysicalDeviceFragmentShaderBarycentricFeaturesNv : PhysicalDeviceFeatures2
    {
        public bool FragmentShaderBarycentric
        {
            get { return M->FragmentShaderBarycentric; }
            set { M->FragmentShaderBarycentric = value; }
        }

        internal new Interop.PhysicalDeviceFragmentShaderBarycentricFeaturesNv* M
        {
            get { return (Interop.PhysicalDeviceFragmentShaderBarycentricFeaturesNv*)native.Handle; }
        }

        public PhysicalDeviceFragmentShaderBarycentricFeaturesNv()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PhysicalDeviceFragmentShaderBarycentricFeaturesNv));

            M->SType = StructureType.PhysicalDeviceFragmentShaderBarycentricFeaturesNv;
        }

        internal PhysicalDeviceFragmentShaderBarycentricFeaturesNv(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PhysicalDeviceFragmentShaderBarycentricFeaturesNv;
        }
    }

    unsafe public partial class PhysicalDeviceShaderImageFootprintFeaturesNv : PhysicalDeviceFeatures2
    {
        public bool ImageFootprint
        {
            get { return M->ImageFootprint; }
            set { M->ImageFootprint = value; }
        }

        internal new Interop.PhysicalDeviceShaderImageFootprintFeaturesNv* M
        {
            get { return (Interop.PhysicalDeviceShaderImageFootprintFeaturesNv*)native.Handle; }
        }

        public PhysicalDeviceShaderImageFootprintFeaturesNv()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PhysicalDeviceShaderImageFootprintFeaturesNv));

            M->SType = StructureType.PhysicalDeviceShaderImageFootprintFeaturesNv;
        }

        internal PhysicalDeviceShaderImageFootprintFeaturesNv(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PhysicalDeviceShaderImageFootprintFeaturesNv;
        }
    }

    unsafe public partial class ShadingRatePaletteNv : MarshalledObject
    {
        public UInt32 ShadingRatePaletteEntryCount
        {
            get { return M->ShadingRatePaletteEntryCount; }
            set { M->ShadingRatePaletteEntryCount = value; }
        }

        NativeReference refShadingRatePaletteEntries;
        public ShadingRatePaletteEntryNv[] ShadingRatePaletteEntries
        {
            get
            {
                if (M->ShadingRatePaletteEntryCount == 0)
                    return null;
                var values = new ShadingRatePaletteEntryNv[M->ShadingRatePaletteEntryCount];
                unsafe
                {
                    ShadingRatePaletteEntryNv* ptr = (ShadingRatePaletteEntryNv*)M->ShadingRatePaletteEntries;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->ShadingRatePaletteEntryCount = 0;
                    M->ShadingRatePaletteEntries = IntPtr.Zero;
                    return;
                }
                M->ShadingRatePaletteEntryCount = (uint)value.Length;
                refShadingRatePaletteEntries = new NativeReference((int)(sizeof(ShadingRatePaletteEntryNv) * value.Length));
                M->ShadingRatePaletteEntries = refShadingRatePaletteEntries.Handle;
                unsafe
                {
                    ShadingRatePaletteEntryNv* ptr = (ShadingRatePaletteEntryNv*)M->ShadingRatePaletteEntries;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        internal Interop.ShadingRatePaletteNv* M
        {
            get { return (Interop.ShadingRatePaletteNv*)native.Handle; }
        }

        public ShadingRatePaletteNv()
        {
            native = Interop.Structure.Allocate(typeof(Interop.ShadingRatePaletteNv));
        }

        internal ShadingRatePaletteNv(NativePointer pointer)
        {
            native = pointer;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refShadingRatePaletteEntries.Dispose();
            refShadingRatePaletteEntries = null;
        }
    }

    unsafe public partial class PipelineViewportShadingRateImageStateCreateInfoNv : PipelineViewportStateCreateInfo
    {
        public bool ShadingRateImageEnable
        {
            get { return M->ShadingRateImageEnable; }
            set { M->ShadingRateImageEnable = value; }
        }

        public new UInt32 ViewportCount
        {
            get { return M->ViewportCount; }
            set { M->ViewportCount = value; }
        }

        NativeReference refShadingRatePalettes;
        public ShadingRatePaletteNv[] ShadingRatePalettes
        {
            get
            {
                if (M->ViewportCount == 0)
                    return null;
                var values = new ShadingRatePaletteNv[M->ViewportCount];
                unsafe
                {
                    Interop.ShadingRatePaletteNv* ptr = (Interop.ShadingRatePaletteNv*)M->ShadingRatePalettes;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = new ShadingRatePaletteNv();
                        *values[i].M = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->ViewportCount = 0;
                    M->ShadingRatePalettes = IntPtr.Zero;
                    return;
                }
                M->ViewportCount = (uint)value.Length;
                refShadingRatePalettes = new NativeReference((int)(sizeof(Interop.ShadingRatePaletteNv) * value.Length));
                M->ShadingRatePalettes = refShadingRatePalettes.Handle;
                unsafe
                {
                    Interop.ShadingRatePaletteNv* ptr = (Interop.ShadingRatePaletteNv*)M->ShadingRatePalettes;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = *value[i].M;
                    }
                }
            }
        }

        internal new Interop.PipelineViewportShadingRateImageStateCreateInfoNv* M
        {
            get { return (Interop.PipelineViewportShadingRateImageStateCreateInfoNv*)native.Handle; }
        }

        public PipelineViewportShadingRateImageStateCreateInfoNv()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PipelineViewportShadingRateImageStateCreateInfoNv));

            M->SType = StructureType.PipelineViewportShadingRateImageStateCreateInfoNv;
        }

        internal PipelineViewportShadingRateImageStateCreateInfoNv(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PipelineViewportShadingRateImageStateCreateInfoNv;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refShadingRatePalettes.Dispose();
            refShadingRatePalettes = null;
        }
    }

    unsafe public partial class PhysicalDeviceShadingRateImageFeaturesNv : PhysicalDeviceFeatures2
    {
        public bool ShadingRateImage
        {
            get { return M->ShadingRateImage; }
            set { M->ShadingRateImage = value; }
        }

        public bool ShadingRateCoarseSampleOrder
        {
            get { return M->ShadingRateCoarseSampleOrder; }
            set { M->ShadingRateCoarseSampleOrder = value; }
        }

        internal new Interop.PhysicalDeviceShadingRateImageFeaturesNv* M
        {
            get { return (Interop.PhysicalDeviceShadingRateImageFeaturesNv*)native.Handle; }
        }

        public PhysicalDeviceShadingRateImageFeaturesNv()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PhysicalDeviceShadingRateImageFeaturesNv));

            M->SType = StructureType.PhysicalDeviceShadingRateImageFeaturesNv;
        }

        internal PhysicalDeviceShadingRateImageFeaturesNv(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PhysicalDeviceShadingRateImageFeaturesNv;
        }
    }

    unsafe public partial class PhysicalDeviceShadingRateImagePropertiesNv : PhysicalDeviceProperties
    {
        public Extent2D ShadingRateTexelSize
        {
            get { return M->ShadingRateTexelSize; }
            set { M->ShadingRateTexelSize = value; }
        }

        public UInt32 ShadingRatePaletteSize
        {
            get { return M->ShadingRatePaletteSize; }
            set { M->ShadingRatePaletteSize = value; }
        }

        public UInt32 ShadingRateMaxCoarseSamples
        {
            get { return M->ShadingRateMaxCoarseSamples; }
            set { M->ShadingRateMaxCoarseSamples = value; }
        }

        internal new Interop.PhysicalDeviceShadingRateImagePropertiesNv* M
        {
            get { return (Interop.PhysicalDeviceShadingRateImagePropertiesNv*)native.Handle; }
        }

        public PhysicalDeviceShadingRateImagePropertiesNv()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PhysicalDeviceShadingRateImagePropertiesNv));

            M->SType = StructureType.PhysicalDeviceShadingRateImagePropertiesNv;
        }

        internal PhysicalDeviceShadingRateImagePropertiesNv(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PhysicalDeviceShadingRateImagePropertiesNv;
        }
    }

    unsafe public partial struct CoarseSampleLocationNv
    {
        public UInt32 PixelX;
        public UInt32 PixelY;
        public UInt32 Sample;
    }

    unsafe public partial class CoarseSampleOrderCustomNv : MarshalledObject
    {
        public ShadingRatePaletteEntryNv ShadingRate
        {
            get { return M->ShadingRate; }
            set { M->ShadingRate = value; }
        }

        public UInt32 SampleCount
        {
            get { return M->SampleCount; }
            set { M->SampleCount = value; }
        }

        public UInt32 SampleLocationCount
        {
            get { return M->SampleLocationCount; }
            set { M->SampleLocationCount = value; }
        }

        NativeReference refSampleLocations;
        public CoarseSampleLocationNv[] SampleLocations
        {
            get
            {
                if (M->SampleLocationCount == 0)
                    return null;
                var values = new CoarseSampleLocationNv[M->SampleLocationCount];
                unsafe
                {
                    CoarseSampleLocationNv* ptr = (CoarseSampleLocationNv*)M->SampleLocations;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->SampleLocationCount = 0;
                    M->SampleLocations = IntPtr.Zero;
                    return;
                }
                M->SampleLocationCount = (uint)value.Length;
                refSampleLocations = new NativeReference((int)(sizeof(CoarseSampleLocationNv) * value.Length));
                M->SampleLocations = refSampleLocations.Handle;
                unsafe
                {
                    CoarseSampleLocationNv* ptr = (CoarseSampleLocationNv*)M->SampleLocations;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        internal Interop.CoarseSampleOrderCustomNv* M
        {
            get { return (Interop.CoarseSampleOrderCustomNv*)native.Handle; }
        }

        public CoarseSampleOrderCustomNv()
        {
            native = Interop.Structure.Allocate(typeof(Interop.CoarseSampleOrderCustomNv));
        }

        internal CoarseSampleOrderCustomNv(NativePointer pointer)
        {
            native = pointer;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refSampleLocations.Dispose();
            refSampleLocations = null;
        }
    }

    unsafe public partial class PipelineViewportCoarseSampleOrderStateCreateInfoNv : PipelineViewportStateCreateInfo
    {
        public CoarseSampleOrderTypeNv SampleOrderType
        {
            get { return M->SampleOrderType; }
            set { M->SampleOrderType = value; }
        }

        public UInt32 CustomSampleOrderCount
        {
            get { return M->CustomSampleOrderCount; }
            set { M->CustomSampleOrderCount = value; }
        }

        NativeReference refCustomSampleOrders;
        public CoarseSampleOrderCustomNv[] CustomSampleOrders
        {
            get
            {
                if (M->CustomSampleOrderCount == 0)
                    return null;
                var values = new CoarseSampleOrderCustomNv[M->CustomSampleOrderCount];
                unsafe
                {
                    Interop.CoarseSampleOrderCustomNv* ptr = (Interop.CoarseSampleOrderCustomNv*)M->CustomSampleOrders;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = new CoarseSampleOrderCustomNv();
                        *values[i].M = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->CustomSampleOrderCount = 0;
                    M->CustomSampleOrders = IntPtr.Zero;
                    return;
                }
                M->CustomSampleOrderCount = (uint)value.Length;
                refCustomSampleOrders = new NativeReference((int)(sizeof(Interop.CoarseSampleOrderCustomNv) * value.Length));
                M->CustomSampleOrders = refCustomSampleOrders.Handle;
                unsafe
                {
                    Interop.CoarseSampleOrderCustomNv* ptr = (Interop.CoarseSampleOrderCustomNv*)M->CustomSampleOrders;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = *value[i].M;
                    }
                }
            }
        }

        internal new Interop.PipelineViewportCoarseSampleOrderStateCreateInfoNv* M
        {
            get { return (Interop.PipelineViewportCoarseSampleOrderStateCreateInfoNv*)native.Handle; }
        }

        public PipelineViewportCoarseSampleOrderStateCreateInfoNv()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PipelineViewportCoarseSampleOrderStateCreateInfoNv));

            M->SType = StructureType.PipelineViewportCoarseSampleOrderStateCreateInfoNv;
        }

        internal PipelineViewportCoarseSampleOrderStateCreateInfoNv(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PipelineViewportCoarseSampleOrderStateCreateInfoNv;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refCustomSampleOrders.Dispose();
            refCustomSampleOrders = null;
        }
    }

    unsafe public partial class PhysicalDeviceMeshShaderFeaturesNv : PhysicalDeviceFeatures2
    {
        public bool TaskShader
        {
            get { return M->TaskShader; }
            set { M->TaskShader = value; }
        }

        public bool MeshShader
        {
            get { return M->MeshShader; }
            set { M->MeshShader = value; }
        }

        internal new Interop.PhysicalDeviceMeshShaderFeaturesNv* M
        {
            get { return (Interop.PhysicalDeviceMeshShaderFeaturesNv*)native.Handle; }
        }

        public PhysicalDeviceMeshShaderFeaturesNv()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PhysicalDeviceMeshShaderFeaturesNv));

            M->SType = StructureType.PhysicalDeviceMeshShaderFeaturesNv;
        }

        internal PhysicalDeviceMeshShaderFeaturesNv(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PhysicalDeviceMeshShaderFeaturesNv;
        }
    }

    unsafe public partial class PhysicalDeviceMeshShaderPropertiesNv : PhysicalDeviceProperties2
    {
        public UInt32 MaxDrawMeshTasksCount
        {
            get { return M->MaxDrawMeshTasksCount; }
            set { M->MaxDrawMeshTasksCount = value; }
        }

        public UInt32 MaxTaskWorkGroupInvocations
        {
            get { return M->MaxTaskWorkGroupInvocations; }
            set { M->MaxTaskWorkGroupInvocations = value; }
        }

        public UInt32[] MaxTaskWorkGroupSize
        {
            get
            {
                var arr = new UInt32[3];
                for (int i = 0; i < 3; i++)
                    arr[i] = M->MaxTaskWorkGroupSize[i];
                return arr;
            }
            set
            {
                if (value.Length > 3)
                    throw new Exception("array too long");
                for (int i = 0; i < value.Length; i++)
                    M->MaxTaskWorkGroupSize[i] = value[i];
                for (int i = value.Length; i < 3; i++)
                    M->MaxTaskWorkGroupSize[i] = 0;
            }
        }

        public UInt32 MaxTaskTotalMemorySize
        {
            get { return M->MaxTaskTotalMemorySize; }
            set { M->MaxTaskTotalMemorySize = value; }
        }

        public UInt32 MaxTaskOutputCount
        {
            get { return M->MaxTaskOutputCount; }
            set { M->MaxTaskOutputCount = value; }
        }

        public UInt32 MaxMeshWorkGroupInvocations
        {
            get { return M->MaxMeshWorkGroupInvocations; }
            set { M->MaxMeshWorkGroupInvocations = value; }
        }

        public UInt32[] MaxMeshWorkGroupSize
        {
            get
            {
                var arr = new UInt32[3];
                for (int i = 0; i < 3; i++)
                    arr[i] = M->MaxMeshWorkGroupSize[i];
                return arr;
            }
            set
            {
                if (value.Length > 3)
                    throw new Exception("array too long");
                for (int i = 0; i < value.Length; i++)
                    M->MaxMeshWorkGroupSize[i] = value[i];
                for (int i = value.Length; i < 3; i++)
                    M->MaxMeshWorkGroupSize[i] = 0;
            }
        }

        public UInt32 MaxMeshTotalMemorySize
        {
            get { return M->MaxMeshTotalMemorySize; }
            set { M->MaxMeshTotalMemorySize = value; }
        }

        public UInt32 MaxMeshOutputVertices
        {
            get { return M->MaxMeshOutputVertices; }
            set { M->MaxMeshOutputVertices = value; }
        }

        public UInt32 MaxMeshOutputPrimitives
        {
            get { return M->MaxMeshOutputPrimitives; }
            set { M->MaxMeshOutputPrimitives = value; }
        }

        public UInt32 MaxMeshMultiviewViewCount
        {
            get { return M->MaxMeshMultiviewViewCount; }
            set { M->MaxMeshMultiviewViewCount = value; }
        }

        public UInt32 MeshOutputPerVertexGranularity
        {
            get { return M->MeshOutputPerVertexGranularity; }
            set { M->MeshOutputPerVertexGranularity = value; }
        }

        public UInt32 MeshOutputPerPrimitiveGranularity
        {
            get { return M->MeshOutputPerPrimitiveGranularity; }
            set { M->MeshOutputPerPrimitiveGranularity = value; }
        }

        internal new Interop.PhysicalDeviceMeshShaderPropertiesNv* M
        {
            get { return (Interop.PhysicalDeviceMeshShaderPropertiesNv*)native.Handle; }
        }

        public PhysicalDeviceMeshShaderPropertiesNv()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PhysicalDeviceMeshShaderPropertiesNv));

            M->SType = StructureType.PhysicalDeviceMeshShaderPropertiesNv;
        }

        internal PhysicalDeviceMeshShaderPropertiesNv(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PhysicalDeviceMeshShaderPropertiesNv;
        }
    }

    unsafe public partial struct DrawMeshTasksIndirectCommandNv
    {
        public UInt32 TaskCount;
        public UInt32 FirstTask;
    }

    unsafe public partial class RaytracingPipelineCreateInfoNvx : MarshalledObject
    {
        /// <summary>
        /// Pipeline creation flags
        /// </summary>
        public PipelineCreateFlags Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        public UInt32 StageCount
        {
            get { return M->StageCount; }
            set { M->StageCount = value; }
        }

        /// <summary>
        /// One entry for each active shader stage
        /// </summary>
        NativeReference refStages;
        public PipelineShaderStageCreateInfo[] Stages
        {
            get
            {
                if (M->StageCount == 0)
                    return null;
                var values = new PipelineShaderStageCreateInfo[M->StageCount];
                unsafe
                {
                    Interop.PipelineShaderStageCreateInfo* ptr = (Interop.PipelineShaderStageCreateInfo*)M->Stages;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = new PipelineShaderStageCreateInfo();
                        *values[i].M = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->StageCount = 0;
                    M->Stages = IntPtr.Zero;
                    return;
                }
                M->StageCount = (uint)value.Length;
                refStages = new NativeReference((int)(sizeof(Interop.PipelineShaderStageCreateInfo) * value.Length));
                M->Stages = refStages.Handle;
                unsafe
                {
                    Interop.PipelineShaderStageCreateInfo* ptr = (Interop.PipelineShaderStageCreateInfo*)M->Stages;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = *value[i].M;
                    }
                }
            }
        }

        /// <summary>
        /// One entry for each stage used as the query index and for grouping
        /// </summary>
        NativeReference refGroupNumbers;
        public UInt32[] GroupNumbers
        {
            get
            {
                if (M->StageCount == 0)
                    return null;
                var values = new UInt32[M->StageCount];
                unsafe
                {
                    UInt32* ptr = (UInt32*)M->GroupNumbers;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->StageCount = 0;
                    M->GroupNumbers = IntPtr.Zero;
                    return;
                }
                M->StageCount = (uint)value.Length;
                refGroupNumbers = new NativeReference((int)(sizeof(UInt32) * value.Length));
                M->GroupNumbers = refGroupNumbers.Handle;
                unsafe
                {
                    UInt32* ptr = (UInt32*)M->GroupNumbers;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        public UInt32 MaxRecursionDepth
        {
            get { return M->MaxRecursionDepth; }
            set { M->MaxRecursionDepth = value; }
        }

        /// <summary>
        /// Interface layout of the pipeline
        /// </summary>
        PipelineLayout lLayout;
        public PipelineLayout Layout
        {
            get { return lLayout; }
            set { lLayout = value; M->Layout = value != null ? (UInt64)value.M : default(UInt64); }
        }

        /// <summary>
        /// If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of
        /// </summary>
        Pipeline lBasePipelineHandle;
        public Pipeline BasePipelineHandle
        {
            get { return lBasePipelineHandle; }
            set { lBasePipelineHandle = value; M->BasePipelineHandle = value != null ? (UInt64)value.M : default(UInt64); }
        }

        /// <summary>
        /// If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of
        /// </summary>
        public Int32 BasePipelineIndex
        {
            get { return M->BasePipelineIndex; }
            set { M->BasePipelineIndex = value; }
        }

        internal Interop.RaytracingPipelineCreateInfoNvx* M
        {
            get { return (Interop.RaytracingPipelineCreateInfoNvx*)native.Handle; }
        }

        public RaytracingPipelineCreateInfoNvx()
        {
            native = Interop.Structure.Allocate(typeof(Interop.RaytracingPipelineCreateInfoNvx));

            M->SType = StructureType.RaytracingPipelineCreateInfoNvx;
        }

        internal RaytracingPipelineCreateInfoNvx(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.RaytracingPipelineCreateInfoNvx;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refStages.Dispose();
            refStages = null;
            refGroupNumbers.Dispose();
            refGroupNumbers = null;
        }
    }

    unsafe public partial class GeometryTrianglesNvx : MarshalledObject
    {
        Buffer lVertexData;
        public Buffer VertexData
        {
            get { return lVertexData; }
            set { lVertexData = value; M->VertexData = value != null ? (UInt64)value.M : default(UInt64); }
        }

        public DeviceSize VertexOffset
        {
            get { return M->VertexOffset; }
            set { M->VertexOffset = value; }
        }

        public UInt32 VertexCount
        {
            get { return M->VertexCount; }
            set { M->VertexCount = value; }
        }

        public DeviceSize VertexStride
        {
            get { return M->VertexStride; }
            set { M->VertexStride = value; }
        }

        /// <summary>
        /// VK_FORMAT_R32G32B32_SFLOAT, VK_FORMAT_R32G32B32A32_SFLOAT, VK_FORMAT_R16G16B16_SFLOAT, or VK_FORMAT_R16G16B16A16_SFLOAT
        /// </summary>
        public Format VertexFormat
        {
            get { return M->VertexFormat; }
            set { M->VertexFormat = value; }
        }

        Buffer lIndexData;
        public Buffer IndexData
        {
            get { return lIndexData; }
            set { lIndexData = value; M->IndexData = value != null ? (UInt64)value.M : default(UInt64); }
        }

        public DeviceSize IndexOffset
        {
            get { return M->IndexOffset; }
            set { M->IndexOffset = value; }
        }

        public UInt32 IndexCount
        {
            get { return M->IndexCount; }
            set { M->IndexCount = value; }
        }

        public IndexType IndexType
        {
            get { return M->IndexType; }
            set { M->IndexType = value; }
        }

        /// <summary>
        /// Optional reference to array of floats representing a 3x4 row major affine transformation matrix.
        /// </summary>
        Buffer lTransformData;
        public Buffer TransformData
        {
            get { return lTransformData; }
            set { lTransformData = value; M->TransformData = value != null ? (UInt64)value.M : default(UInt64); }
        }

        public DeviceSize TransformOffset
        {
            get { return M->TransformOffset; }
            set { M->TransformOffset = value; }
        }

        internal Interop.GeometryTrianglesNvx* M
        {
            get { return (Interop.GeometryTrianglesNvx*)native.Handle; }
        }

        public GeometryTrianglesNvx()
        {
            native = Interop.Structure.Allocate(typeof(Interop.GeometryTrianglesNvx));

            M->SType = StructureType.GeometryTrianglesNvx;
        }

        internal GeometryTrianglesNvx(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.GeometryTrianglesNvx;
        }
    }

    unsafe public partial class GeometryAABBNvx : MarshalledObject
    {
        Buffer lAabbData;
        public Buffer AabbData
        {
            get { return lAabbData; }
            set { lAabbData = value; M->AabbData = value != null ? (UInt64)value.M : default(UInt64); }
        }

        public UInt32 NumAabbs
        {
            get { return M->NumAabbs; }
            set { M->NumAabbs = value; }
        }

        /// <summary>
        /// Stride in bytes between AABBs
        /// </summary>
        public UInt32 Stride
        {
            get { return M->Stride; }
            set { M->Stride = value; }
        }

        /// <summary>
        /// Offset in bytes of the first AABB in aabbData
        /// </summary>
        public DeviceSize Offset
        {
            get { return M->Offset; }
            set { M->Offset = value; }
        }

        internal Interop.GeometryAABBNvx* M
        {
            get { return (Interop.GeometryAABBNvx*)native.Handle; }
        }

        public GeometryAABBNvx()
        {
            native = Interop.Structure.Allocate(typeof(Interop.GeometryAABBNvx));

            M->SType = StructureType.GeometryAABBNvx;
        }

        internal GeometryAABBNvx(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.GeometryAABBNvx;
        }
    }

    unsafe public partial class GeometryDataNvx : MarshalledObject
    {
        GeometryTrianglesNvx lTriangles;
        public GeometryTrianglesNvx Triangles
        {
            get { return lTriangles; }
            set { lTriangles = value; M->Triangles = value != null ? *value.M : default(Interop.GeometryTrianglesNvx); }
        }

        GeometryAABBNvx lAabbs;
        public GeometryAABBNvx Aabbs
        {
            get { return lAabbs; }
            set { lAabbs = value; M->Aabbs = value != null ? *value.M : default(Interop.GeometryAABBNvx); }
        }

        internal Interop.GeometryDataNvx* M
        {
            get { return (Interop.GeometryDataNvx*)native.Handle; }
        }

        public GeometryDataNvx()
        {
            native = Interop.Structure.Allocate(typeof(Interop.GeometryDataNvx));

            lTriangles = new GeometryTrianglesNvx(new NativePointer(native.Reference, (IntPtr)(&M->Triangles)));
            lAabbs = new GeometryAABBNvx(new NativePointer(native.Reference, (IntPtr)(&M->Aabbs)));
        }

        internal GeometryDataNvx(NativePointer pointer)
        {
            native = pointer;

            lTriangles = new GeometryTrianglesNvx(new NativePointer(native.Reference, (IntPtr)(&M->Triangles)));
            lAabbs = new GeometryAABBNvx(new NativePointer(native.Reference, (IntPtr)(&M->Aabbs)));
        }
    }

    unsafe public partial class GeometryNvx : MarshalledObject
    {
        public GeometryTypeNvx GeometryType
        {
            get { return M->GeometryType; }
            set { M->GeometryType = value; }
        }

        GeometryDataNvx lGeometry;
        public GeometryDataNvx Geometry
        {
            get { return lGeometry; }
            set { lGeometry = value; M->Geometry = value != null ? *value.M : default(Interop.GeometryDataNvx); }
        }

        public GeometryFlagsNvx Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        internal Interop.GeometryNvx* M
        {
            get { return (Interop.GeometryNvx*)native.Handle; }
        }

        public GeometryNvx()
        {
            native = Interop.Structure.Allocate(typeof(Interop.GeometryNvx));

            M->SType = StructureType.GeometryNvx;
            lGeometry = new GeometryDataNvx(new NativePointer(native.Reference, (IntPtr)(&M->Geometry)));
        }

        internal GeometryNvx(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.GeometryNvx;
            lGeometry = new GeometryDataNvx(new NativePointer(native.Reference, (IntPtr)(&M->Geometry)));
        }
    }

    unsafe public partial class AccelerationStructureCreateInfoNvx : MarshalledObject
    {
        public AccelerationStructureTypeNvx Type
        {
            get { return M->Type; }
            set { M->Type = value; }
        }

        public BuildAccelerationStructureFlagsNvx Flags
        {
            get { return M->Flags; }
            set { M->Flags = value; }
        }

        public DeviceSize CompactedSize
        {
            get { return M->CompactedSize; }
            set { M->CompactedSize = value; }
        }

        public UInt32 InstanceCount
        {
            get { return M->InstanceCount; }
            set { M->InstanceCount = value; }
        }

        public UInt32 GeometryCount
        {
            get { return M->GeometryCount; }
            set { M->GeometryCount = value; }
        }

        NativeReference refGeometries;
        public GeometryNvx[] Geometries
        {
            get
            {
                if (M->GeometryCount == 0)
                    return null;
                var values = new GeometryNvx[M->GeometryCount];
                unsafe
                {
                    Interop.GeometryNvx* ptr = (Interop.GeometryNvx*)M->Geometries;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = new GeometryNvx();
                        *values[i].M = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->GeometryCount = 0;
                    M->Geometries = IntPtr.Zero;
                    return;
                }
                M->GeometryCount = (uint)value.Length;
                refGeometries = new NativeReference((int)(sizeof(Interop.GeometryNvx) * value.Length));
                M->Geometries = refGeometries.Handle;
                unsafe
                {
                    Interop.GeometryNvx* ptr = (Interop.GeometryNvx*)M->Geometries;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = *value[i].M;
                    }
                }
            }
        }

        internal Interop.AccelerationStructureCreateInfoNvx* M
        {
            get { return (Interop.AccelerationStructureCreateInfoNvx*)native.Handle; }
        }

        public AccelerationStructureCreateInfoNvx()
        {
            native = Interop.Structure.Allocate(typeof(Interop.AccelerationStructureCreateInfoNvx));

            M->SType = StructureType.AccelerationStructureCreateInfoNvx;
        }

        internal AccelerationStructureCreateInfoNvx(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.AccelerationStructureCreateInfoNvx;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refGeometries.Dispose();
            refGeometries = null;
        }
    }

    unsafe public partial class BindAccelerationStructureMemoryInfoNvx : MarshalledObject
    {
        AccelerationStructureNvx lAccelerationStructure;
        public AccelerationStructureNvx AccelerationStructure
        {
            get { return lAccelerationStructure; }
            set { lAccelerationStructure = value; M->AccelerationStructure = value != null ? (UInt64)value.M : default(UInt64); }
        }

        DeviceMemory lMemory;
        public DeviceMemory Memory
        {
            get { return lMemory; }
            set { lMemory = value; M->Memory = value != null ? (UInt64)value.M : default(UInt64); }
        }

        public DeviceSize MemoryOffset
        {
            get { return M->MemoryOffset; }
            set { M->MemoryOffset = value; }
        }

        public UInt32 DeviceIndexCount
        {
            get { return M->DeviceIndexCount; }
            set { M->DeviceIndexCount = value; }
        }

        NativeReference refDeviceIndices;
        public UInt32[] DeviceIndices
        {
            get
            {
                if (M->DeviceIndexCount == 0)
                    return null;
                var values = new UInt32[M->DeviceIndexCount];
                unsafe
                {
                    UInt32* ptr = (UInt32*)M->DeviceIndices;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->DeviceIndexCount = 0;
                    M->DeviceIndices = IntPtr.Zero;
                    return;
                }
                M->DeviceIndexCount = (uint)value.Length;
                refDeviceIndices = new NativeReference((int)(sizeof(UInt32) * value.Length));
                M->DeviceIndices = refDeviceIndices.Handle;
                unsafe
                {
                    UInt32* ptr = (UInt32*)M->DeviceIndices;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i];
                    }
                }
            }
        }

        internal Interop.BindAccelerationStructureMemoryInfoNvx* M
        {
            get { return (Interop.BindAccelerationStructureMemoryInfoNvx*)native.Handle; }
        }

        public BindAccelerationStructureMemoryInfoNvx()
        {
            native = Interop.Structure.Allocate(typeof(Interop.BindAccelerationStructureMemoryInfoNvx));

            M->SType = StructureType.BindAccelerationStructureMemoryInfoNvx;
        }

        internal BindAccelerationStructureMemoryInfoNvx(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.BindAccelerationStructureMemoryInfoNvx;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refDeviceIndices.Dispose();
            refDeviceIndices = null;
        }
    }

    unsafe public partial class DescriptorAccelerationStructureInfoNvx : WriteDescriptorSet
    {
        public UInt32 AccelerationStructureCount
        {
            get { return M->AccelerationStructureCount; }
            set { M->AccelerationStructureCount = value; }
        }

        NativeReference refAccelerationStructures;
        public AccelerationStructureNvx[] AccelerationStructures
        {
            get
            {
                if (M->AccelerationStructureCount == 0)
                    return null;
                var values = new AccelerationStructureNvx[M->AccelerationStructureCount];
                unsafe
                {
                    UInt64* ptr = (UInt64*)M->AccelerationStructures;
                    for (int i = 0; i < values.Length; i++)
                    {
                        values[i] = new AccelerationStructureNvx();
                        values[i].M = ptr[i];
                    }
                }
                return values;
            }
            set
            {
                if (value == null)
                {
                    M->AccelerationStructureCount = 0;
                    M->AccelerationStructures = IntPtr.Zero;
                    return;
                }
                M->AccelerationStructureCount = (uint)value.Length;
                refAccelerationStructures = new NativeReference((int)(sizeof(UInt64) * value.Length));
                M->AccelerationStructures = refAccelerationStructures.Handle;
                unsafe
                {
                    UInt64* ptr = (UInt64*)M->AccelerationStructures;
                    for (int i = 0; i < value.Length; i++)
                    {
                        ptr[i] = value[i].M;
                    }
                }
            }
        }

        internal new Interop.DescriptorAccelerationStructureInfoNvx* M
        {
            get { return (Interop.DescriptorAccelerationStructureInfoNvx*)native.Handle; }
        }

        public DescriptorAccelerationStructureInfoNvx()
        {
            native = Interop.Structure.Allocate(typeof(Interop.DescriptorAccelerationStructureInfoNvx));

            M->SType = StructureType.DescriptorAccelerationStructureInfoNvx;
        }

        internal DescriptorAccelerationStructureInfoNvx(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.DescriptorAccelerationStructureInfoNvx;
        }

        override public void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!disposing)
                return;
            refAccelerationStructures.Dispose();
            refAccelerationStructures = null;
        }
    }

    unsafe public partial class AccelerationStructureMemoryRequirementsInfoNvx : MarshalledObject
    {
        AccelerationStructureNvx lAccelerationStructure;
        public AccelerationStructureNvx AccelerationStructure
        {
            get { return lAccelerationStructure; }
            set { lAccelerationStructure = value; M->AccelerationStructure = value != null ? (UInt64)value.M : default(UInt64); }
        }

        internal Interop.AccelerationStructureMemoryRequirementsInfoNvx* M
        {
            get { return (Interop.AccelerationStructureMemoryRequirementsInfoNvx*)native.Handle; }
        }

        public AccelerationStructureMemoryRequirementsInfoNvx()
        {
            native = Interop.Structure.Allocate(typeof(Interop.AccelerationStructureMemoryRequirementsInfoNvx));

            M->SType = StructureType.AccelerationStructureMemoryRequirementsInfoNvx;
        }

        internal AccelerationStructureMemoryRequirementsInfoNvx(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.AccelerationStructureMemoryRequirementsInfoNvx;
        }
    }

    unsafe public partial class PhysicalDeviceRaytracingPropertiesNvx : PhysicalDeviceProperties2
    {
        public UInt32 ShaderHeaderSize
        {
            get { return M->ShaderHeaderSize; }
            set { M->ShaderHeaderSize = value; }
        }

        public UInt32 MaxRecursionDepth
        {
            get { return M->MaxRecursionDepth; }
            set { M->MaxRecursionDepth = value; }
        }

        public UInt32 MaxGeometryCount
        {
            get { return M->MaxGeometryCount; }
            set { M->MaxGeometryCount = value; }
        }

        internal new Interop.PhysicalDeviceRaytracingPropertiesNvx* M
        {
            get { return (Interop.PhysicalDeviceRaytracingPropertiesNvx*)native.Handle; }
        }

        public PhysicalDeviceRaytracingPropertiesNvx()
        {
            native = Interop.Structure.Allocate(typeof(Interop.PhysicalDeviceRaytracingPropertiesNvx));

            M->SType = StructureType.PhysicalDeviceRaytracingPropertiesNvx;
        }

        internal PhysicalDeviceRaytracingPropertiesNvx(NativePointer pointer)
        {
            native = pointer;

            M->SType = StructureType.PhysicalDeviceRaytracingPropertiesNvx;
        }
    }
}

